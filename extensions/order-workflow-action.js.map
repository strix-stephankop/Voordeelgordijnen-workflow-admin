{
  "version": 3,
  "sources": ["../../../../node_modules/react/cjs/react.development.js", "../../../../node_modules/react/index.js", "../../../../node_modules/scheduler/cjs/scheduler.development.js", "../../../../node_modules/scheduler/index.js", "../../../../node_modules/react-reconciler/cjs/react-reconciler.development.js", "../../../../node_modules/react-reconciler/index.js", "../../../../node_modules/react/cjs/react-jsx-runtime.development.js", "../../../../node_modules/react/jsx-runtime.js", "../../../../extensions/order-workflow-action/src/ActionExtension.jsx", "../../../../node_modules/@remote-ui/rpc/build/esm/memory.mjs", "../../../../node_modules/@remote-ui/core/build/esm/utilities.mjs", "../../../../node_modules/@remote-ui/core/build/esm/root.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/utilities/registration.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/admin/extension.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/admin/components/AdminAction/AdminAction.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/admin/components/Banner/Banner.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/admin/components/BlockStack/BlockStack.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/admin/components/Button/Button.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/admin/components/Link/Link.mjs", "../../../../node_modules/@shopify/ui-extensions/build/esm/surfaces/admin/components/ProgressIndicator/ProgressIndicator.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/context.mjs", "../../../../node_modules/@remote-ui/react/build/esm/render.mjs", "../../../../node_modules/@remote-ui/react/build/esm/reconciler.mjs", "../../../../node_modules/@remote-ui/react/build/esm/context.mjs", "../../../../node_modules/@remote-ui/react/build/esm/components.mjs", "../../../../node_modules/@remote-ui/react/build/esm/hooks/render.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/utilities/remoteRootRender.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/render.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/components/AdminAction/AdminAction.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/components/Banner/Banner.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/components/BlockStack/BlockStack.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/components/Button/Button.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/components/Link/Link.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/components/ProgressIndicator/ProgressIndicator.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/hooks/api.mjs", "../../../../node_modules/@shopify/ui-extensions-react/build/esm/surfaces/admin/errors.mjs"],
  "sourceRoot": "/Users/stephankop/Documents/Strix/vogo-admin-app/vogo-workflow-admin/extensions/order-workflow-action/src",
  "sourcesContent": ["/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var ReactVersion = '18.3.1';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  transition: null\n};\n\nvar ReactCurrentActQueue = {\n  current: null,\n  // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n  isBatchingLegacy: false,\n  didScheduleLegacyUpdate: false\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar ReactDebugCurrentFrame = {};\nvar currentExtraStackFrame = null;\nfunction setExtraStackFrame(stack) {\n  {\n    currentExtraStackFrame = stack;\n  }\n}\n\n{\n  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n    {\n      currentExtraStackFrame = stack;\n    }\n  }; // Stack implementation injected by the current renderer.\n\n\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentExtraStackFrame) {\n      stack += currentExtraStackFrame;\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner\n};\n\n{\n  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n  ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n}\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar assign = Object.assign;\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n    throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n  }\n\n  var propName; // Original props are copied\n\n  var props = assign({}, element.props); // Reserved names are extracted\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = key.replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getElementKey(element, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    {\n      checkKeyStringCoercion(element.key);\n    }\n\n    return escape('' + element.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    var _child = children;\n    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n\n    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n    if (isArray(mappedChild)) {\n      var escapedChildKey = '';\n\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n\n      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n        return c;\n      });\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n            checkKeyStringCoercion(mappedChild.key);\n          }\n        }\n\n        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n      }\n\n      array.push(mappedChild);\n    }\n\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      var iterableChildren = children;\n\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(iterableChildren);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n      }\n    } else if (type === 'object') {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      var childrenString = String(children);\n      throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  var count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  var n = 0;\n  mapChildren(children, function () {\n    n++; // Don't return anything\n  });\n  return n;\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  mapChildren(children, function () {\n    forEachFunc.apply(this, arguments); // Don't return anything.\n  }, forEachContext);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  return mapChildren(children, function (child) {\n    return child;\n  }) || [];\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    throw new Error('React.Children.only expected to receive a single React element child.');\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue) {\n  // TODO: Second argument used to be an optional `calculateChangedBits`\n  // function. Warn to reserve for future use?\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null,\n    // Add these to use same hidden class in VM as ServerContext\n    _defaultValue: null,\n    _globalName: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n  var hasWarnedAboutDisplayNameOnConsumer = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n\n            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n\n            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      },\n      displayName: {\n        get: function () {\n          return context.displayName;\n        },\n        set: function (displayName) {\n          if (!hasWarnedAboutDisplayNameOnConsumer) {\n            warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n\n            hasWarnedAboutDisplayNameOnConsumer = true;\n          }\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nvar Uninitialized = -1;\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction lazyInitializer(payload) {\n  if (payload._status === Uninitialized) {\n    var ctor = payload._result;\n    var thenable = ctor(); // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n\n    thenable.then(function (moduleObject) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var resolved = payload;\n        resolved._status = Resolved;\n        resolved._result = moduleObject;\n      }\n    }, function (error) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var rejected = payload;\n        rejected._status = Rejected;\n        rejected._result = error;\n      }\n    });\n\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      var pending = payload;\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n\n  if (payload._status === Resolved) {\n    var moduleObject = payload._result;\n\n    {\n      if (moduleObject === undefined) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n      }\n    }\n\n    {\n      if (!('default' in moduleObject)) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n      }\n    }\n\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nfunction lazy(ctor) {\n  var payload = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor\n  };\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes; // $FlowFixMe\n\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          propTypes = newPropTypes; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null || render.propTypes != null) {\n        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n      }\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!render.name && !render.displayName) {\n          render.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!type.name && !type.displayName) {\n          type.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  {\n    if (dispatcher === null) {\n      error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n    }\n  } // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n\n\n  return dispatcher;\n}\nfunction useContext(Context) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    // TODO: add a more generic warning for invalid values.\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nfunction useInsertionEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\nfunction useLayoutEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nfunction useCallback(callback, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nfunction useMemo(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nfunction useImperativeHandle(ref, create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\nfunction useTransition() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\nfunction useDeferredValue(value) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\nfunction useId() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher$1.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher$1.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      setExtraStackFrame(stack);\n    } else {\n      setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n  }\n\n  {\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    {\n      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nvar didWarnAboutDeprecatedCreateFactory = false;\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n\n      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nfunction startTransition(scope, options) {\n  var prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = {};\n  var currentTransition = ReactCurrentBatchConfig.transition;\n\n  {\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n  }\n\n  try {\n    scope();\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nvar didWarnAboutMessageChannel = false;\nvar enqueueTaskImpl = null;\nfunction enqueueTask(task) {\n  if (enqueueTaskImpl === null) {\n    try {\n      // read require off the module object to get around the bundlers.\n      // we don't want them to detect a require and bundle a Node polyfill.\n      var requireString = ('require' + Math.random()).slice(0, 7);\n      var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n      // version of setImmediate, bypassing fake timers if any.\n\n      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n    } catch (_err) {\n      // we're in a browser\n      // we can't use regular timers because they may still be faked\n      // so we try MessageChannel+postMessage instead\n      enqueueTaskImpl = function (callback) {\n        {\n          if (didWarnAboutMessageChannel === false) {\n            didWarnAboutMessageChannel = true;\n\n            if (typeof MessageChannel === 'undefined') {\n              error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n            }\n          }\n        }\n\n        var channel = new MessageChannel();\n        channel.port1.onmessage = callback;\n        channel.port2.postMessage(undefined);\n      };\n    }\n  }\n\n  return enqueueTaskImpl(task);\n}\n\nvar actScopeDepth = 0;\nvar didWarnNoAwaitAct = false;\nfunction act(callback) {\n  {\n    // `act` calls can be nested, so we track the depth. This represents the\n    // number of `act` scopes on the stack.\n    var prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n\n    if (ReactCurrentActQueue.current === null) {\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\n      // will detect the queue and use it instead of Scheduler.\n      ReactCurrentActQueue.current = [];\n    }\n\n    var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    var result;\n\n    try {\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n      // set to `true` while the given callback is executed, not for updates\n      // triggered during an async event, because this is how the legacy\n      // implementation of `act` behaved.\n      ReactCurrentActQueue.isBatchingLegacy = true;\n      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n\n      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n        var queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n          flushActQueue(queue);\n        }\n      }\n    } catch (error) {\n      popActScope(prevActScopeDepth);\n      throw error;\n    } finally {\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    }\n\n    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n      var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n      // for it to resolve before exiting the current scope.\n\n      var wasAwaited = false;\n      var thenable = {\n        then: function (resolve, reject) {\n          wasAwaited = true;\n          thenableResult.then(function (returnValue) {\n            popActScope(prevActScopeDepth);\n\n            if (actScopeDepth === 0) {\n              // We've exited the outermost act scope. Recursively flush the\n              // queue until there's no remaining work.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }, function (error) {\n            // The callback threw an error.\n            popActScope(prevActScopeDepth);\n            reject(error);\n          });\n        }\n      };\n\n      {\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n          // eslint-disable-next-line no-undef\n          Promise.resolve().then(function () {}).then(function () {\n            if (!wasAwaited) {\n              didWarnNoAwaitAct = true;\n\n              error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n            }\n          });\n        }\n      }\n\n      return thenable;\n    } else {\n      var returnValue = result; // The callback is not an async function. Exit the current scope\n      // immediately, without awaiting.\n\n      popActScope(prevActScopeDepth);\n\n      if (actScopeDepth === 0) {\n        // Exiting the outermost act scope. Flush the queue.\n        var _queue = ReactCurrentActQueue.current;\n\n        if (_queue !== null) {\n          flushActQueue(_queue);\n          ReactCurrentActQueue.current = null;\n        } // Return a thenable. If the user awaits it, we'll flush again in\n        // case additional work was scheduled by a microtask.\n\n\n        var _thenable = {\n          then: function (resolve, reject) {\n            // Confirm we haven't re-entered another `act` scope, in case\n            // the user does something weird like await the thenable\n            // multiple times.\n            if (ReactCurrentActQueue.current === null) {\n              // Recursively flush the queue until there's no remaining work.\n              ReactCurrentActQueue.current = [];\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }\n        };\n        return _thenable;\n      } else {\n        // Since we're inside a nested `act` scope, the returned thenable\n        // immediately resolves. The outer scope will flush the queue.\n        var _thenable2 = {\n          then: function (resolve, reject) {\n            resolve(returnValue);\n          }\n        };\n        return _thenable2;\n      }\n    }\n  }\n}\n\nfunction popActScope(prevActScopeDepth) {\n  {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n    }\n\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n  {\n    var queue = ReactCurrentActQueue.current;\n\n    if (queue !== null) {\n      try {\n        flushActQueue(queue);\n        enqueueTask(function () {\n          if (queue.length === 0) {\n            // No additional work was scheduled. Finish.\n            ReactCurrentActQueue.current = null;\n            resolve(returnValue);\n          } else {\n            // Keep flushing work until there's none left.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nvar isFlushing = false;\n\nfunction flushActQueue(queue) {\n  {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      var i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          var callback = queue[i];\n\n          do {\n            callback = callback(true);\n          } while (callback !== null);\n        }\n\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue = queue.slice(i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}\n\nvar createElement$1 =  createElementWithValidation ;\nvar cloneElement$1 =  cloneElementWithValidation ;\nvar createFactory =  createFactoryWithValidation ;\nvar Children = {\n  map: mapChildren,\n  forEach: forEachChildren,\n  count: countChildren,\n  toArray: toArray,\n  only: onlyChild\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\nexports.act = act;\nexports.cloneElement = cloneElement$1;\nexports.createContext = createContext;\nexports.createElement = createElement$1;\nexports.createFactory = createFactory;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.isValidElement = isValidElement;\nexports.lazy = lazy;\nexports.memo = memo;\nexports.startTransition = startTransition;\nexports.unstable_act = act;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useDebugValue = useDebugValue;\nexports.useDeferredValue = useDeferredValue;\nexports.useEffect = useEffect;\nexports.useId = useId;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useInsertionEffect = useInsertionEffect;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useRef = useRef;\nexports.useState = useState;\nexports.useSyncExternalStore = useSyncExternalStore;\nexports.useTransition = useTransition;\nexports.version = ReactVersion;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n", "/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var enableSchedulerDebugging = false;\nvar enableProfiling = false;\nvar frameYieldMs = 5;\n\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\nfunction peek(heap) {\n  return heap.length === 0 ? null : heap[0];\n}\nfunction pop(heap) {\n  if (heap.length === 0) {\n    return null;\n  }\n\n  var first = heap[0];\n  var last = heap.pop();\n\n  if (last !== first) {\n    heap[0] = last;\n    siftDown(heap, last, 0);\n  }\n\n  return first;\n}\n\nfunction siftUp(heap, node, i) {\n  var index = i;\n\n  while (index > 0) {\n    var parentIndex = index - 1 >>> 1;\n    var parent = heap[parentIndex];\n\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  var index = i;\n  var length = heap.length;\n  var halfLength = length >>> 1;\n\n  while (index < halfLength) {\n    var leftIndex = (index + 1) * 2 - 1;\n    var left = heap[leftIndex];\n    var rightIndex = leftIndex + 1;\n    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n    if (compare(left, node) < 0) {\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  var diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\nfunction markTaskErrored(task, ms) {\n}\n\n/* eslint-disable no-var */\n\nvar hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nif (hasPerformanceNow) {\n  var localPerformance = performance;\n\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date;\n  var initialTime = localDate.now();\n\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n} // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\n\n\nvar maxSigned31BitInt = 1073741823; // Times out immediately\n\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\nvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\nvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\nvar taskQueue = [];\nvar timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\nvar taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\nvar isPerformingWork = false;\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\nvar localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\nvar isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  var timer = peek(timerQueue);\n\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      var firstTimer = peek(timerQueue);\n\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n\n\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  var previousPriorityLevel = currentPriorityLevel;\n\n  try {\n    if (enableProfiling) {\n      try {\n        return workLoop(hasTimeRemaining, initialTime);\n      } catch (error) {\n        if (currentTask !== null) {\n          var currentTime = exports.unstable_now();\n          markTaskErrored(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n\n        throw error;\n      }\n    } else {\n      // No catch in prod code path.\n      return workLoop(hasTimeRemaining, initialTime);\n    }\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue);\n\n  while (currentTask !== null && !(enableSchedulerDebugging )) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n\n    var callback = currentTask.callback;\n\n    if (typeof callback === 'function') {\n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n      var continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = exports.unstable_now();\n\n      if (typeof continuationCallback === 'function') {\n        currentTask.callback = continuationCallback;\n      } else {\n\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n\n      advanceTimers(currentTime);\n    } else {\n      pop(taskQueue);\n    }\n\n    currentTask = peek(taskQueue);\n  } // Return whether there's additional work\n\n\n  if (currentTask !== null) {\n    return true;\n  } else {\n    var firstTimer = peek(timerQueue);\n\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n\n    return false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = exports.unstable_now();\n  var startTime;\n\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  var timeout;\n\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n\n    case UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n\n    case IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n\n    case LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n\n    case NormalPriority:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\n  var expirationTime = startTime + timeout;\n  var newTask = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    sortIndex: -1\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      } // Schedule a timeout.\n\n\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n    // wait until the next time we yield.\n\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction unstable_pauseExecution() {\n}\n\nfunction unstable_continueExecution() {\n\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return peek(taskQueue);\n}\n\nfunction unstable_cancelCallback(task) {\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n\n\n  task.callback = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nvar isMessageLoopRunning = false;\nvar scheduledHostCallback = null;\nvar taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\n\nvar frameInterval = frameYieldMs;\nvar startTime = -1;\n\nfunction shouldYieldToHost() {\n  var timeElapsed = exports.unstable_now() - startTime;\n\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  } // The main thread has been blocked for a non-negligible amount of time. We\n\n\n  return true;\n}\n\nfunction requestPaint() {\n\n}\n\nfunction forceFrameRate(fps) {\n  if (fps < 0 || fps > 125) {\n    // Using console['error'] to evade Babel and ESLint\n    console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n    return;\n  }\n\n  if (fps > 0) {\n    frameInterval = Math.floor(1000 / fps);\n  } else {\n    // reset the framerate\n    frameInterval = frameYieldMs;\n  }\n}\n\nvar performWorkUntilDeadline = function () {\n  if (scheduledHostCallback !== null) {\n    var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n    // has been blocked.\n\n    startTime = currentTime;\n    var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n    // error can be observed.\n    //\n    // Intentionally not using a try-catch, since that makes some debugging\n    // techniques harder. Instead, if `scheduledHostCallback` errors, then\n    // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n    var hasMoreWork = true;\n\n    try {\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n    } finally {\n      if (hasMoreWork) {\n        // If there's more work, schedule the next message event at the end\n        // of the preceding one.\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  } // Yielding to the browser will give it a chance to paint, so we can\n};\n\nvar schedulePerformWorkUntilDeadline;\n\nif (typeof localSetImmediate === 'function') {\n  // Node.js and old IE.\n  // There's a few reasons for why we prefer setImmediate.\n  //\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n  // (Even though this is a DOM fork of the Scheduler, you could get here\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n  // https://github.com/facebook/react/issues/20756\n  //\n  // But also, it runs earlier which is the semantic we want.\n  // If other browsers ever implement it, it's better to use it.\n  // Although both of these would be inferior to native scheduling.\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\n} else if (typeof MessageChannel !== 'undefined') {\n  // DOM and Worker environments.\n  // We prefer MessageChannel because of the 4ms setTimeout clamping.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else {\n  // We should only fallback here in non-browser environments.\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\n}\n\nfunction requestHostCallback(callback) {\n  scheduledHostCallback = callback;\n\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\n\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\n\nfunction cancelHostTimeout() {\n  localClearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n}\n\nvar unstable_requestPaint = requestPaint;\nvar unstable_Profiling =  null;\n\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_Profiling = unstable_Profiling;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_forceFrameRate = forceFrameRate;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\nexports.unstable_next = unstable_next;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = unstable_wrapCallback;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n", "/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  module.exports = function $$$reconciler($$$hostConfig) {\n    var exports = {};\n'use strict';\n\nvar React = require('react');\nvar Scheduler = require('scheduler');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar suppressWarning = false;\nfunction setSuppressWarning(newSuppressWarning) {\n  {\n    suppressWarning = newSuppressWarning;\n  }\n} // In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    if (!suppressWarning) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n}\nfunction error(format) {\n  {\n    if (!suppressWarning) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar assign = Object.assign;\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\nfunction get(key) {\n  return key._reactInternals;\n}\nfunction set(key, value) {\n  key._reactInternals = value;\n}\n\n// -----------------------------------------------------------------------------\n// the react-reconciler package.\n\nvar enableNewReconciler = false; // Support legacy Primer support on internal FB www\n\nvar enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\nvar enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\nvar warnAboutStringRefs = false; // -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\n\nvar enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n\nvar enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n\nvar enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n\nvar FunctionComponent = 0;\nvar ClassComponent = 1;\nvar IndeterminateComponent = 2; // Before we know whether it is function or class\n\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\nvar HostComponent = 5;\nvar HostText = 6;\nvar Fragment = 7;\nvar Mode = 8;\nvar ContextConsumer = 9;\nvar ContextProvider = 10;\nvar ForwardRef = 11;\nvar Profiler = 12;\nvar SuspenseComponent = 13;\nvar MemoComponent = 14;\nvar SimpleMemoComponent = 15;\nvar LazyComponent = 16;\nvar IncompleteClassComponent = 17;\nvar DehydratedFragment = 18;\nvar SuspenseListComponent = 19;\nvar ScopeComponent = 21;\nvar OffscreenComponent = 22;\nvar LegacyHiddenComponent = 23;\nvar CacheComponent = 24;\nvar TracingMarkerComponent = 25;\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_SCOPE_TYPE = Symbol.for('react.scope');\nvar REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nfunction getWrappedName$1(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n} // Keep in sync with shared/getComponentNameFromType\n\n\nfunction getContextName$1(type) {\n  return type.displayName || 'Context';\n}\n\nfunction getComponentNameFromFiber(fiber) {\n  var tag = fiber.tag,\n      type = fiber.type;\n\n  switch (tag) {\n    case CacheComponent:\n      return 'Cache';\n\n    case ContextConsumer:\n      var context = type;\n      return getContextName$1(context) + '.Consumer';\n\n    case ContextProvider:\n      var provider = type;\n      return getContextName$1(provider._context) + '.Provider';\n\n    case DehydratedFragment:\n      return 'DehydratedFragment';\n\n    case ForwardRef:\n      return getWrappedName$1(type, type.render, 'ForwardRef');\n\n    case Fragment:\n      return 'Fragment';\n\n    case HostComponent:\n      // Host component type is the display name (e.g. \"div\", \"View\")\n      return type;\n\n    case HostPortal:\n      return 'Portal';\n\n    case HostRoot:\n      return 'Root';\n\n    case HostText:\n      return 'Text';\n\n    case LazyComponent:\n      // Name comes from the type in this case; we don't have a tag.\n      return getComponentNameFromType(type);\n\n    case Mode:\n      if (type === REACT_STRICT_MODE_TYPE) {\n        // Don't be less specific than shared/getComponentNameFromType\n        return 'StrictMode';\n      }\n\n      return 'Mode';\n\n    case OffscreenComponent:\n      return 'Offscreen';\n\n    case Profiler:\n      return 'Profiler';\n\n    case ScopeComponent:\n      return 'Scope';\n\n    case SuspenseComponent:\n      return 'Suspense';\n\n    case SuspenseListComponent:\n      return 'SuspenseList';\n\n    case TracingMarkerComponent:\n      return 'TracingMarker';\n    // The display name for this tags come from the user-provided type:\n\n    case ClassComponent:\n    case FunctionComponent:\n    case IncompleteClassComponent:\n    case IndeterminateComponent:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      break;\n\n  }\n\n  return null;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags =\n/*                      */\n0;\nvar PerformedWork =\n/*                */\n1; // You can change the rest (and add more).\n\nvar Placement =\n/*                    */\n2;\nvar Update =\n/*                       */\n4;\nvar ChildDeletion =\n/*                */\n16;\nvar ContentReset =\n/*                 */\n32;\nvar Callback =\n/*                     */\n64;\nvar DidCapture =\n/*                   */\n128;\nvar ForceClientRender =\n/*            */\n256;\nvar Ref =\n/*                          */\n512;\nvar Snapshot =\n/*                     */\n1024;\nvar Passive =\n/*                      */\n2048;\nvar Hydrating =\n/*                    */\n4096;\nvar Visibility =\n/*                   */\n8192;\nvar StoreConsistency =\n/*             */\n16384;\nvar LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)\n\nvar HostEffectMask =\n/*               */\n32767; // These are not really side effects, but we still reuse this field.\n\nvar Incomplete =\n/*                   */\n32768;\nvar ShouldCapture =\n/*                */\n65536;\nvar ForceUpdateForLegacySuspense =\n/* */\n131072;\nvar Forked =\n/*                       */\n1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\n\nvar RefStatic =\n/*                    */\n2097152;\nvar LayoutStatic =\n/*                 */\n4194304;\nvar PassiveStatic =\n/*                */\n8388608; // These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\n\nvar MountLayoutDev =\n/*               */\n16777216;\nvar MountPassiveDev =\n/*              */\n33554432; // Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\n\nvar BeforeMutationMask = // TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate | Snapshot | ( 0);\nvar MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\nvar LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n\nvar PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\n\nvar StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nfunction getNearestMountedFiber(fiber) {\n  var node = fiber;\n  var nearestMounted = fiber;\n\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    var nextNode = node;\n\n    do {\n      node = nextNode;\n\n      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n        // This is an insertion or in-progress hydration. The nearest possible\n        // mounted fiber is the parent but we need to continue to figure out\n        // if that one is still mounted.\n        nearestMounted = node.return;\n      }\n\n      nextNode = node.return;\n    } while (nextNode);\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return nearestMounted;\n  } // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n\n\n  return null;\n}\nfunction isFiberMounted(fiber) {\n  return getNearestMountedFiber(fiber) === fiber;\n}\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n\n      if (!instance._warnedAboutRefsInRender) {\n        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n      }\n\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n\n  if (!fiber) {\n    return false;\n  }\n\n  return getNearestMountedFiber(fiber) === fiber;\n}\n\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var nearestMounted = getNearestMountedFiber(fiber);\n\n    if (nearestMounted === null) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (nearestMounted !== fiber) {\n      return null;\n    }\n\n    return fiber;\n  } // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n\n\n  var a = fiber;\n  var b = alternate;\n\n  while (true) {\n    var parentA = a.return;\n\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n\n    var parentB = parentA.alternate;\n\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      var nextParent = parentA.return;\n\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      } // If there's no parent, we're at the root.\n\n\n      break;\n    } // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n\n\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n\n        child = child.sibling;\n      } // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n\n\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n\n        _child = _child.sibling;\n      }\n\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n\n          _child = _child.sibling;\n        }\n\n        if (!didFindChild) {\n          throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n        }\n      }\n    }\n\n    if (a.alternate !== b) {\n      throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n  } // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n\n\n  if (a.tag !== HostRoot) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  } // Otherwise B has to be current branch.\n\n\n  return alternate;\n}\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  var child = node.child;\n\n  while (child !== null) {\n    var match = findCurrentHostFiberImpl(child);\n\n    if (match !== null) {\n      return match;\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberWithNoPortalsImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  var child = node.child;\n\n  while (child !== null) {\n    if (child.tag !== HostPortal) {\n      var match = findCurrentHostFiberWithNoPortalsImpl(child);\n\n      if (match !== null) {\n        return match;\n      }\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// This is a host config that's used for the `react-reconciler` package on npm.\n// It is only used by third-party renderers.\n//\n// Its API lets you pass the host config as an argument.\n// However, inside the `react-reconciler` we treat host config as a module.\n// This file is a shim between two worlds.\n//\n// It works because the `react-reconciler` bundle is wrapped in something like:\n//\n// module.exports = function ($$$config) {\n//   /* reconciler code */\n// }\n//\n// So `$$$config` looks like a global variable, but it's\n// really an argument to a top-level wrapping function.\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\nvar getPublicInstance = $$$hostConfig.getPublicInstance;\nvar getRootHostContext = $$$hostConfig.getRootHostContext;\nvar getChildHostContext = $$$hostConfig.getChildHostContext;\nvar prepareForCommit = $$$hostConfig.prepareForCommit;\nvar resetAfterCommit = $$$hostConfig.resetAfterCommit;\nvar createInstance = $$$hostConfig.createInstance;\nvar appendInitialChild = $$$hostConfig.appendInitialChild;\nvar finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;\nvar prepareUpdate = $$$hostConfig.prepareUpdate;\nvar shouldSetTextContent = $$$hostConfig.shouldSetTextContent;\nvar createTextInstance = $$$hostConfig.createTextInstance;\nvar scheduleTimeout = $$$hostConfig.scheduleTimeout;\nvar cancelTimeout = $$$hostConfig.cancelTimeout;\nvar noTimeout = $$$hostConfig.noTimeout;\nvar isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;\nvar warnsIfNotActing = $$$hostConfig.warnsIfNotActing;\nvar supportsMutation = $$$hostConfig.supportsMutation;\nvar supportsPersistence = $$$hostConfig.supportsPersistence;\nvar supportsHydration = $$$hostConfig.supportsHydration;\nvar getInstanceFromNode = $$$hostConfig.getInstanceFromNode;\nvar beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;\nvar afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;\nvar preparePortalMount = $$$hostConfig.preparePortalMount;\nvar prepareScopeUpdate = $$$hostConfig.prepareScopeUpdate;\nvar getInstanceFromScope = $$$hostConfig.getInstanceFromScope;\nvar getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;\nvar detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------\n//      Microtasks\n//     (optional)\n// -------------------\n\nvar supportsMicrotasks = $$$hostConfig.supportsMicrotasks;\nvar scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------\n//      Test selectors\n//     (optional)\n// -------------------\n\nvar supportsTestSelectors = $$$hostConfig.supportsTestSelectors;\nvar findFiberRoot = $$$hostConfig.findFiberRoot;\nvar getBoundingRect = $$$hostConfig.getBoundingRect;\nvar getTextContent = $$$hostConfig.getTextContent;\nvar isHiddenSubtree = $$$hostConfig.isHiddenSubtree;\nvar matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;\nvar setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;\nvar setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------\n//      Mutation\n//     (optional)\n// -------------------\n\nvar appendChild = $$$hostConfig.appendChild;\nvar appendChildToContainer = $$$hostConfig.appendChildToContainer;\nvar commitTextUpdate = $$$hostConfig.commitTextUpdate;\nvar commitMount = $$$hostConfig.commitMount;\nvar commitUpdate = $$$hostConfig.commitUpdate;\nvar insertBefore = $$$hostConfig.insertBefore;\nvar insertInContainerBefore = $$$hostConfig.insertInContainerBefore;\nvar removeChild = $$$hostConfig.removeChild;\nvar removeChildFromContainer = $$$hostConfig.removeChildFromContainer;\nvar resetTextContent = $$$hostConfig.resetTextContent;\nvar hideInstance = $$$hostConfig.hideInstance;\nvar hideTextInstance = $$$hostConfig.hideTextInstance;\nvar unhideInstance = $$$hostConfig.unhideInstance;\nvar unhideTextInstance = $$$hostConfig.unhideTextInstance;\nvar clearContainer = $$$hostConfig.clearContainer; // -------------------\n//     Persistence\n//     (optional)\n// -------------------\n\nvar cloneInstance = $$$hostConfig.cloneInstance;\nvar createContainerChildSet = $$$hostConfig.createContainerChildSet;\nvar appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;\nvar finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;\nvar replaceContainerChildren = $$$hostConfig.replaceContainerChildren;\nvar cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;\nvar cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------\n//     Hydration\n//     (optional)\n// -------------------\n\nvar canHydrateInstance = $$$hostConfig.canHydrateInstance;\nvar canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;\nvar canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;\nvar isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;\nvar isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;\nvar getSuspenseInstanceFallbackErrorDetails = $$$hostConfig.getSuspenseInstanceFallbackErrorDetails;\nvar registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;\nvar getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;\nvar getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;\nvar getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;\nvar getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;\nvar hydrateInstance = $$$hostConfig.hydrateInstance;\nvar hydrateTextInstance = $$$hostConfig.hydrateTextInstance;\nvar hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;\nvar getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;\nvar commitHydratedContainer = $$$hostConfig.commitHydratedContainer;\nvar commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;\nvar clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;\nvar clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;\nvar shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;\nvar didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;\nvar didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;\nvar didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;\nvar didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;\nvar didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;\nvar didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;\nvar didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;\nvar didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;\nvar didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;\nvar didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;\nvar didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;\nvar didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;\nvar didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;\nvar didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;\nvar errorHydratingContainer = $$$hostConfig.errorHydratingContainer;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\n\nfunction describeClassComponentFrame(ctor, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(ctor, true);\n  }\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar valueStack = [];\nvar fiberStack;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      error('Unexpected pop.');\n    }\n\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      error('Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nvar warnedAboutMissingGetChildContext;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar emptyContextObject = {};\n\n{\n  Object.freeze(emptyContextObject);\n} // A cursor to the current merged context object on the stack.\n\n\nvar contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n\nvar didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\n\nvar previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  {\n    var instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  {\n    var type = workInProgress.type;\n    var contextTypes = type.contextTypes;\n\n    if (!contextTypes) {\n      return emptyContextObject;\n    } // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n    var instance = workInProgress.stateNode;\n\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    var context = {};\n\n    for (var key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    {\n      var name = getComponentNameFromFiber(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name);\n    } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n\n\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged() {\n  {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type) {\n  {\n    var childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber) {\n  {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber) {\n  {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  {\n    if (contextStackCursor.current !== emptyContextObject) {\n      throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  {\n    var instance = fiber.stateNode;\n    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n    if (typeof instance.getChildContext !== 'function') {\n      {\n        var componentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n\n          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n\n      return parentContext;\n    }\n\n    var childContext = instance.getChildContext();\n\n    for (var contextKey in childContext) {\n      if (!(contextKey in childContextTypes)) {\n        throw new Error((getComponentNameFromFiber(fiber) || 'Unknown') + \".getChildContext(): key \\\"\" + contextKey + \"\\\" is not defined in childContextTypes.\");\n      }\n    }\n\n    {\n      var name = getComponentNameFromFiber(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\n    }\n\n    return assign({}, parentContext, childContext);\n  }\n}\n\nfunction pushContextProvider(workInProgress) {\n  {\n    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n\n    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  {\n    var instance = workInProgress.stateNode;\n\n    if (!instance) {\n      throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      var mergedContext = processChildContext(workInProgress, type, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n      throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    var node = fiber;\n\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n\n        case ClassComponent:\n          {\n            var Component = node.type;\n\n            if (isContextProvider(Component)) {\n              return node.stateNode.__reactInternalMemoizedMergedChildContext;\n            }\n\n            break;\n          }\n      }\n\n      node = node.return;\n    } while (node !== null);\n\n    throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nvar NoMode =\n/*                         */\n0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n\nvar ConcurrentMode =\n/*                 */\n1;\nvar ProfileMode =\n/*                    */\n2;\nvar StrictLegacyMode =\n/*               */\n8;\nvar StrictEffectsMode =\n/*              */\n16;\n\n// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nfunction clz32Fallback(x) {\n  var asUint = x >>> 0;\n\n  if (asUint === 0) {\n    return 32;\n  }\n\n  return 31 - (log(asUint) / LN2 | 0) | 0;\n}\n\n// If those values are changed that package should be rebuilt and redeployed.\n\nvar TotalLanes = 31;\nvar NoLanes =\n/*                        */\n0;\nvar NoLane =\n/*                          */\n0;\nvar SyncLane =\n/*                        */\n1;\nvar InputContinuousHydrationLane =\n/*    */\n2;\nvar InputContinuousLane =\n/*             */\n4;\nvar DefaultHydrationLane =\n/*            */\n8;\nvar DefaultLane =\n/*                     */\n16;\nvar TransitionHydrationLane =\n/*                */\n32;\nvar TransitionLanes =\n/*                       */\n4194240;\nvar TransitionLane1 =\n/*                        */\n64;\nvar TransitionLane2 =\n/*                        */\n128;\nvar TransitionLane3 =\n/*                        */\n256;\nvar TransitionLane4 =\n/*                        */\n512;\nvar TransitionLane5 =\n/*                        */\n1024;\nvar TransitionLane6 =\n/*                        */\n2048;\nvar TransitionLane7 =\n/*                        */\n4096;\nvar TransitionLane8 =\n/*                        */\n8192;\nvar TransitionLane9 =\n/*                        */\n16384;\nvar TransitionLane10 =\n/*                       */\n32768;\nvar TransitionLane11 =\n/*                       */\n65536;\nvar TransitionLane12 =\n/*                       */\n131072;\nvar TransitionLane13 =\n/*                       */\n262144;\nvar TransitionLane14 =\n/*                       */\n524288;\nvar TransitionLane15 =\n/*                       */\n1048576;\nvar TransitionLane16 =\n/*                       */\n2097152;\nvar RetryLanes =\n/*                            */\n130023424;\nvar RetryLane1 =\n/*                             */\n4194304;\nvar RetryLane2 =\n/*                             */\n8388608;\nvar RetryLane3 =\n/*                             */\n16777216;\nvar RetryLane4 =\n/*                             */\n33554432;\nvar RetryLane5 =\n/*                             */\n67108864;\nvar SomeRetryLane = RetryLane1;\nvar SelectiveHydrationLane =\n/*          */\n134217728;\nvar NonIdleLanes =\n/*                          */\n268435455;\nvar IdleHydrationLane =\n/*               */\n268435456;\nvar IdleLane =\n/*                        */\n536870912;\nvar OffscreenLane =\n/*                   */\n1073741824; // This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\n\nfunction getLabelForLane(lane) {\n  {\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\nvar NoTimestamp = -1;\nvar nextTransitionLane = TransitionLane1;\nvar nextRetryLane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes) {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncLane:\n      return SyncLane;\n\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n\n    case InputContinuousLane:\n      return InputContinuousLane;\n\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n\n    case DefaultLane:\n      return DefaultLane;\n\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      return lanes & RetryLanes;\n\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n\n    case IdleLane:\n      return IdleLane;\n\n    case OffscreenLane:\n      return OffscreenLane;\n\n    default:\n      {\n        error('Should have found matching lanes. This is a bug in React.');\n      } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\n\n      return lanes;\n  }\n}\n\nfunction getNextLanes(root, wipLanes) {\n  // Early bailout if there's no pending work left.\n  var pendingLanes = root.pendingLanes;\n\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  var nextLanes = NoLanes;\n  var suspendedLanes = root.suspendedLanes;\n  var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n\n  var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n\n  if (nonIdlePendingLanes !== NoLanes) {\n    var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    var unblockedLanes = pendingLanes & ~suspendedLanes;\n\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  } // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n\n\n  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n  // bother waiting until the root is complete.\n  (wipLanes & suspendedLanes) === NoLanes) {\n    var nextLane = getHighestPriorityLane(nextLanes);\n    var wipLane = getHighestPriorityLane(wipLanes);\n\n    if ( // Tests whether the next lane is equal or lower priority than the wip\n    // one. This works because the bits decrease in priority as you go left.\n    nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n    // only difference between default updates and transition updates is that\n    // default updates do not support refresh transitions.\n    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  } // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n\n\n  var entangledLanes = root.entangledLanes;\n\n  if (entangledLanes !== NoLanes) {\n    var entanglements = root.entanglements;\n    var lanes = nextLanes & entangledLanes;\n\n    while (lanes > 0) {\n      var index = pickArbitraryLaneIndex(lanes);\n      var lane = 1 << index;\n      nextLanes |= entanglements[index];\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\nfunction getMostRecentEventTime(root, lanes) {\n  var eventTimes = root.eventTimes;\n  var mostRecentEventTime = NoTimestamp;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    var eventTime = eventTimes[index];\n\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n\n    default:\n      {\n        error('Should have found matching lanes. This is a bug in React.');\n      }\n\n      return NoTimestamp;\n  }\n}\n\nfunction markStarvedLanesAsExpired(root, currentTime) {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n  var pendingLanes = root.pendingLanes;\n  var suspendedLanes = root.suspendedLanes;\n  var pingedLanes = root.pingedLanes;\n  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n\n  var lanes = pendingLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    var expirationTime = expirationTimes[index];\n\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n} // This returns the highest priority pending lanes regardless of whether they\n// are suspended.\n\nfunction getHighestPriorityPendingLanes(root) {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\nfunction getLanesToRetrySynchronouslyOnError(root) {\n  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n\n  return NoLanes;\n}\nfunction includesSyncLane(lanes) {\n  return (lanes & SyncLane) !== NoLanes;\n}\nfunction includesNonIdleWork(lanes) {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nfunction includesOnlyRetries(lanes) {\n  return (lanes & RetryLanes) === lanes;\n}\nfunction includesOnlyNonUrgentLanes(lanes) {\n  var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n  return (lanes & UrgentLanes) === NoLanes;\n}\nfunction includesOnlyTransitions(lanes) {\n  return (lanes & TransitionLanes) === lanes;\n}\nfunction includesBlockingLane(root, lanes) {\n\n  var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\nfunction includesExpiredLane(root, lanes) {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\nfunction isTransitionLane(lane) {\n  return (lane & TransitionLanes) !== NoLanes;\n}\nfunction claimNextTransitionLane() {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  var lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n    nextTransitionLane = TransitionLane1;\n  }\n\n  return lane;\n}\nfunction claimNextRetryLane() {\n  var lane = nextRetryLane;\n  nextRetryLane <<= 1;\n\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\n    nextRetryLane = RetryLane1;\n  }\n\n  return lane;\n}\nfunction getHighestPriorityLane(lanes) {\n  return lanes & -lanes;\n}\nfunction pickArbitraryLane(lanes) {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nfunction includesSomeLane(a, b) {\n  return (a & b) !== NoLanes;\n}\nfunction isSubsetOfLanes(set, subset) {\n  return (set & subset) === subset;\n}\nfunction mergeLanes(a, b) {\n  return a | b;\n}\nfunction removeLanes(set, subset) {\n  return set & ~subset;\n}\nfunction intersectLanes(a, b) {\n  return a & b;\n} // Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\n\nfunction laneToLanes(lane) {\n  return lane;\n}\nfunction higherPriorityLane(a, b) {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\nfunction createLaneMap(initial) {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  var laneMap = [];\n\n  for (var i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n\n  return laneMap;\n}\nfunction markRootUpdated(root, updateLane, eventTime) {\n  root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  var eventTimes = root.eventTimes;\n  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n\n  eventTimes[index] = eventTime;\n}\nfunction markRootSuspended(root, suspendedLanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\n  var expirationTimes = root.expirationTimes;\n  var lanes = suspendedLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nfunction markRootPinged(root, pingedLanes, eventTime) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\nfunction markRootFinished(root, remainingLanes) {\n  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n  root.pendingLanes = remainingLanes; // Let's try everything again\n\n  root.suspendedLanes = NoLanes;\n  root.pingedLanes = NoLanes;\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  var entanglements = root.entanglements;\n  var eventTimes = root.eventTimes;\n  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n\n  var lanes = noLongerPendingLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nfunction markRootEntangled(root, entangledLanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n  var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n  var entanglements = root.entanglements;\n  var lanes = rootEntangledLanes;\n\n  while (lanes) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n\n    if ( // Is this one of the newly entangled lanes?\n    lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n    entanglements[index] & entangledLanes) {\n      entanglements[index] |= entangledLanes;\n    }\n\n    lanes &= ~lane;\n  }\n}\nfunction getBumpedLaneForHydration(root, renderLanes) {\n  var renderLane = getHighestPriorityLane(renderLanes);\n  var lane;\n\n  switch (renderLane) {\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      lane = TransitionHydrationLane;\n      break;\n\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  } // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n\n\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\nfunction addFiberToLanesMap(root, fiber, lanes) {\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\n  while (lanes > 0) {\n    var index = laneToIndex(lanes);\n    var lane = 1 << index;\n    var updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n    lanes &= ~lane;\n  }\n}\nfunction movePendingFibersToMemoized(root, lanes) {\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  var memoizedUpdaters = root.memoizedUpdaters;\n\n  while (lanes > 0) {\n    var index = laneToIndex(lanes);\n    var lane = 1 << index;\n    var updaters = pendingUpdatersLaneMap[index];\n\n    if (updaters.size > 0) {\n      updaters.forEach(function (fiber) {\n        var alternate = fiber.alternate;\n\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\nfunction getTransitionsForLanes(root, lanes) {\n  {\n    return null;\n  }\n}\n\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\nvar currentUpdatePriority = NoLane;\nfunction getCurrentUpdatePriority() {\n  return currentUpdatePriority;\n}\nfunction setCurrentUpdatePriority(newPriority) {\n  currentUpdatePriority = newPriority;\n}\nfunction runWithPriority(priority, fn) {\n  var previousPriority = currentUpdatePriority;\n\n  try {\n    currentUpdatePriority = priority;\n    return fn();\n  } finally {\n    currentUpdatePriority = previousPriority;\n  }\n}\nfunction higherEventPriority(a, b) {\n  return a !== 0 && a < b ? a : b;\n}\nfunction lowerEventPriority(a, b) {\n  return a === 0 || a > b ? a : b;\n}\nfunction isHigherEventPriority(a, b) {\n  return a !== 0 && a < b;\n}\nfunction lanesToEventPriority(lanes) {\n  var lane = getHighestPriorityLane(lanes);\n\n  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n    return DiscreteEventPriority;\n  }\n\n  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n    return ContinuousEventPriority;\n  }\n\n  if (includesNonIdleWork(lane)) {\n    return DefaultEventPriority;\n  }\n\n  return IdleEventPriority;\n}\n\n// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback = Scheduler.unstable_scheduleCallback;\nvar cancelCallback = Scheduler.unstable_cancelCallback;\nvar shouldYield = Scheduler.unstable_shouldYield;\nvar requestPaint = Scheduler.unstable_requestPaint;\nvar now = Scheduler.unstable_now;\nvar ImmediatePriority = Scheduler.unstable_ImmediatePriority;\nvar UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\nvar NormalPriority = Scheduler.unstable_NormalPriority;\nvar IdlePriority = Scheduler.unstable_IdlePriority;\n// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue = Scheduler.unstable_yieldValue;\nvar unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n\nvar rendererID = null;\nvar injectedHook = null;\nvar injectedProfilingHooks = null;\nvar hasLoggedError = false;\nvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n\n  if (!hook.supportsFiber) {\n    {\n      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');\n    } // DevTools exists, even though it doesn't support Fiber.\n\n\n    return true;\n  }\n\n  try {\n    if (enableSchedulingProfiler) {\n      // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n      // This gives DevTools a way to feature detect that isn't tied to version number\n      // (since profiling and timeline are controlled by different feature flags).\n      internals = assign({}, internals, {\n        getLaneLabelMap: getLaneLabelMap,\n        injectProfilingHooks: injectProfilingHooks\n      });\n    }\n\n    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n\n    injectedHook = hook;\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      error('React instrumentation encountered an error: %s.', err);\n    }\n  }\n\n  if (hook.checkDCE) {\n    // This is the real DevTools.\n    return true;\n  } else {\n    // This is likely a hook installed by Fast Refresh runtime.\n    return false;\n  }\n}\nfunction onScheduleRoot(root, children) {\n  {\n    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n      try {\n        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n      } catch (err) {\n        if ( !hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onCommitRoot(root, eventPriority) {\n  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n    try {\n      var didError = (root.current.flags & DidCapture) === DidCapture;\n\n      if (enableProfilerTimer) {\n        var schedulerPriority;\n\n        switch (eventPriority) {\n          case DiscreteEventPriority:\n            schedulerPriority = ImmediatePriority;\n            break;\n\n          case ContinuousEventPriority:\n            schedulerPriority = UserBlockingPriority;\n            break;\n\n          case DefaultEventPriority:\n            schedulerPriority = NormalPriority;\n            break;\n\n          case IdleEventPriority:\n            schedulerPriority = IdlePriority;\n            break;\n\n          default:\n            schedulerPriority = NormalPriority;\n            break;\n        }\n\n        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n      } else {\n        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);\n      }\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onPostCommitRoot(root) {\n  if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n    try {\n      injectedHook.onPostCommitFiberRoot(rendererID, root);\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onCommitUnmount(fiber) {\n  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n    try {\n      injectedHook.onCommitFiberUnmount(rendererID, fiber);\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\n  {\n    if (typeof unstable_yieldValue === 'function') {\n      // We're in a test because Scheduler.unstable_yieldValue only exists\n      // in SchedulerMock. To reduce the noise in strict mode tests,\n      // suppress warnings and disable scheduler yielding during the double render\n      unstable_setDisableYieldValue(newIsStrictMode);\n      setSuppressWarning(newIsStrictMode);\n    }\n\n    if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n      try {\n        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n      } catch (err) {\n        {\n          if (!hasLoggedError) {\n            hasLoggedError = true;\n\n            error('React instrumentation encountered an error: %s', err);\n          }\n        }\n      }\n    }\n  }\n} // Profiler API hooks\n\nfunction injectProfilingHooks(profilingHooks) {\n  injectedProfilingHooks = profilingHooks;\n}\n\nfunction getLaneLabelMap() {\n  {\n    var map = new Map();\n    var lane = 1;\n\n    for (var index = 0; index < TotalLanes; index++) {\n      var label = getLabelForLane(lane);\n      map.set(lane, label);\n      lane *= 2;\n    }\n\n    return map;\n  }\n}\n\nfunction markCommitStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n      injectedProfilingHooks.markCommitStarted(lanes);\n    }\n  }\n}\nfunction markCommitStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n      injectedProfilingHooks.markCommitStopped();\n    }\n  }\n}\nfunction markComponentRenderStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n      injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n  }\n}\nfunction markComponentRenderStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n      injectedProfilingHooks.markComponentRenderStopped();\n    }\n  }\n}\nfunction markComponentPassiveEffectMountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n    }\n  }\n}\nfunction markComponentPassiveEffectMountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n    }\n  }\n}\nfunction markComponentPassiveEffectUnmountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n    }\n  }\n}\nfunction markComponentPassiveEffectUnmountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n    }\n  }\n}\nfunction markComponentLayoutEffectMountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n    }\n  }\n}\nfunction markComponentLayoutEffectMountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n    }\n  }\n}\nfunction markComponentLayoutEffectUnmountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n    }\n  }\n}\nfunction markComponentLayoutEffectUnmountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n    }\n  }\n}\nfunction markComponentErrored(fiber, thrownValue, lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n      injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n    }\n  }\n}\nfunction markComponentSuspended(fiber, wakeable, lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n      injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n    }\n  }\n}\nfunction markLayoutEffectsStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n      injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n    }\n  }\n}\nfunction markLayoutEffectsStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n      injectedProfilingHooks.markLayoutEffectsStopped();\n    }\n  }\n}\nfunction markPassiveEffectsStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n      injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n    }\n  }\n}\nfunction markPassiveEffectsStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n      injectedProfilingHooks.markPassiveEffectsStopped();\n    }\n  }\n}\nfunction markRenderStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n      injectedProfilingHooks.markRenderStarted(lanes);\n    }\n  }\n}\nfunction markRenderYielded() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n      injectedProfilingHooks.markRenderYielded();\n    }\n  }\n}\nfunction markRenderStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n      injectedProfilingHooks.markRenderStopped();\n    }\n  }\n}\nfunction markRenderScheduled(lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n      injectedProfilingHooks.markRenderScheduled(lane);\n    }\n  }\n}\nfunction markForceUpdateScheduled(fiber, lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n      injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n    }\n  }\n}\nfunction markStateUpdateScheduled(fiber, lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n      injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar syncQueue = null;\nvar includesLegacySyncCallbacks = false;\nvar isFlushingSyncQueue = false;\nfunction scheduleSyncCallback(callback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\nfunction scheduleLegacySyncCallback(callback) {\n  includesLegacySyncCallbacks = true;\n  scheduleSyncCallback(callback);\n}\nfunction flushSyncCallbacksOnlyInLegacyMode() {\n  // Only flushes the queue if there's a legacy sync callback scheduled.\n  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n  // it might make more sense for the queue to be a list of roots instead of a\n  // list of generic callbacks. Then we can have two: one for legacy roots, one\n  // for concurrent roots. And this method would only flush the legacy ones.\n  if (includesLegacySyncCallbacks) {\n    flushSyncCallbacks();\n  }\n}\nfunction flushSyncCallbacks() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    var i = 0;\n    var previousUpdatePriority = getCurrentUpdatePriority();\n\n    try {\n      var isSync = true;\n      var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n\n      setCurrentUpdatePriority(DiscreteEventPriority);\n\n      for (; i < queue.length; i++) {\n        var callback = queue[i];\n\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      } // Resume flushing in the next tick\n\n\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n\n  return null;\n}\n\n// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root) {\n  var currentState = root.current.memoizedState;\n  return currentState.isDehydrated;\n}\n\n// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack = [];\nvar forkStackIndex = 0;\nvar treeForkProvider = null;\nvar treeForkCount = 0;\nvar idStack = [];\nvar idStackIndex = 0;\nvar treeContextProvider = null;\nvar treeContextId = 1;\nvar treeContextOverflow = '';\nfunction isForkedChild(workInProgress) {\n  warnIfNotHydrating();\n  return (workInProgress.flags & Forked) !== NoFlags;\n}\nfunction getForksAtLevel(workInProgress) {\n  warnIfNotHydrating();\n  return treeForkCount;\n}\nfunction getTreeId() {\n  var overflow = treeContextOverflow;\n  var idWithLeadingBit = treeContextId;\n  var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n  return id.toString(32) + overflow;\n}\nfunction pushTreeFork(workInProgress, totalChildren) {\n  // This is called right after we reconcile an array (or iterator) of child\n  // fibers, because that's the only place where we know how many children in\n  // the whole set without doing extra work later, or storing addtional\n  // information on the fiber.\n  //\n  // That's why this function is separate from pushTreeId \u2014 it's called during\n  // the render phase of the fork parent, not the child, which is where we push\n  // the other context values.\n  //\n  // In the Fizz implementation this is much simpler because the child is\n  // rendered in the same callstack as the parent.\n  //\n  // It might be better to just add a `forks` field to the Fiber type. It would\n  // make this module simpler.\n  warnIfNotHydrating();\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nfunction pushTreeId(workInProgress, totalChildren, index) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  var baseIdWithLeadingBit = treeContextId;\n  var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n  // of the id; we use it to account for leading 0s.\n\n  var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n  var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n  var slot = index + 1;\n  var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n  // consideration the leading 1 we use to mark the end of the sequence.\n\n  if (length > 30) {\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n    // This branch assumes the length of the base id is greater than 5; it won't\n    // work for smaller ids, because you need 5 bits per character.\n    //\n    // We encode the id in multiple steps: first the base id, then the\n    // remaining digits.\n    //\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\n    // example, if the current id is 23 bits long, we can convert 20 of those\n    // bits into a string of 4 characters, with 3 bits left over.\n    //\n    // First calculate how many bits in the base id represent a complete\n    // sequence of characters.\n    var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n\n    var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n\n    var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n\n    var restOfBaseId = baseId >> numberOfOverflowBits;\n    var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n    // we made more room, this time it won't overflow.\n\n    var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n    var restOfNewBits = slot << restOfBaseLength;\n    var id = restOfNewBits | restOfBaseId;\n    var overflow = newOverflow + baseOverflow;\n    treeContextId = 1 << restOfLength | id;\n    treeContextOverflow = overflow;\n  } else {\n    // Normal path\n    var newBits = slot << baseLength;\n\n    var _id = newBits | baseId;\n\n    var _overflow = baseOverflow;\n    treeContextId = 1 << length | _id;\n    treeContextOverflow = _overflow;\n  }\n}\nfunction pushMaterializedTreeId(workInProgress) {\n  warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n  // in its children.\n\n  var returnFiber = workInProgress.return;\n\n  if (returnFiber !== null) {\n    var numberOfForks = 1;\n    var slotIndex = 0;\n    pushTreeFork(workInProgress, numberOfForks);\n    pushTreeId(workInProgress, numberOfForks, slotIndex);\n  }\n}\n\nfunction getBitLength(number) {\n  return 32 - clz32(number);\n}\n\nfunction getLeadingBit(id) {\n  return 1 << getBitLength(id) - 1;\n}\n\nfunction popTreeContext(workInProgress) {\n  // Restore the previous values.\n  // This is a bit more complicated than other context-like modules in Fiber\n  // because the same Fiber may appear on the stack multiple times and for\n  // different reasons. We have to keep popping until the work-in-progress is\n  // no longer at the top of the stack.\n  while (workInProgress === treeForkProvider) {\n    treeForkProvider = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n    treeForkCount = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n  }\n\n  while (workInProgress === treeContextProvider) {\n    treeContextProvider = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextOverflow = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextId = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n  }\n}\nfunction getSuspendedTreeContext() {\n  warnIfNotHydrating();\n\n  if (treeContextProvider !== null) {\n    return {\n      id: treeContextId,\n      overflow: treeContextOverflow\n    };\n  } else {\n    return null;\n  }\n}\nfunction restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextId = suspendedContext.id;\n  treeContextOverflow = suspendedContext.overflow;\n  treeContextProvider = workInProgress;\n}\n\nfunction warnIfNotHydrating() {\n  {\n    if (!getIsHydrating()) {\n      error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n    }\n  }\n}\n\n// This may have been an insertion or a hydration.\n\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\n\nvar didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary\n\nvar hydrationErrors = null;\n\nfunction warnIfHydrating() {\n  {\n    if (isHydrating) {\n      error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n    }\n  }\n}\n\nfunction markDidThrowWhileHydratingDEV() {\n  {\n    didSuspendOrErrorDEV = true;\n  }\n}\nfunction didSuspendOrErrorWhileHydratingDEV() {\n  {\n    return didSuspendOrErrorDEV;\n  }\n}\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n\n  return true;\n}\n\nfunction warnUnhydratedInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n          break;\n        }\n\n      case HostComponent:\n        {\n          var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, // TODO: Delete this argument when we remove the legacy root API.\n          isConcurrentMode);\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          var suspenseState = returnFiber.memoizedState;\n          if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n          break;\n        }\n    }\n  }\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  warnUnhydratedInstance(returnFiber, instance);\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  var deletions = returnFiber.deletions;\n\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction warnNonhydratedInstance(returnFiber, fiber) {\n  {\n    if (didSuspendOrErrorDEV) {\n      // Inside a boundary that already suspended. We're currently rendering the\n      // siblings of a suspended node. The mismatch may be due to the missing\n      // data, so it's probably a false positive.\n      return;\n    }\n\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n              break;\n\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n              break;\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              {\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, // TODO: Delete this argument when we remove the legacy root API.\n                isConcurrentMode);\n                break;\n              }\n\n            case HostText:\n              {\n                var _text = fiber.pendingProps;\n\n                var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, // TODO: Delete this argument when we remove the legacy root API.\n                _isConcurrentMode);\n                break;\n              }\n\n            case SuspenseComponent:\n              {\n                didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n                break;\n              }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          var suspenseState = returnFiber.memoizedState;\n          var _parentInstance = suspenseState.dehydrated;\n          if (_parentInstance !== null) switch (fiber.tag) {\n            case HostComponent:\n              var _type2 = fiber.type;\n              var _props2 = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);\n              break;\n\n            case HostText:\n              var _text2 = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);\n              break;\n          }\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.flags = fiber.flags & ~Hydrating | Placement;\n  warnNonhydratedInstance(returnFiber, fiber);\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          hydrationParentFiber = fiber;\n          nextHydratableInstance = getFirstHydratableChild(instance);\n          return true;\n        }\n\n        return false;\n      }\n\n    case HostText:\n      {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    case SuspenseComponent:\n      {\n        var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n        if (suspenseInstance !== null) {\n          var suspenseState = {\n            dehydrated: suspenseInstance,\n            treeContext: getSuspendedTreeContext(),\n            retryLane: OffscreenLane\n          };\n          fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n          // This simplifies the code for getHostSibling and deleting nodes,\n          // since it doesn't have to consider all Suspense boundaries and\n          // check if they're dehydrated ones or not.\n\n          var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n          dehydratedFragment.return = fiber;\n          fiber.child = dehydratedFragment;\n          hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n          // it during the first pass. Instead, we'll reenter it later.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nfunction shouldClientRenderOnMismatch(fiber) {\n  return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n}\n\nfunction throwOnHydrationMismatch(fiber) {\n  throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n\n  var nextInstance = nextHydratableInstance;\n\n  if (!nextInstance) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch();\n    } // Nothing to hydrate. Make it an insertion.\n\n\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  var firstAttemptedInstance = nextInstance;\n\n  if (!tryHydrate(fiber, nextInstance)) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch();\n    } // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n\n\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    var prevHydrationParentFiber = hydrationParentFiber;\n\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    } // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n\n\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var instance = fiber.stateNode;\n  var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n\n  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n\n  if (updatePayload !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n\n  if (shouldUpdate) {\n    // We assume that prepareToHydrateHostTextInstance is called in a context where the\n    // hydration parent is the parent host component of this host text.\n    var returnFiber = hydrationParentFiber;\n\n    if (returnFiber !== null) {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode);\n            break;\n          }\n\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n\n            var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\n            didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            _isConcurrentMode2);\n            break;\n          }\n      }\n    }\n  }\n\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var suspenseState = fiber.memoizedState;\n  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var suspenseState = fiber.memoizedState;\n  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n    parent = parent.return;\n  }\n\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  } // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them. We also don't delete anything inside the root container.\n\n\n  if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n    var nextInstance = nextHydratableInstance;\n\n    if (nextInstance) {\n      if (shouldClientRenderOnMismatch(fiber)) {\n        warnIfUnhydratedTailNodes(fiber);\n        throwOnHydrationMismatch();\n      } else {\n        while (nextInstance) {\n          deleteHydratableInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n    }\n  }\n\n  popToNextHostParent(fiber);\n\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  }\n\n  return true;\n}\n\nfunction hasUnhydratedTailNodes() {\n  return isHydrating && nextHydratableInstance !== null;\n}\n\nfunction warnIfUnhydratedTailNodes(fiber) {\n  var nextInstance = nextHydratableInstance;\n\n  while (nextInstance) {\n    warnUnhydratedInstance(fiber, nextInstance);\n    nextInstance = getNextHydratableSibling(nextInstance);\n  }\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n  didSuspendOrErrorDEV = false;\n}\n\nfunction upgradeHydrationErrorsToRecoverable() {\n  if (hydrationErrors !== null) {\n    // Successfully completed a forced client render. The errors that occurred\n    // during the hydration attempt are now recovered. We will log them in\n    // commit phase, once the entire tree has finished.\n    queueRecoverableErrors(hydrationErrors);\n    hydrationErrors = null;\n  }\n}\n\nfunction getIsHydrating() {\n  return isHydrating;\n}\n\nfunction queueHydrationError(error) {\n  if (hydrationErrors === null) {\n    hydrationErrors = [error];\n  } else {\n    hydrationErrors.push(error);\n  }\n}\n\nvar ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\nvar NoTransition = null;\nfunction requestCurrentTransition() {\n  return ReactCurrentBatchConfig.transition;\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\n\nfunction shallowEqual(objA, objB) {\n  if (objectIs(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (var i = 0; i < keysA.length; i++) {\n    var currentKey = keysA[i];\n\n    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction describeFiber(fiber) {\n  var owner =  fiber._debugOwner ? fiber._debugOwner.type : null ;\n  var source =  fiber._debugSource ;\n\n  switch (fiber.tag) {\n    case HostComponent:\n      return describeBuiltInComponentFrame(fiber.type);\n\n    case LazyComponent:\n      return describeBuiltInComponentFrame('Lazy');\n\n    case SuspenseComponent:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case SuspenseListComponent:\n      return describeBuiltInComponentFrame('SuspenseList');\n\n    case FunctionComponent:\n    case IndeterminateComponent:\n    case SimpleMemoComponent:\n      return describeFunctionComponentFrame(fiber.type);\n\n    case ForwardRef:\n      return describeFunctionComponentFrame(fiber.type.render);\n\n    case ClassComponent:\n      return describeClassComponentFrame(fiber.type);\n\n    default:\n      return '';\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  try {\n    var info = '';\n    var node = workInProgress;\n\n    do {\n      info += describeFiber(node);\n      node = node.return;\n    } while (node);\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}\n\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\nvar current = null;\nvar isRendering = false;\nfunction getCurrentFiberOwnerNameInDevOrNull() {\n  {\n    if (current === null) {\n      return null;\n    }\n\n    var owner = current._debugOwner;\n\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentNameFromFiber(owner);\n    }\n  }\n\n  return null;\n}\n\nfunction getCurrentFiberStackInDev() {\n  {\n    if (current === null) {\n      return '';\n    } // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n\n\n    return getStackByFiberInDevAndProd(current);\n  }\n}\n\nfunction resetCurrentFiber() {\n  {\n    ReactDebugCurrentFrame$1.getCurrentStack = null;\n    current = null;\n    isRendering = false;\n  }\n}\nfunction setCurrentFiber(fiber) {\n  {\n    ReactDebugCurrentFrame$1.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n    current = fiber;\n    isRendering = false;\n  }\n}\nfunction getCurrentFiber() {\n  {\n    return current;\n  }\n}\nfunction setIsRendering(rendering) {\n  {\n    isRendering = rendering;\n  }\n}\n\nvar ReactStrictModeWarnings = {\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordLegacyContextWarning: function (fiber, instance) {},\n  flushLegacyContextWarning: function () {},\n  discardPendingWarnings: function () {}\n};\n\n{\n  var findStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n    var node = fiber;\n\n    while (node !== null) {\n      if (node.mode & StrictLegacyMode) {\n        maybeStrictRoot = node;\n      }\n\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingUNSAFE_ComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n\n  var didWarnAboutUnsafeLifecycles = new Set();\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    // Dedupe strategy: Warn once per component.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n    instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n    }\n\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n    }\n\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    // We do an initial pass to gather component names\n    var componentWillMountUniqueNames = new Set();\n\n    if (pendingComponentWillMountWarnings.length > 0) {\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillMountWarnings = [];\n    }\n\n    var UNSAFE_componentWillMountUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillMountWarnings = [];\n    }\n\n    var componentWillReceivePropsUniqueNames = new Set();\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n    }\n\n    var componentWillUpdateUniqueNames = new Set();\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillUpdateWarnings = [];\n    }\n\n    var UNSAFE_componentWillUpdateUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillUpdateWarnings = [];\n    } // Finally, we flush all the warnings\n    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n\n\n    if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n\n      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n    }\n\n    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n\n      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n    }\n\n    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n\n      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n    }\n\n    if (componentWillMountUniqueNames.size > 0) {\n      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n\n      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n    }\n\n    if (componentWillReceivePropsUniqueNames.size > 0) {\n      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n\n      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n    }\n\n    if (componentWillUpdateUniqueNames.size > 0) {\n      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n\n      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n    }\n  };\n\n  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n\n  var didWarnAboutLegacyContext = new Set();\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n\n    if (strictRoot === null) {\n      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\n      return;\n    } // Dedup strategy: Warn once per component.\n\n\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n      if (fiberArray.length === 0) {\n        return;\n      }\n\n      var firstFiber = fiberArray[0];\n      var uniqueNames = new Set();\n      fiberArray.forEach(function (fiber) {\n        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n      var sortedNames = setToSortedString(uniqueNames);\n\n      try {\n        setCurrentFiber(firstFiber);\n\n        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);\n      } finally {\n        resetCurrentFiber();\n      }\n    });\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingUNSAFE_ComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n    pendingLegacyContextWarning = new Map();\n  };\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\nfunction checkPropStringCoercion(value, propName) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided `%s` prop is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', propName, typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    var props = assign({}, baseProps);\n    var defaultProps = Component.defaultProps;\n\n    for (var propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n\n    return props;\n  }\n\n  return baseProps;\n}\n\nvar valueCursor = createCursor(null);\nvar rendererSigil;\n\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nvar currentlyRenderingFiber = null;\nvar lastContextDependency = null;\nvar lastFullyObservedContext = null;\nvar isDisallowedContextReadInDEV = false;\nfunction resetContextDependencies() {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n\n  {\n    isDisallowedContextReadInDEV = false;\n  }\n}\nfunction enterDisallowedContextReadInDEV() {\n  {\n    isDisallowedContextReadInDEV = true;\n  }\n}\nfunction exitDisallowedContextReadInDEV() {\n  {\n    isDisallowedContextReadInDEV = false;\n  }\n}\nfunction pushProvider(providerFiber, context, nextValue) {\n  if (isPrimaryRenderer) {\n    push(valueCursor, context._currentValue, providerFiber);\n    context._currentValue = nextValue;\n\n    {\n      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n      }\n\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(valueCursor, context._currentValue2, providerFiber);\n    context._currentValue2 = nextValue;\n\n    {\n      if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n      }\n\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\nfunction popProvider(context, providerFiber) {\n  var currentValue = valueCursor.current;\n  pop(valueCursor, providerFiber);\n\n  if (isPrimaryRenderer) {\n    {\n      context._currentValue = currentValue;\n    }\n  } else {\n    {\n      context._currentValue2 = currentValue;\n    }\n  }\n}\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n  // Update the child lanes of all the ancestors, including the alternates.\n  var node = parent;\n\n  while (node !== null) {\n    var alternate = node.alternate;\n\n    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n      node.childLanes = mergeLanes(node.childLanes, renderLanes);\n\n      if (alternate !== null) {\n        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n      }\n    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n    }\n\n    if (node === propagationRoot) {\n      break;\n    }\n\n    node = node.return;\n  }\n\n  {\n    if (node !== propagationRoot) {\n      error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n}\nfunction propagateContextChange(workInProgress, context, renderLanes) {\n  {\n    propagateContextChange_eager(workInProgress, context, renderLanes);\n  }\n}\n\nfunction propagateContextChange_eager(workInProgress, context, renderLanes) {\n\n  var fiber = workInProgress.child;\n\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n\n  while (fiber !== null) {\n    var nextFiber = void 0; // Visit this fiber.\n\n    var list = fiber.dependencies;\n\n    if (list !== null) {\n      nextFiber = fiber.child;\n      var dependency = list.firstContext;\n\n      while (dependency !== null) {\n        // Check if the context matches.\n        if (dependency.context === context) {\n          // Match! Schedule an update on this fiber.\n          if (fiber.tag === ClassComponent) {\n            // Schedule a force update on the work-in-progress.\n            var lane = pickArbitraryLane(renderLanes);\n            var update = createUpdate(NoTimestamp, lane);\n            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n            // update to the current fiber, too, which means it will persist even if\n            // this render is thrown away. Since it's a race condition, not sure it's\n            // worth fixing.\n            // Inlined `enqueueUpdate` to remove interleaved update check\n\n            var updateQueue = fiber.updateQueue;\n\n            if (updateQueue === null) ; else {\n              var sharedQueue = updateQueue.shared;\n              var pending = sharedQueue.pending;\n\n              if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n              } else {\n                update.next = pending.next;\n                pending.next = update;\n              }\n\n              sharedQueue.pending = update;\n            }\n          }\n\n          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n          var alternate = fiber.alternate;\n\n          if (alternate !== null) {\n            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n          }\n\n          scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n\n          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n          // dependency list.\n\n          break;\n        }\n\n        dependency = dependency.next;\n      }\n    } else if (fiber.tag === ContextProvider) {\n      // Don't scan deeper if this is a matching provider\n      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n    } else if (fiber.tag === DehydratedFragment) {\n      // If a dehydrated suspense boundary is in this subtree, we don't know\n      // if it will have any context consumers in it. The best we can do is\n      // mark it as having updates.\n      var parentSuspense = fiber.return;\n\n      if (parentSuspense === null) {\n        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n      }\n\n      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n      var _alternate = parentSuspense.alternate;\n\n      if (_alternate !== null) {\n        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n      } // This is intentionally passing this fiber as the parent\n      // because we want to schedule this fiber as having work\n      // on its children. We'll use the childLanes on\n      // this fiber to indicate that a context has changed.\n\n\n      scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n      nextFiber = fiber.sibling;\n    } else {\n      // Traverse down.\n      nextFiber = fiber.child;\n    }\n\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n\n        var sibling = nextFiber.sibling;\n\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        } // No more siblings. Traverse up.\n\n\n        nextFiber = nextFiber.return;\n      }\n    }\n\n    fiber = nextFiber;\n  }\n}\nfunction prepareToReadContext(workInProgress, renderLanes) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n  var dependencies = workInProgress.dependencies;\n\n  if (dependencies !== null) {\n    {\n      var firstContext = dependencies.firstContext;\n\n      if (firstContext !== null) {\n        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n          // Context list has a pending update. Mark that this fiber performed work.\n          markWorkInProgressReceivedUpdate();\n        } // Reset the work-in-progress list\n\n\n        dependencies.firstContext = null;\n      }\n    }\n  }\n}\nfunction readContext(context) {\n  {\n    // This warning would fire if you read context inside a Hook like useMemo.\n    // Unlike the class check below, it's not enforced in production for perf.\n    if (isDisallowedContextReadInDEV) {\n      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n    }\n  }\n\n  var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n\n  if (lastFullyObservedContext === context) ; else {\n    var contextItem = {\n      context: context,\n      memoizedValue: value,\n      next: null\n    };\n\n    if (lastContextDependency === null) {\n      if (currentlyRenderingFiber === null) {\n        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n      } // This is the first dependency for this component. Create a new list.\n\n\n      lastContextDependency = contextItem;\n      currentlyRenderingFiber.dependencies = {\n        lanes: NoLanes,\n        firstContext: contextItem\n      };\n    } else {\n      // Append a new context item.\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n  }\n\n  return value;\n}\n\n// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\n\nvar concurrentQueues = null;\nfunction pushConcurrentUpdateQueue(queue) {\n  if (concurrentQueues === null) {\n    concurrentQueues = [queue];\n  } else {\n    concurrentQueues.push(queue);\n  }\n}\nfunction finishQueueingConcurrentUpdates() {\n  // Transfer the interleaved updates onto the main queue. Each queue has a\n  // `pending` field and an `interleaved` field. When they are not null, they\n  // point to the last node in a circular linked list. We need to append the\n  // interleaved list to the end of the pending list by joining them into a\n  // single, circular list.\n  if (concurrentQueues !== null) {\n    for (var i = 0; i < concurrentQueues.length; i++) {\n      var queue = concurrentQueues[i];\n      var lastInterleavedUpdate = queue.interleaved;\n\n      if (lastInterleavedUpdate !== null) {\n        queue.interleaved = null;\n        var firstInterleavedUpdate = lastInterleavedUpdate.next;\n        var lastPendingUpdate = queue.pending;\n\n        if (lastPendingUpdate !== null) {\n          var firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = firstInterleavedUpdate;\n          lastInterleavedUpdate.next = firstPendingUpdate;\n        }\n\n        queue.pending = lastInterleavedUpdate;\n      }\n    }\n\n    concurrentQueues = null;\n  }\n}\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n  var interleaved = queue.interleaved;\n\n  if (interleaved === null) {\n    // This is the first update. Create a circular list.\n    update.next = update; // At the end of the current render, this queue's interleaved updates will\n    // be transferred to the pending queue.\n\n    pushConcurrentUpdateQueue(queue);\n  } else {\n    update.next = interleaved.next;\n    interleaved.next = update;\n  }\n\n  queue.interleaved = update;\n  return markUpdateLaneFromFiberToRoot(fiber, lane);\n}\nfunction enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {\n  var interleaved = queue.interleaved;\n\n  if (interleaved === null) {\n    // This is the first update. Create a circular list.\n    update.next = update; // At the end of the current render, this queue's interleaved updates will\n    // be transferred to the pending queue.\n\n    pushConcurrentUpdateQueue(queue);\n  } else {\n    update.next = interleaved.next;\n    interleaved.next = update;\n  }\n\n  queue.interleaved = update;\n}\nfunction enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n  var interleaved = queue.interleaved;\n\n  if (interleaved === null) {\n    // This is the first update. Create a circular list.\n    update.next = update; // At the end of the current render, this queue's interleaved updates will\n    // be transferred to the pending queue.\n\n    pushConcurrentUpdateQueue(queue);\n  } else {\n    update.next = interleaved.next;\n    interleaved.next = update;\n  }\n\n  queue.interleaved = update;\n  return markUpdateLaneFromFiberToRoot(fiber, lane);\n}\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\n  return markUpdateLaneFromFiberToRoot(fiber, lane);\n} // Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\n\nvar unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;\n\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n  // Update the source fiber's lanes\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  var alternate = sourceFiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n\n  {\n    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  } // Walk the parent path to the root and update the child lanes.\n\n\n  var node = sourceFiber;\n  var parent = sourceFiber.return;\n\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    } else {\n      {\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        }\n      }\n    }\n\n    node = parent;\n    parent = parent.return;\n  }\n\n  if (node.tag === HostRoot) {\n    var root = node.stateNode;\n    return root;\n  } else {\n    return null;\n  }\n}\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nvar hasForceUpdate = false;\nvar didWarnUpdateInsideUpdate;\nvar currentlyProcessingQueue;\n\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n}\n\nfunction initializeUpdateQueue(fiber) {\n  var queue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes\n    },\n    effects: null\n  };\n  fiber.updateQueue = queue;\n}\nfunction cloneUpdateQueue(current, workInProgress) {\n  // Clone the update queue from current. Unless it's already a clone.\n  var queue = workInProgress.updateQueue;\n  var currentQueue = current.updateQueue;\n\n  if (queue === currentQueue) {\n    var clone = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\nfunction createUpdate(eventTime, lane) {\n  var update = {\n    eventTime: eventTime,\n    lane: lane,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null\n  };\n  return update;\n}\nfunction enqueueUpdate(fiber, update, lane) {\n  var updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return null;\n  }\n\n  var sharedQueue = updateQueue.shared;\n\n  {\n    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  if (isUnsafeClassRenderPhaseUpdate()) {\n    // This is an unsafe render phase update. Add directly to the update\n    // queue so we can process it immediately during the current render.\n    var pending = sharedQueue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n    // this fiber. This is for backwards compatibility in the case where you\n    // update a different component during render phase than the one that is\n    // currently renderings (a pattern that is accompanied by a warning).\n\n    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n  } else {\n    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n  }\n}\nfunction entangleTransitions(root, fiber, lane) {\n  var updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  var sharedQueue = updateQueue.shared;\n\n  if (isTransitionLane(lane)) {\n    var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    var newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n\n  var current = workInProgress.alternate;\n\n  if (current !== null) {\n    var currentQueue = current.updateQueue;\n\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      var newFirst = null;\n      var newLast = null;\n      var firstBaseUpdate = queue.firstBaseUpdate;\n\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        var update = firstBaseUpdate;\n\n        do {\n          var clone = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          }\n\n          update = update.next;\n        } while (update !== null); // Append the captured update the end of the cloned list.\n\n\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        effects: currentQueue.effects\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  } // Append the update to the end of the list.\n\n\n  var lastBaseUpdate = queue.lastBaseUpdate;\n\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        var payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          {\n            enterDisallowedContextReadInDEV();\n          }\n\n          var nextState = payload.call(instance, prevState, nextProps);\n\n          {\n            if ( workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        var _payload = update.payload;\n        var partialState;\n\n        if (typeof _payload === 'function') {\n          // Updater function\n          {\n            enterDisallowedContextReadInDEV();\n          }\n\n          partialState = _payload.call(instance, prevState, nextProps);\n\n          {\n            if ( workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                _payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = _payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nfunction processUpdateQueue(workInProgress, props, instance, renderLanes) {\n  // This is always non-null on a ClassComponent or HostRoot\n  var queue = workInProgress.updateQueue;\n  hasForceUpdate = false;\n\n  {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  var firstBaseUpdate = queue.firstBaseUpdate;\n  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n\n  var pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n\n    var lastPendingUpdate = pendingQueue;\n    var firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null; // Append pending updates to base queue\n\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n\n    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n\n    var current = workInProgress.alternate;\n\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      var currentQueue = current.updateQueue;\n      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  } // These values may change as we process the queue.\n\n\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n\n    var newLanes = NoLanes;\n    var newBaseState = null;\n    var newFirstBaseUpdate = null;\n    var newLastBaseUpdate = null;\n    var update = firstBaseUpdate;\n\n    do {\n      var updateLane = update.lane;\n      var updateEventTime = update.eventTime;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        var clone = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n          next: null\n        };\n\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Update the remaining priority in the queue.\n\n\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newLastBaseUpdate !== null) {\n          var _clone = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n        } // Process this update.\n\n\n        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n        var callback = update.callback;\n\n        if (callback !== null && // If the update was already committed, we should not queue its\n        // callback again.\n        update.lane !== NoLane) {\n          workInProgress.flags |= Callback;\n          var effects = queue.effects;\n\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n\n      update = update.next;\n\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n\n          var _firstPendingUpdate = _lastPendingUpdate.next;\n          _lastPendingUpdate.next = null;\n          update = _firstPendingUpdate;\n          queue.lastBaseUpdate = _lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = newBaseState;\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n    // process them during this render, but we do need to track which lanes\n    // are remaining.\n\n    var lastInterleaved = queue.shared.interleaved;\n\n    if (lastInterleaved !== null) {\n      var interleaved = lastInterleaved;\n\n      do {\n        newLanes = mergeLanes(newLanes, interleaved.lane);\n        interleaved = interleaved.next;\n      } while (interleaved !== lastInterleaved);\n    } else if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    } // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n  }\n\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\nfunction commitUpdateQueue(finishedWork, finishedQueue, instance) {\n  // Commit the effects\n  var effects = finishedQueue.effects;\n  finishedQueue.effects = null;\n\n  if (effects !== null) {\n    for (var i = 0; i < effects.length; i++) {\n      var effect = effects[i];\n      var callback = effect.callback;\n\n      if (callback !== null) {\n        effect.callback = null;\n        callCallback(callback, instance);\n      }\n    }\n  }\n}\n\nvar fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\n\nvar emptyRefsObject = new React.Component().refs;\nvar didWarnAboutStateAssignmentForComponent;\nvar didWarnAboutUninitializedState;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nvar didWarnAboutLegacyLifecyclesAndDerivedState;\nvar didWarnAboutUndefinedDerivedState;\nvar warnOnUndefinedDerivedState;\nvar warnOnInvalidCallback;\nvar didWarnAboutDirectlyAssigningPropsToState;\nvar didWarnAboutContextTypeAndContextTypes;\nvar didWarnAboutInvalidateContextType;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n\n    var key = callerName + '_' + callback;\n\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n\n      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentNameFromType(type) || 'Component';\n\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n\n        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  }; // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n\n\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  var prevState = workInProgress.memoizedState;\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        // Invoke the function an extra time to help detect side-effects.\n        partialState = getDerivedStateFromProps(nextProps, prevState);\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    warnOnUndefinedDerivedState(ctor, partialState);\n  } // Merge the partial state and the previous state.\n\n\n  var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n  // base state.\n\n  if (workInProgress.lanes === NoLanes) {\n    // Queue is always non-null for classes\n    var updateQueue = workInProgress.updateQueue;\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    }\n\n    var root = enqueueUpdate(fiber, update, lane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n\n      update.callback = callback;\n    }\n\n    var root = enqueueUpdate(fiber, update, lane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    var root = enqueueUpdate(fiber, update, lane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markForceUpdateScheduled(fiber, lane);\n    }\n  }\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  var instance = workInProgress.stateNode;\n\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n\n    {\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          // Invoke the function an extra time to help detect side-effects.\n          shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      if (shouldUpdate === undefined) {\n        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  var instance = workInProgress.stateNode;\n\n  {\n    var name = getComponentNameFromType(ctor) || 'Component';\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n    }\n\n    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n    }\n\n    if (instance.propTypes) {\n      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n    }\n\n    if (instance.contextType) {\n      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n    }\n\n    {\n      if (instance.contextTypes) {\n        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      }\n\n      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n\n        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n    }\n\n    if (typeof instance.componentDidUnmount === 'function') {\n      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n    }\n\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n    }\n\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n    }\n\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n    }\n\n    var hasMutatedProps = instance.props !== newProps;\n\n    if (instance.props !== undefined && hasMutatedProps) {\n      error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n    }\n\n    if (instance.defaultProps) {\n      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n\n      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n    }\n\n    var _state = instance.state;\n\n    if (_state && (typeof _state !== 'object' || isArray(_state))) {\n      error('%s.state: must be set to an object or null', name);\n    }\n\n    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n  set(instance, workInProgress);\n\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props) {\n  var isLegacyContextConsumer = false;\n  var unmaskedContext = emptyContextObject;\n  var context = emptyContextObject;\n  var contextType = ctor.contextType;\n\n  {\n    if ('contextType' in ctor) {\n      var isValid = // Allow null for conditional declaration\n      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n        var addendum = '';\n\n        if (contextType === undefined) {\n          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n        }\n\n        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext(contextType);\n  } else {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    var contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n  }\n\n  var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n\n  {\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        instance = new ctor(props, context); // eslint-disable-line no-new\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n  }\n\n  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n\n        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        var _componentName = getComponentNameFromType(ctor) || 'Component';\n\n        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n\n          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n        }\n      }\n    }\n  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  if (oldState !== instance.state) {\n    {\n      error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n\n        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\nfunction mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  var instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  initializeUpdateQueue(workInProgress);\n  var contextType = ctor.contextType;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else {\n    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  {\n    if (instance.state === newProps) {\n      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n\n        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n    }\n  }\n\n  instance.state = workInProgress.memoizedState;\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  } // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n    // process them now.\n\n    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    var fiberFlags = Update;\n\n    {\n      fiberFlags |= LayoutStatic;\n    }\n\n    if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n      fiberFlags |= MountLayoutDev;\n    }\n\n    workInProgress.flags |= fiberFlags;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  var instance = workInProgress.stateNode;\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n  var oldContext = instance.context;\n  var contextType = ctor.contextType;\n  var nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      var fiberFlags = Update;\n\n      {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n    }\n\n    if (typeof instance.componentDidMount === 'function') {\n      var _fiberFlags = Update;\n\n      {\n        _fiberFlags |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        _fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= _fiberFlags;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      var _fiberFlags2 = Update;\n\n      {\n        _fiberFlags2 |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        _fiberFlags2 |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= _fiberFlags2;\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n  var instance = workInProgress.stateNode;\n  cloneUpdateQueue(current, workInProgress);\n  var unresolvedOldProps = workInProgress.memoizedProps;\n  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n  instance.props = oldProps;\n  var unresolvedNewProps = workInProgress.pendingProps;\n  var oldContext = instance.context;\n  var contextType = ctor.contextType;\n  var nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(enableLazyContextPropagation   )) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n  // both before and after `shouldComponentUpdate` has been called. Not ideal,\n  // but I'm loath to refactor this function. This only happens for memoized\n  // components so it's not that common.\n  enableLazyContextPropagation   ;\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n    }\n\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.flags |= Update;\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.flags |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n}\n\nvar didWarnAboutMaps;\nvar didWarnAboutGenerators;\nvar didWarnAboutStringRefs;\nvar ownerHasKeyUseWarning;\nvar ownerHasFunctionTypeWarning;\n\nvar warnForMissingKey = function (child, returnFiber) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child, returnFiber) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    child._store.validated = true;\n    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[componentName] = true;\n\n    error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\n  };\n}\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n      // because these cannot be automatically converted to an arrow function\n      // using a codemod. Therefore, we don't have to warn about string refs again.\n      !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n        var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          {\n            error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst;\n\n      if (owner) {\n        var ownerFiber = owner;\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + 'bug in React. Please file an issue.');\n      } // Assigning this to a const so Flow knows it won't change in the closure\n\n\n      var resolvedInst = inst;\n\n      {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n\n      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      var ref = function (value) {\n        var refs = resolvedInst.refs;\n\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = resolvedInst.refs = {};\n        }\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      }\n\n      if (!element._owner) {\n        throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');\n      }\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  var childString = Object.prototype.toString.call(newChild);\n  throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n}\n\nfunction warnOnFunctionType(returnFiber) {\n  {\n    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n\n    ownerHasFunctionTypeWarning[componentName] = true;\n\n    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  var payload = lazyType._payload;\n  var init = lazyType._init;\n  return init(payload);\n} // This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\n\n\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n\n    var deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    var childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    var existingChildren = new Map();\n    var existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n\n    var current = newFiber.alternate;\n\n    if (current !== null) {\n      var oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, lanes) {\n    var elementType = element.type;\n\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n    }\n\n    if (current !== null) {\n      if (current.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n       isCompatibleFamilyForHotReloading(current, element) ) || // Lazy types should reconcile their resolved type.\n      // We need to do this after the Hot Reloading check above,\n      // because hot reloading has different semantics than prod because\n      // it doesn't resuspend. So we can't let the call below suspend.\n      typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n        // Move based on index\n        var existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n\n        {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      }\n    } // Insert\n\n\n    var created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created.return = returnFiber;\n            return _created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n\n            _created2.return = returnFiber;\n            return _created2;\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            var payload = newChild._payload;\n            var init = newChild._init;\n            return createChild(returnFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    // Update the fiber if the keys match, otherwise return null.\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateElement(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            var payload = newChild._payload;\n            var init = newChild._init;\n            return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n          }\n\n        case REACT_LAZY_TYPE:\n          var payload = newChild._payload;\n          var init = newChild._init;\n          return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys, returnFiber) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          var key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted \u2014 the behavior is unsupported and ' + 'could change in a future version.', key);\n\n          break;\n\n        case REACT_LAZY_TYPE:\n          var payload = child._payload;\n          var init = child._init;\n          warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n          break;\n      }\n    }\n\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n    {\n      // First, validate keys.\n      var knownKeys = null;\n\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        var numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n\n        if (_newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n\n        previousNewFiber = _newFiber;\n      }\n\n      if (getIsHydrating()) {\n        var _numberOfForks = newIdx;\n        pushTreeFork(returnFiber, _numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n      if (_newFiber2 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    if (getIsHydrating()) {\n      var _numberOfForks2 = newIdx;\n      pushTreeFork(returnFiber, _numberOfForks2);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n    }\n\n    {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        if (!didWarnAboutGenerators) {\n          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        }\n\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n        }\n\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (_newChildren) {\n        var knownKeys = null;\n\n        var _step = _newChildren.next();\n\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    var step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        var numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, lanes);\n\n        if (_newFiber3 === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n\n        previousNewFiber = _newFiber3;\n      }\n\n      if (getIsHydrating()) {\n        var _numberOfForks3 = newIdx;\n        pushTreeFork(returnFiber, _numberOfForks3);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    if (getIsHydrating()) {\n      var _numberOfForks4 = newIdx;\n      pushTreeFork(returnFiber, _numberOfForks4);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    } // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n    var key = element.key;\n    var child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        var elementType = element.type;\n\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n\n            {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } else {\n          if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n           isCompatibleFamilyForHotReloading(child, element) ) || // Lazy types should reconcile their resolved type.\n          // We need to do this after the Hot Reloading check above,\n          // because hot reloading has different semantics than prod because\n          // it doesn't resuspend. So we can't let the call below suspend.\n          typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n\n            var _existing = useFiber(child, element.props);\n\n            _existing.ref = coerceRef(returnFiber, child, element);\n            _existing.return = returnFiber;\n\n            {\n              _existing._debugSource = element._source;\n              _existing._debugOwner = element._owner;\n            }\n\n            return _existing;\n          }\n        } // Didn't match.\n\n\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n    var key = portal.key;\n    var child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n\n\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          var payload = newChild._payload;\n          var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n          return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\nfunction cloneChildFibers(current, workInProgress) {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nfunction resetChildFibers(workInProgress, lanes) {\n  var child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}\n\nvar NO_CONTEXT = {};\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  if (c === NO_CONTEXT) {\n    throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n  if (context === nextContext) {\n    return;\n  } // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\n\nvar SubtreeSuspenseContextMask = 1; // Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\n\nvar InvisibleParentSuspenseContext = 1; // Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\n\nvar ForceSuspenseFallback = 2;\nvar suspenseStackCursor = createCursor(DefaultSuspenseContext);\nfunction hasSuspenseContext(parentContext, flag) {\n  return (parentContext & flag) !== 0;\n}\nfunction setDefaultShallowSuspenseContext(parentContext) {\n  return parentContext & SubtreeSuspenseContextMask;\n}\nfunction setShallowSuspenseContext(parentContext, shallowContext) {\n  return parentContext & SubtreeSuspenseContextMask | shallowContext;\n}\nfunction addSubtreeSuspenseContext(parentContext, subtreeContext) {\n  return parentContext | subtreeContext;\n}\nfunction pushSuspenseContext(fiber, newContext) {\n  push(suspenseStackCursor, newContext, fiber);\n}\nfunction popSuspenseContext(fiber) {\n  pop(suspenseStackCursor, fiber);\n}\n\nfunction shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  var nextState = workInProgress.memoizedState;\n\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n\n    return false;\n  }\n\n  var props = workInProgress.memoizedProps; // Regular boundaries always capture.\n\n  {\n    return true;\n  } // If it's a boundary we should avoid, then we prefer to bubble up to the\n}\nfunction findFirstSuspended(row) {\n  var node = row;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      var state = node.memoizedState;\n\n      if (state !== null) {\n        var dehydrated = state.dehydrated;\n\n        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n          return node;\n        }\n      }\n    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n    // keep track of whether it suspended or not.\n    node.memoizedProps.revealOrder !== undefined) {\n      var didSuspend = (node.flags & DidCapture) !== NoFlags;\n\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === row) {\n      return null;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n\n  return null;\n}\n\nvar NoFlags$1 =\n/*   */\n0; // Represents whether effect should fire.\n\nvar HasEffect =\n/* */\n1; // Represents the phase in which the effect (not the clean-up) fires.\n\nvar Insertion =\n/*  */\n2;\nvar Layout =\n/*    */\n4;\nvar Passive$1 =\n/*   */\n8;\n\n// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\n\nvar workInProgressSources = [];\nfunction resetWorkInProgressVersions() {\n  for (var i = 0; i < workInProgressSources.length; i++) {\n    var mutableSource = workInProgressSources[i];\n\n    if (isPrimaryRenderer) {\n      mutableSource._workInProgressVersionPrimary = null;\n    } else {\n      mutableSource._workInProgressVersionSecondary = null;\n    }\n  }\n\n  workInProgressSources.length = 0;\n}\n// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\n\nfunction registerMutableSourceForHydration(root, mutableSource) {\n  var getVersion = mutableSource._getVersion;\n  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\n  // Retaining it forever may interfere with GC.\n\n  if (root.mutableSourceEagerHydrationData == null) {\n    root.mutableSourceEagerHydrationData = [mutableSource, version];\n  } else {\n    root.mutableSourceEagerHydrationData.push(mutableSource, version);\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,\n    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\nvar didWarnAboutMismatchedHooksForComponent;\nvar didWarnUncachedGetSnapshot;\n\n{\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\n// These are set right before calling the component.\nvar renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nvar currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nvar currentHook = null;\nvar workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\n\nvar didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\nvar didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n\nvar localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\n\nvar globalClientIdCounter = 0;\nvar RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nvar currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nvar hookTypesDev = null;\nvar hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nvar ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  {\n    var hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  {\n    var hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  {\n    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        var table = '';\n        var secondColumnStart = 30;\n\n        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          var oldHookName = hookTypesDev[i];\n          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    {\n      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n    }\n  }\n\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (objectIs(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber$1 = workInProgress;\n\n  {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes; // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n\n  {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n    }\n  }\n\n  var children = Component(props, secondArg); // Check if there was a render phase update\n\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    var numberOfReRenders = 0;\n\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      localIdCounter = 0;\n\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n        throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n      }\n\n      numberOfReRenders += 1;\n\n      {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      } // Start over from the beginning of the list\n\n\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n\n      {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;\n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  } // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n\n\n  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n  {\n    workInProgress._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderLanes = NoLanes;\n  currentlyRenderingFiber$1 = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n\n    if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n    // and creates false positives. To make this work in legacy mode, we'd\n    // need to mark fibers that commit in an incomplete state, somehow. For\n    // now I'll disable the warning that most of the bugs that would trigger\n    // it are either exclusive to concurrent mode or exist in both.\n    (current.mode & ConcurrentMode) !== NoMode) {\n      error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  if (didRenderTooFewHooks) {\n    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  }\n\n  return children;\n}\nfunction checkDidRenderIdHook() {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  var didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nfunction bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n\n  if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n    workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n  } else {\n    workInProgress.flags &= ~(Passive | Update);\n  }\n\n  current.lanes = removeLanes(current.lanes, lanes);\n}\nfunction resetHooksAfterThrow() {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    var hook = currentlyRenderingFiber$1.memoizedState;\n\n    while (hook !== null) {\n      var queue = hook.queue;\n\n      if (queue !== null) {\n        queue.pending = null;\n      }\n\n      hook = hook.next;\n    }\n\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber$1 = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n    isUpdatingOpaqueValueInRenderPhase = false;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n}\n\nfunction mountWorkInProgressHook() {\n  var hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  var nextCurrentHook;\n\n  if (currentHook === null) {\n    var current = currentlyRenderingFiber$1.alternate;\n\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  var nextWorkInProgressHook;\n\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n    if (nextCurrentHook === null) {\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n\n    currentHook = nextCurrentHook;\n    var newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue() {\n  return {\n    lastEffect: null,\n    stores: null\n  };\n}\n\nfunction basicStateReducer(state, action) {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  var hook = mountWorkInProgressHook();\n  var initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  var queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  var hook = updateWorkInProgressHook();\n  var queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer;\n  var current = currentHook; // The last rebase update that is NOT part of the base state.\n\n  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n\n  var pendingQueue = queue.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      var baseFirst = baseQueue.next;\n      var pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n      }\n    }\n\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    var first = baseQueue.next;\n    var newState = current.baseState;\n    var newBaseState = null;\n    var newBaseQueueFirst = null;\n    var newBaseQueueLast = null;\n    var update = first;\n\n    do {\n      var updateLane = update.lane;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        var clone = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        };\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n\n\n        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newBaseQueueLast !== null) {\n          var _clone = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          };\n          newBaseQueueLast = newBaseQueueLast.next = _clone;\n        } // Process this update.\n\n\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState;\n        } else {\n          var action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!objectIs(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = newState;\n  } // Interleaved updates are stored on a separate queue. We aren't going to\n  // process them during this render, but we do need to track which lanes\n  // are remaining.\n\n\n  var lastInterleaved = queue.interleaved;\n\n  if (lastInterleaved !== null) {\n    var interleaved = lastInterleaved;\n\n    do {\n      var interleavedLane = interleaved.lane;\n      currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n      markSkippedUpdateLanes(interleavedLane);\n      interleaved = interleaved.next;\n    } while (interleaved !== lastInterleaved);\n  } else if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n\n  var dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer(reducer, initialArg, init) {\n  var hook = updateWorkInProgressHook();\n  var queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n\n  var dispatch = queue.dispatch;\n  var lastRenderPhaseUpdate = queue.pending;\n  var newState = hook.memoizedState;\n\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    var update = firstRenderPhaseUpdate;\n\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      var action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!objectIs(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n\n  return [newState, dispatch];\n}\n\nfunction mountMutableSource(source, getSnapshot, subscribe) {\n  {\n    return undefined;\n  }\n}\n\nfunction updateMutableSource(source, getSnapshot, subscribe) {\n  {\n    return undefined;\n  }\n}\n\nfunction mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1;\n  var hook = mountWorkInProgressHook();\n  var nextSnapshot;\n  var isHydrating = getIsHydrating();\n\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n    }\n\n    nextSnapshot = getServerSnapshot();\n\n    {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n\n    {\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedSnapshot = getSnapshot();\n\n        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n          error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    } // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n\n\n    var root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  } // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n\n  hook.memoizedState = nextSnapshot;\n  var inst = {\n    value: nextSnapshot,\n    getSnapshot: getSnapshot\n  };\n  hook.queue = inst; // Schedule an effect to subscribe to the store.\n\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n\n  fiber.flags |= Passive;\n  pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1;\n  var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n  var nextSnapshot = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedSnapshot = getSnapshot();\n\n      if (!objectIs(nextSnapshot, cachedSnapshot)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  var prevSnapshot = hook.memoizedState;\n  var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n\n  var inst = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n\n  if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n  // checking whether we scheduled a subscription effect above.\n  workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n    fiber.flags |= Passive;\n    pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n\n    var root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= StoreConsistency;\n  var check = {\n    getSnapshot: getSnapshot,\n    value: renderedSnapshot\n  };\n  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.stores = [check];\n  } else {\n    var stores = componentUpdateQueue.stores;\n\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore(fiber, inst, subscribe) {\n  var handleStoreChange = function () {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  }; // Subscribe to the store and return a clean-up function.\n\n\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n\nfunction mountState(initialState) {\n  var hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  var queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer);\n}\n\nfunction rerenderState(initialState) {\n  return rerenderReducer(basicStateReducer);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  var effect = {\n    tag: tag,\n    create: create,\n    destroy: destroy,\n    deps: deps,\n    // Circular\n    next: null\n  };\n  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    var lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      var firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nfunction mountRef(initialValue) {\n  var hook = mountWorkInProgressHook();\n\n  {\n    var _ref2 = {\n      current: initialValue\n    };\n    hook.memoizedState = _ref2;\n    return _ref2;\n  }\n}\n\nfunction updateRef(initialValue) {\n  var hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var destroy = undefined;\n\n  if (currentHook !== null) {\n    var prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      var prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n}\n\nfunction mountEffect(create, deps) {\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n  } else {\n    return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n  }\n}\n\nfunction updateEffect(create, deps) {\n  return updateEffectImpl(Passive, Passive$1, create, deps);\n}\n\nfunction mountInsertionEffect(create, deps) {\n  return mountEffectImpl(Update, Insertion, create, deps);\n}\n\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(Update, Insertion, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  var fiberFlags = Update;\n\n  {\n    fiberFlags |= LayoutStatic;\n  }\n\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDev;\n  }\n\n  return mountEffectImpl(fiberFlags, Layout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(Update, Layout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    var refCallback = ref;\n\n    var _inst = create();\n\n    refCallback(_inst);\n    return function () {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    var refObject = ref;\n\n    {\n      if (!refObject.hasOwnProperty('current')) {\n        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n      }\n    }\n\n    var _inst2 = create();\n\n    refObject.current = _inst2;\n    return function () {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  {\n    if (typeof create !== 'function') {\n      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  var fiberFlags = Update;\n\n  {\n    fiberFlags |= LayoutStatic;\n  }\n\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDev;\n  }\n\n  return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  {\n    if (typeof create !== 'function') {\n      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nvar updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      var prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      var prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  var nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue(value) {\n  var hook = mountWorkInProgressHook();\n  hook.memoizedState = value;\n  return value;\n}\n\nfunction updateDeferredValue(value) {\n  var hook = updateWorkInProgressHook();\n  var resolvedCurrentHook = currentHook;\n  var prevValue = resolvedCurrentHook.memoizedState;\n  return updateDeferredValueImpl(hook, prevValue, value);\n}\n\nfunction rerenderDeferredValue(value) {\n  var hook = updateWorkInProgressHook();\n\n  if (currentHook === null) {\n    // This is a rerender during a mount.\n    hook.memoizedState = value;\n    return value;\n  } else {\n    // This is a rerender during an update.\n    var prevValue = currentHook.memoizedState;\n    return updateDeferredValueImpl(hook, prevValue, value);\n  }\n}\n\nfunction updateDeferredValueImpl(hook, prevValue, value) {\n  var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n\n  if (shouldDeferValue) {\n    // This is an urgent update. If the value has changed, keep using the\n    // previous value and spawn a deferred render to update it later.\n    if (!objectIs(value, prevValue)) {\n      // Schedule a deferred render\n      var deferredLane = claimNextTransitionLane();\n      currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n      markSkippedUpdateLanes(deferredLane); // Set this to true to indicate that the rendered value is inconsistent\n      // from the latest value. The name \"baseState\" doesn't really match how we\n      // use it because we're reusing a state hook field instead of creating a\n      // new one.\n\n      hook.baseState = true;\n    } // Reuse the previous value\n\n\n    return prevValue;\n  } else {\n    // This is not an urgent update, so we can use the latest value regardless\n    // of what it is. No need to defer it.\n    // However, if we're currently inside a spawned render, then we need to mark\n    // this as an update to prevent the fiber from bailing out.\n    //\n    // `baseState` is true when the current value is different from the rendered\n    // value. The name doesn't really match how we use it because we're reusing\n    // a state hook field instead of creating a new one.\n    if (hook.baseState) {\n      // Flip this back to false.\n      hook.baseState = false;\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = value;\n    return value;\n  }\n}\n\nfunction startTransition(setPending, callback, options) {\n  var previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n  setPending(true);\n  var prevTransition = ReactCurrentBatchConfig$1.transition;\n  ReactCurrentBatchConfig$1.transition = {};\n  var currentTransition = ReactCurrentBatchConfig$1.transition;\n\n  {\n    ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();\n  }\n\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$1.transition = prevTransition;\n\n    {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition() {\n  var _mountState = mountState(false),\n      isPending = _mountState[0],\n      setPending = _mountState[1]; // The `start` method never changes.\n\n\n  var start = startTransition.bind(null, setPending);\n  var hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition() {\n  var _updateState = updateState(),\n      isPending = _updateState[0];\n\n  var hook = updateWorkInProgressHook();\n  var start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition() {\n  var _rerenderState = rerenderState(),\n      isPending = _rerenderState[0];\n\n  var hook = updateWorkInProgressHook();\n  var start = hook.memoizedState;\n  return [isPending, start];\n}\n\nvar isUpdatingOpaqueValueInRenderPhase = false;\nfunction getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n  {\n    return isUpdatingOpaqueValueInRenderPhase;\n  }\n}\n\nfunction mountId() {\n  var hook = mountWorkInProgressHook();\n  var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n  // should do this in Fiber, too? Deferring this decision for now because\n  // there's no other place to store the prefix except for an internal field on\n  // the public createRoot object, which the fiber tree does not currently have\n  // a reference to.\n\n  var identifierPrefix = root.identifierPrefix;\n  var id;\n\n  if (getIsHydrating()) {\n    var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n\n    id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n\n    var localId = localIdCounter++;\n\n    if (localId > 0) {\n      id += 'H' + localId.toString(32);\n    }\n\n    id += ':';\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    var globalClientId = globalClientIdCounter++;\n    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId() {\n  var hook = updateWorkInProgressHook();\n  var id = hook.memoizedState;\n  return id;\n}\n\nfunction dispatchReducerAction(fiber, queue, action) {\n  {\n    if (typeof arguments[3] === 'function') {\n      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var update = {\n    lane: lane,\n    action: action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n    if (root !== null) {\n      var eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane);\n}\n\nfunction dispatchSetState(fiber, queue, action) {\n  {\n    if (typeof arguments[3] === 'function') {\n      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var update = {\n    lane: lane,\n    action: action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    var alternate = fiber.alternate;\n\n    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      var lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        var prevDispatcher;\n\n        {\n          prevDispatcher = ReactCurrentDispatcher$1.current;\n          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          var currentState = queue.lastRenderedState;\n          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n\n          if (objectIs(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            // TODO: Do we still need to entangle transitions in this case?\n            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          {\n            ReactCurrentDispatcher$1.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n    if (root !== null) {\n      var eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane);\n}\n\nfunction isRenderPhaseUpdate(fiber) {\n  var alternate = fiber.alternate;\n  return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n}\n\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  var pending = queue.pending;\n\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n\n  queue.pending = update;\n} // TODO: Move to ReactFiberConcurrentUpdates?\n\n\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (isTransitionLane(lane)) {\n    var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    var newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools(fiber, lane, action) {\n\n  {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nvar ContextOnlyDispatcher = {\n  readContext: readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nvar HooksDispatcherOnMountInDEV = null;\nvar HooksDispatcherOnMountWithHookTypesInDEV = null;\nvar HooksDispatcherOnUpdateInDEV = null;\nvar HooksDispatcherOnRerenderInDEV = null;\nvar InvalidNestedHooksDispatcherOnMountInDEV = null;\nvar InvalidNestedHooksDispatcherOnUpdateInDEV = null;\nvar InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\n{\n  var warnInvalidContextAccess = function () {\n    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  var warnInvalidHookAccess = function () {\n    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n}\n\nvar now$1 = Scheduler.unstable_now;\nvar commitTime = 0;\nvar layoutEffectStartTime = -1;\nvar profilerStartTime = -1;\nvar passiveEffectStartTime = -1;\n/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */\n\nvar currentUpdateIsNested = false;\nvar nestedUpdateScheduled = false;\n\nfunction isCurrentUpdateNested() {\n  return currentUpdateIsNested;\n}\n\nfunction markNestedUpdateScheduled() {\n  {\n    nestedUpdateScheduled = true;\n  }\n}\n\nfunction resetNestedUpdateFlag() {\n  {\n    currentUpdateIsNested = false;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction syncNestedUpdateFlag() {\n  {\n    currentUpdateIsNested = nestedUpdateScheduled;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n\n  commitTime = now$1();\n}\n\nfunction startProfilerTimer(fiber) {\n\n  profilerStartTime = now$1();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = now$1();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n\n  if (profilerStartTime >= 0) {\n    var elapsedTime = now$1() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n\n    profilerStartTime = -1;\n  }\n}\n\nfunction recordLayoutEffectDuration(fiber) {\n\n  if (layoutEffectStartTime >= 0) {\n    var elapsedTime = now$1() - layoutEffectStartTime;\n    layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    var parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          var root = parentFiber.stateNode;\n          root.effectDuration += elapsedTime;\n          return;\n\n        case Profiler:\n          var parentStateNode = parentFiber.stateNode;\n          parentStateNode.effectDuration += elapsedTime;\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction recordPassiveEffectDuration(fiber) {\n\n  if (passiveEffectStartTime >= 0) {\n    var elapsedTime = now$1() - passiveEffectStartTime;\n    passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    var parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          var root = parentFiber.stateNode;\n\n          if (root !== null) {\n            root.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n\n        case Profiler:\n          var parentStateNode = parentFiber.stateNode;\n\n          if (parentStateNode !== null) {\n            // Detached fibers have their state node cleared out.\n            // In this case, the return pointer is also cleared out,\n            // so we won't be able to report the time spent in this Profiler's subtree.\n            parentStateNode.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction startLayoutEffectTimer() {\n\n  layoutEffectStartTime = now$1();\n}\n\nfunction startPassiveEffectTimer() {\n\n  passiveEffectStartTime = now$1();\n}\n\nfunction transferActualDuration(fiber) {\n  // Transfer time spent rendering these children so we don't lose it\n  // after we rerender. This is used as a helper in special cases\n  // where we should count the work of multiple passes.\n  var child = fiber.child;\n\n  while (child) {\n    fiber.actualDuration += child.actualDuration;\n    child = child.sibling;\n  }\n}\n\nfunction createCapturedValueAtFiber(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source),\n    digest: null\n  };\n}\nfunction createCapturedValue(value, digest, stack) {\n  return {\n    value: value,\n    source: null,\n    stack: stack != null ? stack : null,\n    digest: digest != null ? digest : null\n  };\n}\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary, errorInfo) {\n  return true;\n}\n\nfunction logCapturedError(boundary, errorInfo) {\n  try {\n    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\n    // This enables renderers like ReactNative to better manage redbox behavior.\n\n    if (logError === false) {\n      return;\n    }\n\n    var error = errorInfo.value;\n\n    if (true) {\n      var source = errorInfo.source;\n      var stack = errorInfo.stack;\n      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling\n      // `preventDefault()` in window `error` handler.\n      // We record this information as an expando on the error.\n\n      if (error != null && error._suppressLogging) {\n        if (boundary.tag === ClassComponent) {\n          // The error is recoverable and was silenced.\n          // Ignore it and don't print the stack addendum.\n          // This is handy for testing error boundaries without noise.\n          return;\n        } // The error is fatal. Since the silencing might have\n        // been accidental, we'll surface it anyway.\n        // However, the browser would have silenced the original error\n        // so we'll print it first, and then print the stack addendum.\n\n\n        console['error'](error); // Don't transform to our wrapper\n        // For a more detailed description of this block, see:\n        // https://github.com/facebook/react/pull/13384\n      }\n\n      var componentName = source ? getComponentNameFromFiber(source) : null;\n      var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : 'The above error occurred in one of your React components:';\n      var errorBoundaryMessage;\n\n      if (boundary.tag === HostRoot) {\n        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';\n      } else {\n        var errorBoundaryName = getComponentNameFromFiber(boundary) || 'Anonymous';\n        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      }\n\n      var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n      // We don't include the original error message and JS stack because the browser\n      // has already printed it. Even if the application swallows the error, it is still\n      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n      console['error'](combinedMessage); // Don't transform to our wrapper\n    } else {\n      // In production, we print the error directly.\n      // This will include the message, the JS stack, and anything the browser wants to show.\n      // We pass the error object instead of custom message so that the browser displays the error natively.\n      console['error'](error); // Don't transform to our wrapper\n    }\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nvar PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(fiber, errorInfo, lane) {\n  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n\n  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: null\n  };\n  var error = errorInfo.value;\n\n  update.callback = function () {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, lane) {\n  var update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n  if (typeof getDerivedStateFromError === 'function') {\n    var error$1 = errorInfo.value;\n\n    update.payload = function () {\n      return getDerivedStateFromError(error$1);\n    };\n\n    update.callback = function () {\n      {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  var inst = fiber.stateNode;\n\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n\n      var error$1 = errorInfo.value;\n      var stack = errorInfo.stack;\n      this.componentDidCatch(error$1, {\n        componentStack: stack !== null ? stack : ''\n      });\n\n      {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, SyncLane)) {\n            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n          }\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\nfunction attachPingListener(root, wakeable, lanes) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  var pingCache = root.pingCache;\n  var threadIDs;\n\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap$1();\n    threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(wakeable);\n\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    }\n  }\n\n  if (!threadIDs.has(lanes)) {\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(lanes);\n    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n\n    {\n      if (isDevToolsPresent) {\n        // If we have pending work still, restore the original updaters\n        restorePendingUpdaters(root, lanes);\n      }\n    }\n\n    wakeable.then(ping, ping);\n  }\n}\n\nfunction attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n  // Retry listener\n  //\n  // If the fallback does commit, we need to attach a different type of\n  // listener. This one schedules an update on the Suspense boundary to turn\n  // the fallback state off.\n  //\n  // Stash the wakeable on the boundary fiber so we can access it in the\n  // commit phase.\n  //\n  // When the wakeable resolves, we'll attempt to render the boundary\n  // again (\"retry\").\n  var wakeables = suspenseBoundary.updateQueue;\n\n  if (wakeables === null) {\n    var updateQueue = new Set();\n    updateQueue.add(wakeable);\n    suspenseBoundary.updateQueue = updateQueue;\n  } else {\n    wakeables.add(wakeable);\n  }\n}\n\nfunction resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n  // A legacy mode Suspense quirk, only relevant to hook components.\n\n\n  var tag = sourceFiber.tag;\n\n  if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n    var currentSource = sourceFiber.alternate;\n\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction getNearestSuspenseBoundaryToCapture(returnFiber) {\n  var node = returnFiber;\n\n  do {\n    if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n      return node;\n    } // This boundary already captured during this render. Continue to the next\n    // boundary.\n\n\n    node = node.return;\n  } while (node !== null);\n\n  return null;\n}\n\nfunction markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (sourceFiber.tag === ClassComponent) {\n        var currentSourceFiber = sourceFiber.alternate;\n\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          var update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update, SyncLane);\n        }\n      } // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n\n\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n\n    return suspenseBoundary;\n  } // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n\n\n  suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a wakeable. The component suspended.\n    var wakeable = value;\n    resetSuspendedComponent(sourceFiber);\n\n    {\n      if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n        markDidThrowWhileHydratingDEV();\n      }\n    }\n\n\n    var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n\n    if (suspenseBoundary !== null) {\n      suspenseBoundary.flags &= ~ForceClientRender;\n      markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n      // commits fallbacks synchronously, so there are no pings.\n\n      if (suspenseBoundary.mode & ConcurrentMode) {\n        attachPingListener(root, wakeable, rootRenderLanes);\n      }\n\n      attachRetryListener(suspenseBoundary, root, wakeable);\n      return;\n    } else {\n      // No boundary was found. Unless this is a sync update, this is OK.\n      // We can suspend and wait for more data to arrive.\n      if (!includesSyncLane(rootRenderLanes)) {\n        // This is not a sync update. Suspend. Since we're not activating a\n        // Suspense boundary, this will unwind all the way to the root without\n        // performing a second pass to render a fallback. (This is arguably how\n        // refresh transitions should work, too, since we're not going to commit\n        // the fallbacks anyway.)\n        //\n        // This case also applies to initial hydration.\n        attachPingListener(root, wakeable, rootRenderLanes);\n        renderDidSuspendDelayIfPossible();\n        return;\n      } // This is a sync/discrete update. We treat this case like an error\n      // because discrete renders are expected to produce a complete tree\n      // synchronously to maintain consistency with external state.\n\n\n      var uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.'); // If we're outside a transition, fall through to the regular error path.\n      // The error will be caught by the nearest suspense boundary.\n\n      value = uncaughtSuspenseError;\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      markDidThrowWhileHydratingDEV();\n\n      var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n\n\n      if (_suspenseBoundary !== null) {\n        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          _suspenseBoundary.flags |= ForceClientRender;\n        }\n\n        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n        // still log it so it can be fixed.\n\n        queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n        return;\n      }\n    }\n  }\n\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  renderDidError(value); // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n\n  var workInProgress = returnFiber;\n\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          var _errorInfo = value;\n          workInProgress.flags |= ShouldCapture;\n          var lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n      case ClassComponent:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n\n        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.flags |= ShouldCapture;\n\n          var _lane = pickArbitraryLane(rootRenderLanes);\n\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\n\n          var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);\n\n          enqueueCapturedUpdate(workInProgress, _update);\n          return;\n        }\n\n        break;\n    }\n\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction getSuspendedCache() {\n  {\n    return null;\n  } // This function is called when a Suspense boundary suspends. It returns the\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar didReceiveUpdate = false;\nvar didWarnAboutBadClass;\nvar didWarnAboutModulePatternComponent;\nvar didWarnAboutContextTypeOnFunctionComponent;\nvar didWarnAboutGetDerivedStateOnFunctionComponent;\nvar didWarnAboutFunctionRefs;\nvar didWarnAboutReassigningProps;\nvar didWarnAboutRevealOrder;\nvar didWarnAboutTailOptions;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n}\n\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  var render = Component.render;\n  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  var nextChildren;\n  var hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (current === null) {\n    var type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      var resolvedType = type;\n\n      {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n    }\n\n    {\n      var innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(type));\n      }\n    }\n\n    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  {\n    var _type = Component.type;\n    var _innerPropTypes = _type.propTypes;\n\n    if (_innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(_innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentNameFromType(_type));\n    }\n  }\n\n  var currentChild = current.child; // This is always exactly one child\n\n  var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    var compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  var newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        var lazyComponent = outerMemoType;\n        var payload = lazyComponent._payload;\n        var init = lazyComponent._init;\n\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          outerMemoType = null;\n        } // Inner propTypes will be validated in the function component path.\n\n\n        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n        if (outerPropTypes) {\n          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop', getComponentNameFromType(outerMemoType));\n        }\n      }\n    }\n  }\n\n  if (current !== null) {\n    var prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\n     workInProgress.type === current.type )) {\n      didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n      // would during a normal fiber bailout.\n      //\n      // We don't have strong guarantees that the props object is referentially\n      // equal during updates where we can't bail out anyway \u2014 like if the props\n      // are shallowly equal, but there's a local state or context update in the\n      // same batch.\n      //\n      // However, as a principle, we should aim to make the behavior consistent\n      // across different ways of memoizing a component. For example, React.memo\n      // has a different internal Fiber layout if you pass a normal function\n      // component (SimpleMemoComponent) versus if you pass a different type\n      // like forwardRef (MemoComponent). But this is an implementation detail.\n      // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n      // affect whether the props object is reused during a bailout.\n\n      workInProgress.pendingProps = nextProps = prevProps;\n\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n}\n\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  var prevState = current !== null ? current.memoizedState : null;\n\n  if (nextProps.mode === 'hidden' || enableLegacyHidden ) {\n    // Rendering a hidden tree.\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      // TODO: Consider how Offscreen should work with transitions in the future\n      var nextState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n        transitions: null\n      };\n      workInProgress.memoizedState = nextState;\n\n      pushRenderLanes(workInProgress, renderLanes);\n    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n      var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n\n      var nextBaseLanes;\n\n      if (prevState !== null) {\n        var prevBaseLanes = prevState.baseLanes;\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n      } else {\n        nextBaseLanes = renderLanes;\n      } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n      var _nextState = {\n        baseLanes: nextBaseLanes,\n        cachePool: spawnedCachePool,\n        transitions: null\n      };\n      workInProgress.memoizedState = _nextState;\n      workInProgress.updateQueue = null;\n      // to avoid a push/pop misalignment.\n\n\n      pushRenderLanes(workInProgress, nextBaseLanes);\n\n      return null;\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n      // Rendering at offscreen, so we can clear the base lanes.\n      var _nextState2 = {\n        baseLanes: NoLanes,\n        cachePool: null,\n        transitions: null\n      };\n      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\n\n      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\n    }\n  } else {\n    // Rendering a visible tree.\n    var _subtreeRenderLanes;\n\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n      _subtreeRenderLanes = renderLanes;\n    }\n\n    pushRenderLanes(workInProgress, _subtreeRenderLanes);\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n} // Note: These happen to have identical begin phases, for now. We shouldn't hold\n\nfunction updateFragment(current, workInProgress, renderLanes) {\n  var nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderLanes) {\n  var nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderLanes) {\n  {\n    workInProgress.flags |= Update;\n\n    {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      var stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n\n    {\n      workInProgress.flags |= RefStatic;\n    }\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  var context;\n\n  {\n    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  var nextChildren;\n  var hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false:\n        {\n          var _instance = workInProgress.stateNode;\n          var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n          // Is there a better way to do this?\n\n          var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n          var state = tempInstance.state;\n\n          _instance.updater.enqueueSetState(_instance, state, null);\n\n          break;\n        }\n\n      case true:\n        {\n          workInProgress.flags |= DidCapture;\n          workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n\n          var error$1 = new Error('Simulated error coming from DevTools');\n          var lane = pickArbitraryLane(renderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          var update = createClassErrorUpdate(workInProgress, createCapturedValueAtFiber(error$1, workInProgress), lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          break;\n        }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  var hasContext;\n\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var instance = workInProgress.stateNode;\n  var shouldUpdate;\n\n  if (instance === null) {\n    resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress); // In the initial pass we might need to construct the instance.\n\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n  }\n\n  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n\n  {\n    var inst = workInProgress.stateNode;\n\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n      }\n\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  var instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner$1.current = workInProgress;\n  var nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    {\n      stopProfilerTimerIfRunning();\n    }\n  } else {\n    {\n      markComponentRenderStarted(workInProgress);\n    }\n\n    {\n      setIsRendering(true);\n      nextChildren = instance.render();\n\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      setIsRendering(false);\n    }\n\n    {\n      markComponentRenderStopped();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  var nextState = workInProgress.memoizedState;\n  var root = workInProgress.stateNode;\n  // being called \"element\".\n\n\n  var nextChildren = nextState.element;\n\n  if (supportsHydration && prevState.isDehydrated) {\n    // This is a hydration root whose shell has not yet hydrated. We should\n    // attempt to hydrate.\n    // Flip isDehydrated to false to indicate that when this render\n    // finishes, the root will no longer be dehydrated.\n    var overrideState = {\n      element: nextChildren,\n      isDehydrated: false,\n      cache: nextState.cache,\n      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\n      transitions: nextState.transitions\n    };\n    var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n    // have reducer functions so it doesn't need rebasing.\n\n    updateQueue.baseState = overrideState;\n    workInProgress.memoizedState = overrideState;\n\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during a previous attempt to hydrate the shell, so we\n      // forced a client render.\n      var recoverableError = createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.'), workInProgress);\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n    } else if (nextChildren !== prevChildren) {\n      var _recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);\n    } else {\n      // The outermost shell has not hydrated yet. Start hydrating.\n      enterHydrationState(workInProgress);\n\n      var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n      workInProgress.child = child;\n      var node = child;\n\n      while (node) {\n        // Mark each child as hydrating. This is a fast path to know whether this\n        // tree is part of a hydrating tree. This is used to determine if a child\n        // node has fully mounted yet, and for scheduling event replaying.\n        // Conceptually this is similar to Placement in that a new subtree is\n        // inserted into the React tree here. It just happens to not need DOM\n        // mutations because it already exists.\n        node.flags = node.flags & ~Placement | Hydrating;\n        node = node.sibling;\n      }\n    }\n  } else {\n    // Root is not dehydrated. Either this is a client-only root, or it\n    // already hydrated.\n    resetHydrationState();\n\n    if (nextChildren === prevChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nfunction mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n  // Revert to client rendering.\n  resetHydrationState();\n  queueHydrationError(recoverableError);\n  workInProgress.flags |= ForceClientRender;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current !== null ? current.memoizedProps : null;\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n  var props = workInProgress.pendingProps;\n  var lazyComponent = elementType;\n  var payload = lazyComponent._payload;\n  var init = lazyComponent._init;\n  var Component = init(payload); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  var resolvedProps = resolveDefaultProps(Component, props);\n  var child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ClassComponent:\n      {\n        {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ForwardRef:\n      {\n        {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case MemoComponent:\n      {\n        {\n          if (workInProgress.type !== workInProgress.elementType) {\n            var outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(Component));\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes);\n        return child;\n      }\n  }\n\n  var hint = '';\n\n  {\n    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n\n\n  throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress); // Promote the fiber to a class and try rendering again.\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  var hasContext;\n\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n}\n\nfunction mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n  var props = workInProgress.pendingProps;\n  var context;\n\n  {\n    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var value;\n  var hasId;\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      var componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner$1.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      var _componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[_componentName]) {\n        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);\n\n        didWarnAboutModulePatternComponent[_componentName] = true;\n      }\n    }\n  }\n\n  if ( // Run these checks in production only if the flag is off.\n  // Eventually we'll delete this branch altogether.\n   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    {\n      var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[_componentName2]) {\n        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);\n\n        didWarnAboutModulePatternComponent[_componentName2] = true;\n      }\n    } // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    var hasContext = false;\n\n    if (isContextProvider(Component)) {\n      hasContext = true;\n      pushContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    initializeUpdateQueue(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    {\n\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n          hasId = checkDidRenderIdHook();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n\n    {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  {\n    if (Component) {\n      if (Component.childContextTypes) {\n        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n      }\n    }\n\n    if (workInProgress.ref !== null) {\n      var info = '';\n      var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      var warningKey = ownerName || '';\n      var debugSource = workInProgress._debugSource;\n\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n\n        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);\n\n        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n      }\n    }\n\n    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n      var _componentName4 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n        error('%s: Function components do not support contextType.', _componentName4);\n\n        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n      }\n    }\n  }\n}\n\nvar SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane\n};\n\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCache(),\n    transitions: null\n  };\n}\n\nfunction updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n  var cachePool = null;\n\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool: cachePool,\n    transitions: prevOffscreenState.transitions\n  };\n} // TODO: Probably should inline this back\n\n\nfunction shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    var suspenseState = current.memoizedState;\n\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  } // Not currently showing content. Consult the Suspense context.\n\n\n  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n}\n\nfunction getRemainingWorkInPrimaryTree(current, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  var suspenseContext = suspenseStackCursor.current;\n  var showFallback = false;\n  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (current === null || current.memoizedState !== null) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n      {\n        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n\n  if (current === null) {\n    // Initial mount\n    // Special path for hydration\n    // If we're currently hydrating, try to hydrate this boundary.\n    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n    var suspenseState = workInProgress.memoizedState;\n\n    if (suspenseState !== null) {\n      var dehydrated = suspenseState.dehydrated;\n\n      if (dehydrated !== null) {\n        return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n      }\n    }\n\n    var nextPrimaryChildren = nextProps.children;\n    var nextFallbackChildren = nextProps.fallback;\n\n    if (showFallback) {\n      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      var primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n\n      return fallbackFragment;\n    } else {\n      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n    }\n  } else {\n    // This is an update.\n    // Special path for hydration\n    var prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      var _dehydrated = prevState.dehydrated;\n\n      if (_dehydrated !== null) {\n        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, _dehydrated, prevState, renderLanes);\n      }\n    }\n\n    if (showFallback) {\n      var _nextFallbackChildren = nextProps.fallback;\n      var _nextPrimaryChildren = nextProps.children;\n      var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n      var _primaryChildFragment2 = workInProgress.child;\n      var prevOffscreenState = current.child.memoizedState;\n      _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n\n      _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    } else {\n      var _nextPrimaryChildren2 = nextProps.children;\n\n      var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2, renderLanes);\n\n      workInProgress.memoizedState = null;\n      return _primaryChildFragment3;\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var progressedPrimaryFragment = workInProgress.child;\n  var primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  var primaryChildFragment;\n  var fallbackChildFragment;\n\n  if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if ( workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n  var currentPrimaryChildFragment = current.child;\n  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n    mode: 'visible',\n    children: primaryChildren\n  });\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    var deletions = workInProgress.deletions;\n\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var currentPrimaryChildFragment = current.child;\n  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  var primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  var primaryChildFragment;\n\n  if ( // In legacy mode, we commit the primary tree as if it successfully\n  // completed, even though it's in an inconsistent state.\n  (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n  // already cloned. In legacy mode, the only case where this isn't true is\n  // when DevTools forces us to display a fallback; we skip the first render\n  // pass entirely and go straight to rendering the fallback. (In Concurrent\n  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n  // only codepath.)\n  workInProgress.child !== currentPrimaryChildFragment) {\n    var progressedPrimaryFragment = workInProgress.child;\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if ( workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n    } // The fallback fiber was added as a deletion during the first pass.\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n\n\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n\n    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n\n  var fallbackChildFragment;\n\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n  } else {\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n  // Falling back to client rendering. Because this has performance\n  // implications, it's considered a recoverable error, even though the user\n  // likely won't observe anything wrong with the UI.\n  //\n  // The error is passed in as an argument to enforce that every caller provide\n  // a custom message, or explicitly opt out (currently the only path that opts\n  // out is legacy mode; every concurrent path provides an error).\n  if (recoverableError !== null) {\n    queueHydrationError(recoverableError);\n  } // This will add the old fiber to the deletion list\n\n\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n\n  var nextProps = workInProgress.pendingProps;\n  var primaryChildren = nextProps.children;\n  var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var fiberMode = workInProgress.mode;\n  var primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n  var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n\n  fallbackChildFragment.flags |= Placement;\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    {\n      error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes) {\n  if (!didSuspend) {\n    // This is the first render pass. Attempt to hydrate.\n    // We should never be hydrating at this point because it is the first pass,\n    // but after we've already committed once.\n    warnIfHydrating();\n\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // TODO: When we delete legacy mode, we should make this error argument\n      // required \u2014 every concurrent mode path that causes hydration to\n      // de-opt to client rendering should have an error message.\n      null);\n    }\n\n    if (isSuspenseInstanceFallback(suspenseInstance)) {\n      // This boundary is in a permanent fallback state. In this case, we'll never\n      // get an update and we'll never be able to hydrate the final content. Let's just try the\n      // client side render instead.\n      var digest, message, stack;\n\n      {\n        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n\n        digest = _getSuspenseInstanceF.digest;\n        message = _getSuspenseInstanceF.message;\n        stack = _getSuspenseInstanceF.stack;\n      }\n\n      var error;\n\n      if (message) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        error = new Error(message);\n      } else {\n        error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.');\n      }\n\n      var capturedValue = createCapturedValue(error, digest, stack);\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);\n    }\n    // any context has changed, we need to treat is as if the input might have changed.\n\n\n    var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n\n    if (didReceiveUpdate || hasContextChanged) {\n      // This boundary has changed since the first render. This means that we are now unable to\n      // hydrate it. We might still be able to hydrate it using a higher priority lane.\n      var root = getWorkInProgressRoot();\n\n      if (root !== null) {\n        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n\n        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n          // Intentionally mutating since this render will get interrupted. This\n          // is one of the very rare times where we mutate the current tree\n          // during the render phase.\n          suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n\n          var eventTime = NoTimestamp;\n          enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n          scheduleUpdateOnFiber(root, current, attemptHydrationAtLane, eventTime);\n        }\n      } // If we have scheduled higher pri work above, this will probably just abort the render\n      // since we now have higher priority work, but in case it doesn't, we need to prepare to\n      // render something, if we time out. Even if that requires us to delete everything and\n      // skip hydration.\n      // Delay having to do this as long as the suspense timeout allows us.\n\n\n      renderDidSuspendDelayIfPossible();\n\n      var _capturedValue = createCapturedValue(new Error('This Suspense boundary received an update before it finished ' + 'hydrating. This caused the boundary to switch to client rendering. ' + 'The usual way to fix this is to wrap the original update ' + 'in startTransition.'));\n\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue);\n    } else if (isSuspenseInstancePending(suspenseInstance)) {\n      // This component is still pending more data from the server, so we can't hydrate its\n      // content. We treat it as if this component suspended itself. It might seem as if\n      // we could just try to render it client-side instead. However, this will perform a\n      // lot of unnecessary work and is unlikely to complete since it often will suspend\n      // on missing data anyway. Additionally, the server might be able to render more\n      // than we can on the client yet. In that case we'd end up with more fallback states\n      // on the client than if we just leave it alone. If the server times out or errors\n      // these should update this boundary to the permanent Fallback state instead.\n      // Mark it as having captured (i.e. suspended).\n      workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n      workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n      var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n      registerSuspenseInstanceRetry(suspenseInstance, retry);\n      return null;\n    } else {\n      // This is the first attempt.\n      reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n      var primaryChildren = nextProps.children;\n      var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n\n      primaryChildFragment.flags |= Hydrating;\n      return primaryChildFragment;\n    }\n  } else {\n    // This is the second render pass. We already attempted to hydrated, but\n    // something either suspended or errored.\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during hydration. Try again without hydrating.\n      workInProgress.flags &= ~ForceClientRender;\n\n      var _capturedValue2 = createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));\n\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue2);\n    } else if (workInProgress.memoizedState !== null) {\n      // Something suspended and we should still be in dehydrated mode.\n      // Leave the existing child in place.\n      workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n      // but the normal suspense pass doesn't.\n\n      workInProgress.flags |= DidCapture;\n      return null;\n    } else {\n      // Suspended but we should no longer be in dehydrated mode.\n      // Therefore we now have to render the fallback.\n      var nextPrimaryChildren = nextProps.children;\n      var nextFallbackChildren = nextProps.fallback;\n      var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      var _primaryChildFragment4 = workInProgress.child;\n      _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    }\n  }\n}\n\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  var node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      var state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  var row = firstChild;\n  var lastContentRow = null;\n\n  while (row !== null) {\n    var currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n\n              break;\n            }\n\n          default:\n            error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n\n            break;\n        }\n      } else {\n        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n\n        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n\n        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  {\n    var isAnArray = isArray(childSlot);\n    var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isAnArray || isIterable) {\n      var type = isAnArray ? 'array' : 'iterable';\n\n      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          var childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            var step = childrenIterator.next();\n            var _i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, _i)) {\n                return;\n              }\n\n              _i++;\n            }\n          }\n        } else {\n          error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n  var renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps;\n  var revealOrder = nextProps.revealOrder;\n  var tailMode = nextProps.tail;\n  var newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  var suspenseContext = suspenseStackCursor.current;\n  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.flags |= DidCapture;\n  } else {\n    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          var lastContentRow = findLastContentRow(workInProgress.child);\n          var tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          var _tail = null;\n          var row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            var currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            var nextRow = row.sibling;\n            row.sibling = _tail;\n            _tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          _tail, null, // last\n          tailMode);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderLanes) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nvar hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(current, workInProgress, renderLanes) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n  var newValue = newProps.value;\n\n  {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n\n        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n      }\n    }\n\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  {\n    if (oldProps !== null) {\n      var oldValue = oldProps.value;\n\n      if (objectIs(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children && !hasContextChanged()) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  var newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nvar hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderLanes) {\n  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n\n          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  var newProps = workInProgress.pendingProps;\n  var render = newProps.children;\n\n  {\n    if (typeof render !== 'function') {\n      error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var newValue = readContext(context);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  var newChildren;\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nfunction resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (current !== null) {\n      // A lazy component only mounts if it suspended inside a non-\n      // concurrent tree, in an inconsistent state. We want to treat it like\n      // a new mount, even though an empty version of it already committed.\n      // Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.flags |= Placement;\n    }\n  }\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning();\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    {\n      return null;\n    }\n  } // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  {\n    var returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      var prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      }\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    var deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  }\n}\n\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  var updateLanes = current.lanes;\n\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  } // No pending update, but because context is propagated lazily, we need\n\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      var root = workInProgress.stateNode;\n\n      resetHydrationState();\n      break;\n\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          pushContextProvider(workInProgress);\n        }\n\n        break;\n      }\n\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n\n    case ContextProvider:\n      {\n        var newValue = workInProgress.memoizedProps.value;\n        var context = workInProgress.type._context;\n        pushProvider(workInProgress, context, newValue);\n        break;\n      }\n\n    case Profiler:\n      {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          var stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n\n      break;\n\n    case SuspenseComponent:\n      {\n        var state = workInProgress.memoizedState;\n\n        if (state !== null) {\n          if (state.dehydrated !== null) {\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n            // been unsuspended it has committed as a resolved Suspense component.\n            // If it needs to be retried, it should have work scheduled on it.\n\n            workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n            // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\n            return null;\n          } // If this boundary is currently timed out, we need to decide\n          // whether to retry the primary children, or to skip over it and\n          // go straight to the fallback. Check the priority of the primary\n          // child fragment.\n\n\n          var primaryChildFragment = workInProgress.child;\n          var primaryChildLanes = primaryChildFragment.childLanes;\n\n          if (includesSomeLane(renderLanes, primaryChildLanes)) {\n            // The primary children have pending work. Use the normal path\n            // to attempt to render the primary children again.\n            return updateSuspenseComponent(current, workInProgress, renderLanes);\n          } else {\n            // The primary child fragment does not have pending work marked\n            // on it\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n            // priority. Bailout.\n\n            var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\n            if (child !== null) {\n              // The fallback children have pending work. Skip over the\n              // primary children and work on the fallback.\n              return child.sibling;\n            } else {\n              // Note: We can return `null` here because we already checked\n              // whether there were nested context consumers, via the call to\n              // `bailoutOnAlreadyFinishedWork` above.\n              return null;\n            }\n          }\n        } else {\n          pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n        }\n\n        break;\n      }\n\n    case SuspenseListComponent:\n      {\n        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n\n        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (didSuspendBefore) {\n          if (_hasChildWork) {\n            // If something was in fallback state last time, and we have all the\n            // same children then we're still in progressive loading state.\n            // Something might get unblocked by state updates or retries in the\n            // tree which will affect the tail. So we need to use the normal\n            // path to compute the correct tail.\n            return updateSuspenseListComponent(current, workInProgress, renderLanes);\n          } // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n\n\n          workInProgress.flags |= DidCapture;\n        } // If nothing suspended before and we're rendering the same children,\n        // then the tail doesn't matter. Anything new that suspends will work\n        // in the \"together\" mode, so we can continue from the state we had.\n\n\n        var renderState = workInProgress.memoizedState;\n\n        if (renderState !== null) {\n          // Reset to the \"together\" mode in case we've started a different\n          // update in the past but didn't complete it.\n          renderState.rendering = null;\n          renderState.tail = null;\n          renderState.lastEffect = null;\n        }\n\n        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n        if (_hasChildWork) {\n          break;\n        } else {\n          // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n          return null;\n        }\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        // Need to check if the tree still needs to be deferred. This is\n        // almost identical to the logic used in the normal update path,\n        // so we'll just enter that. The only difference is we'll bail out\n        // at the next level instead of this one, because the child props\n        // have not changed. Which is fine.\n        // TODO: Probably should refactor `beginWork` to split the bailout\n        // path from the normal path. I'm tempted to do a labeled break here\n        // but I won't :)\n        workInProgress.lanes = NoLanes;\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n  }\n\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(current, workInProgress, renderLanes) {\n  {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n    }\n  }\n\n  if (current !== null) {\n    var oldProps = current.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n     workInProgress.type !== current.type )) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n      // may not be work scheduled on `current`, so we check for this flag.\n      (workInProgress.flags & DidCapture) === NoFlags) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n      }\n\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      var slotIndex = workInProgress.index;\n      var numberOfForks = getForksAtLevel();\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  } // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n\n\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n      }\n\n    case LazyComponent:\n      {\n        var elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n      }\n\n    case FunctionComponent:\n      {\n        var Component = workInProgress.type;\n        var unresolvedProps = workInProgress.pendingProps;\n        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case ClassComponent:\n      {\n        var _Component = workInProgress.type;\n        var _unresolvedProps = workInProgress.pendingProps;\n\n        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n\n        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);\n      }\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n\n    case HostText:\n      return updateHostText(current, workInProgress);\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n\n    case ForwardRef:\n      {\n        var type = workInProgress.type;\n        var _unresolvedProps2 = workInProgress.pendingProps;\n\n        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n\n        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\n      }\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n\n    case MemoComponent:\n      {\n        var _type2 = workInProgress.type;\n        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n\n        {\n          if (workInProgress.type !== workInProgress.elementType) {\n            var outerPropTypes = _type2.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only\n              'prop', getComponentNameFromType(_type2));\n            }\n          }\n        }\n\n        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);\n      }\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n      }\n\n    case IncompleteClassComponent:\n      {\n        var _Component2 = workInProgress.type;\n        var _unresolvedProps4 = workInProgress.pendingProps;\n\n        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n\n        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);\n      }\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n      }\n\n    case ScopeComponent:\n      {\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n  }\n\n  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.flags |= Ref;\n\n  {\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction hadNoMutationsEffects(current, completedWork) {\n  var didBailout = current !== null && current.child === completedWork.child;\n\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n\n\n  var child = completedWork.child;\n\n  while (child !== null) {\n    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n      return false;\n    }\n\n    child = child.sibling;\n  }\n\n  return true;\n}\n\nvar appendAllChildren;\nvar updateHostContainer;\nvar updateHostComponent$1;\nvar updateHostText$1;\n\nif (supportsMutation) {\n  // Mutation mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) ; else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    var oldProps = current.memoizedProps;\n\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    } // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n\n\n    var instance = workInProgress.stateNode;\n    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n\n    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n\n    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n       if (node.tag === HostComponent) {\n        var instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var props = node.memoizedProps;\n          var type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        var _instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var text = node.memoizedProps;\n          _instance = cloneHiddenTextInstance(_instance, text, node);\n        }\n\n        appendInitialChild(parent, _instance);\n      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        var child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        appendAllChildren(parent, node, true, true);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n  var appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n       if (node.tag === HostComponent) {\n        var instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var props = node.memoizedProps;\n          var type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        var _instance2 = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var text = node.memoizedProps;\n          _instance2 = cloneHiddenTextInstance(_instance2, text, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, _instance2);\n      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        var child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        appendAllChildrenToContainer(containerChildSet, node, true, true);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged) ; else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    var currentInstance = current.stateNode;\n    var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n\n    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    var recyclableInstance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    var updatePayload = null;\n\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    workInProgress.stateNode = newInstance;\n\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {// Noop\n  };\n\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {// Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n\n  switch (renderState.tailMode) {\n    case 'hidden':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        var tailNode = renderState.tail;\n        var lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          renderState.tail = null;\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n\n    case 'collapsed':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        var _tailNode = renderState.tail;\n        var _lastTailNode = null;\n\n        while (_tailNode !== null) {\n          if (_tailNode.alternate !== null) {\n            _lastTailNode = _tailNode;\n          }\n\n          _tailNode = _tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (_lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          if (!hasRenderedATailFallback && renderState.tail !== null) {\n            // We suspended during the head. We want to show at least one\n            // row at the tail. So we'll keep on and cut off the rest.\n            renderState.tail.sibling = null;\n          } else {\n            renderState.tail = null;\n          }\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          _lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n  }\n}\n\nfunction bubbleProperties(completedWork) {\n  var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n  var newChildLanes = NoLanes;\n  var subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      var actualDuration = completedWork.actualDuration;\n      var treeBaseDuration = completedWork.selfBaseDuration;\n      var child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n\n        actualDuration += child.actualDuration;\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      var _child = completedWork.child;\n\n      while (_child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n        subtreeFlags |= _child.subtreeFlags;\n        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        _child.return = completedWork;\n        _child = _child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      var _treeBaseDuration = completedWork.selfBaseDuration;\n      var _child2 = completedWork.child;\n\n      while (_child2 !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n        subtreeFlags |= _child2.flags & StaticMask;\n        _treeBaseDuration += _child2.treeBaseDuration;\n        _child2 = _child2.sibling;\n      }\n\n      completedWork.treeBaseDuration = _treeBaseDuration;\n    } else {\n      var _child3 = completedWork.child;\n\n      while (_child3 !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        _child3.return = completedWork;\n        _child3 = _child3.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\n\nfunction completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n  if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n    warnIfUnhydratedTailNodes(workInProgress);\n    resetHydrationState();\n    workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n    return false;\n  }\n\n  var wasHydrated = popHydrationState(workInProgress);\n\n  if (nextState !== null && nextState.dehydrated !== null) {\n    // We might be inside a hydration state the first time we're picking up this\n    // Suspense boundary, and also after we've reentered it for further hydration.\n    if (current === null) {\n      if (!wasHydrated) {\n        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n      }\n\n      prepareToHydrateHostSuspenseInstance(workInProgress);\n      bubbleProperties(workInProgress);\n\n      {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          var isTimedOutSuspense = nextState !== null;\n\n          if (isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            var primaryChildFragment = workInProgress.child;\n\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n            }\n          }\n        }\n      }\n\n      return false;\n    } else {\n      // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n      // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n      resetHydrationState();\n\n      if ((workInProgress.flags & DidCapture) === NoFlags) {\n        // This boundary did not suspend so it's now hydrated and unsuspended.\n        workInProgress.memoizedState = null;\n      } // If nothing suspended, we need to schedule an effect to mark this boundary\n      // as having hydrated so events know that they're free to be invoked.\n      // It's also a signal to replay events and the suspense callback.\n      // If something suspended, schedule an effect to attach retry listeners.\n      // So we might as well always mark this.\n\n\n      workInProgress.flags |= Update;\n      bubbleProperties(workInProgress);\n\n      {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          var _isTimedOutSuspense = nextState !== null;\n\n          if (_isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            var _primaryChildFragment = workInProgress.child;\n\n            if (_primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  } else {\n    // Successfully completed this tree. If this was a forced client render,\n    // there may have been recoverable errors during first hydration\n    // attempt. If so, add them to a queue so we can log them in the\n    // commit phase.\n    upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n\n    return true;\n  }\n}\n\nfunction completeWork(current, workInProgress, renderLanes) {\n  var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostRoot:\n      {\n        var fiberRoot = workInProgress.stateNode;\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        resetWorkInProgressVersions();\n\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          var wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // If we hydrated, then we'll need to schedule an update for\n            // the commit side-effects on the root.\n            markUpdate(workInProgress);\n          } else {\n            if (current !== null) {\n              var prevState = current.memoizedState;\n\n              if ( // Check if this is a client root\n              !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n              (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                // Schedule an effect to clear this container at the start of the\n                // next commit. This handles the case of React rendering into a\n                // container with previous children. It's also safe to do for\n                // updates too, because current.child would only be null if the\n                // previous render was null (so the container would already\n                // be empty).\n                workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                // recoverable errors during first hydration attempt. If so, add\n                // them to a queue so we can log them in the commit phase.\n\n                upgradeHydrationErrorsToRecoverable();\n              }\n            }\n          }\n        }\n\n        updateHostContainer(current, workInProgress);\n        bubbleProperties(workInProgress);\n\n        return null;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef$1(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n\n            bubbleProperties(workInProgress);\n            return null;\n          }\n\n          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on whether we want to add them top->down or\n          // bottom->up. Top->down is faster in IE11.\n\n          var _wasHydrated = popHydrationState(workInProgress);\n\n          if (_wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node need to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n            appendAllChildren(instance, workInProgress, false, false);\n            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef$1(workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostText:\n      {\n        var newText = newProps;\n\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n\n          updateHostText$1(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n          }\n\n          var _rootContainerInstance = getRootHostContainer();\n\n          var _currentHostContext = getHostContext();\n\n          var _wasHydrated2 = popHydrationState(workInProgress);\n\n          if (_wasHydrated2) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n        // to its own fiber type so that we can add other kinds of hydration\n        // boundaries that aren't associated with a Suspense tree. In anticipation\n        // of such a refactor, all the hydration logic is contained in\n        // this branch.\n\n        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n          var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n\n          if (!fallthroughToNormalSuspensePath) {\n            if (workInProgress.flags & ShouldCapture) {\n              // Special case. There were remaining unhydrated nodes. We treat\n              // this as a mismatch. Revert to client rendering.\n              return workInProgress;\n            } else {\n              // Did not finish hydrating, either because this is the initial\n              // render or because something suspended.\n              return null;\n            }\n          } // Continue with the normal Suspense path.\n\n        }\n\n        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n          // Something suspended. Re-render with the fallback children.\n          workInProgress.lanes = renderLanes; // Do not reset the effect list.\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          } // Don't bubble properties in this case.\n\n\n          return workInProgress;\n        }\n\n        var nextDidTimeout = nextState !== null;\n        var prevDidTimeout = current !== null && current.memoizedState !== null;\n        // a passive effect, which is when we process the transitions\n\n\n        if (nextDidTimeout !== prevDidTimeout) {\n          // an effect to toggle the subtree's visibility. When we switch from\n          // fallback -> primary, the inner Offscreen fiber schedules this effect\n          // as part of its normal complete phase. But when we switch from\n          // primary -> fallback, the inner Offscreen fiber does not have a complete\n          // phase. So we need to schedule its effect here.\n          //\n          // We also use this flag to connect/disconnect the effects, but the same\n          // logic applies: when re-connecting, the Offscreen fiber's complete\n          // phase will handle scheduling the effect. It's only when the fallback\n          // is active that we have to do anything special.\n\n\n          if (nextDidTimeout) {\n            var _offscreenFiber2 = workInProgress.child;\n            _offscreenFiber2.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n            // in the concurrent tree already suspended during this render.\n            // This is a known bug.\n\n            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n              // TODO: Move this back to throwException because this is too late\n              // if this is a large tree which is common for initial loads. We\n              // don't know if we should restart a render or not until we get\n              // this marker, and this is too late.\n              // If this render already had a ping or lower pri updates,\n              // and this is the first time we know we're going to suspend we\n              // should be able to immediately restart from within throwException.\n              var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n\n              if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                // If this was in an invisible tree or a new render, then showing\n                // this boundary is ok.\n                renderDidSuspend();\n              } else {\n                // Otherwise, we're going to have to hide content so we should\n                // suspend for longer if possible.\n                renderDidSuspendDelayIfPossible();\n              }\n            }\n          }\n        }\n\n        var wakeables = workInProgress.updateQueue;\n\n        if (wakeables !== null) {\n          // Schedule an effect to attach a retry listener to the promise.\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        bubbleProperties(workInProgress);\n\n        {\n          if ((workInProgress.mode & ProfileMode) !== NoMode) {\n            if (nextDidTimeout) {\n              // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n              var primaryChildFragment = workInProgress.child;\n\n              if (primaryChildFragment !== null) {\n                // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ContextProvider:\n      // Pop provider fiber\n      var context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n\n    case IncompleteClassComponent:\n      {\n        // Same as class component case. I put it down here so that the tags are\n        // sequential to ensure this switch is compiled to a jump table.\n        var _Component = workInProgress.type;\n\n        if (isContextProvider(_Component)) {\n          popContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var renderState = workInProgress.memoizedState;\n\n        if (renderState === null) {\n          // We're running in the default, \"independent\" mode.\n          // We don't do anything in this mode.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n        var renderedTail = renderState.rendering;\n\n        if (renderedTail === null) {\n          // We just rendered the head.\n          if (!didSuspendAlready) {\n            // This is the first pass. We need to figure out if anything is still\n            // suspended in the rendered set.\n            // If new content unsuspended, but there's still some content that\n            // didn't. Then we need to do a second pass that forces everything\n            // to keep showing their fallbacks.\n            // We might be suspended if something in this render pass suspended, or\n            // something in the previous committed pass suspended. Otherwise,\n            // there's no chance so we can skip the expensive call to\n            // findFirstSuspended.\n            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n\n            if (!cannotBeSuspended) {\n              var row = workInProgress.child;\n\n              while (row !== null) {\n                var suspended = findFirstSuspended(row);\n\n                if (suspended !== null) {\n                  didSuspendAlready = true;\n                  workInProgress.flags |= DidCapture;\n                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                  // part of the second pass. In that case nothing will subscribe to\n                  // its thenables. Instead, we'll transfer its thenables to the\n                  // SuspenseList so that it can retry if they resolve.\n                  // There might be multiple of these in the list but since we're\n                  // going to wait for all of them anyway, it doesn't really matter\n                  // which ones gets to ping. In theory we could get clever and keep\n                  // track of how many dependencies remain but it gets tricky because\n                  // in the meantime, we can add/remove/change items and dependencies.\n                  // We might bail out of the loop before finding any but that\n                  // doesn't matter since that means that the other boundaries that\n                  // we did find already has their listeners attached.\n\n                  var newThenables = suspended.updateQueue;\n\n                  if (newThenables !== null) {\n                    workInProgress.updateQueue = newThenables;\n                    workInProgress.flags |= Update;\n                  } // Rerender the whole list, but this time, we'll force fallbacks\n                  // to stay in place.\n                  // Reset the effect flags before doing the second pass since that's now invalid.\n                  // Reset the child fibers to their original state.\n\n\n                  workInProgress.subtreeFlags = NoFlags;\n                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                  // rerender the children.\n\n                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n\n                  return workInProgress.child;\n                }\n\n                row = row.sibling;\n              }\n            }\n\n            if (renderState.tail !== null && now() > getRenderTargetTime()) {\n              // We have already passed our CPU deadline but we still have rows\n              // left in the tail. We'll just give up further attempts to render\n              // the main content and only render fallbacks.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          } else {\n            cutOffTailIfNeeded(renderState, false);\n          } // Next we're going to render the tail.\n\n        } else {\n          // Append the rendered row to the child list.\n          if (!didSuspendAlready) {\n            var _suspended = findFirstSuspended(renderedTail);\n\n            if (_suspended !== null) {\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n              // get lost if this row ends up dropped during a second pass.\n\n              var _newThenables = _suspended.updateQueue;\n\n              if (_newThenables !== null) {\n                workInProgress.updateQueue = _newThenables;\n                workInProgress.flags |= Update;\n              }\n\n              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n              ) {\n                  // We're done.\n                  bubbleProperties(workInProgress);\n                  return null;\n                }\n            } else if ( // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n              // We have now passed our CPU deadline and we'll just give up further\n              // attempts to render the main content and only render fallbacks.\n              // The assumption is that this is usually faster.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          }\n\n          if (renderState.isBackwards) {\n            // The effect list of the backwards tail will have been added\n            // to the end. This breaks the guarantee that life-cycles fire in\n            // sibling order but that isn't a strong guarantee promised by React.\n            // Especially since these might also just pop in during future commits.\n            // Append to the beginning of the list.\n            renderedTail.sibling = workInProgress.child;\n            workInProgress.child = renderedTail;\n          } else {\n            var previousSibling = renderState.last;\n\n            if (previousSibling !== null) {\n              previousSibling.sibling = renderedTail;\n            } else {\n              workInProgress.child = renderedTail;\n            }\n\n            renderState.last = renderedTail;\n          }\n        }\n\n        if (renderState.tail !== null) {\n          // We still have tail rows to render.\n          // Pop a row.\n          var next = renderState.tail;\n          renderState.rendering = next;\n          renderState.tail = next.sibling;\n          renderState.renderingStartTime = now();\n          next.sibling = null; // Restore the context.\n          // TODO: We can probably just avoid popping it instead and only\n          // setting it the first time we go from not suspended to suspended.\n\n          var suspenseContext = suspenseStackCursor.current;\n\n          if (didSuspendAlready) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          } else {\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n\n          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n          // Don't bubble properties in this case.\n\n          return next;\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case ScopeComponent:\n      {\n\n        break;\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        popRenderLanes(workInProgress);\n        var _nextState = workInProgress.memoizedState;\n        var nextIsHidden = _nextState !== null;\n\n        if (current !== null) {\n          var _prevState = current.memoizedState;\n          var prevIsHidden = _prevState !== null;\n\n          if (prevIsHidden !== nextIsHidden && ( // LegacyHidden doesn't do any hiding \u2014 it only pre-renders.\n          !enableLegacyHidden )) {\n            workInProgress.flags |= Visibility;\n          }\n        }\n\n        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n          bubbleProperties(workInProgress);\n        } else {\n          // Don't bubble properties for hidden children unless we're rendering\n          // at offscreen priority.\n          if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n            bubbleProperties(workInProgress);\n\n            if (supportsMutation) {\n              // Check if there was an insertion or update in the hidden subtree.\n              // If so, we need to hide those nodes in the commit phase, so\n              // schedule a visibility effect.\n              if ( workInProgress.subtreeFlags & (Placement | Update)) {\n                workInProgress.flags |= Visibility;\n              }\n            }\n          }\n        }\n        return null;\n      }\n\n    case CacheComponent:\n      {\n\n        return null;\n      }\n\n    case TracingMarkerComponent:\n      {\n\n        return null;\n      }\n  }\n\n  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n}\n\nfunction unwindWork(current, workInProgress, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n\n        var flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case HostRoot:\n      {\n        var root = workInProgress.stateNode;\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        resetWorkInProgressVersions();\n        var _flags = workInProgress.flags;\n\n        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n          // There was an error during render that wasn't captured by a suspense\n          // boundary. Do a second pass on the root to unmount the children.\n          workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        } // We unwound to the root without completing it. Exit.\n\n\n        return null;\n      }\n\n    case HostComponent:\n      {\n        // TODO: popHydrationState\n        popHostContext(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var suspenseState = workInProgress.memoizedState;\n\n        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n          if (workInProgress.alternate === null) {\n            throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n          }\n\n          resetHydrationState();\n        }\n\n        var _flags2 = workInProgress.flags;\n\n        if (_flags2 & ShouldCapture) {\n          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n        // caught by a nested boundary. If not, it should bubble through.\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n\n    case ContextProvider:\n      var context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      return null;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(workInProgress);\n      return null;\n\n    case CacheComponent:\n\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(current, interruptedWork, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(interruptedWork);\n\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        var childContextTypes = interruptedWork.type.childContextTypes;\n\n        if (childContextTypes !== null && childContextTypes !== undefined) {\n          popContext(interruptedWork);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        var root = interruptedWork.stateNode;\n        popHostContainer(interruptedWork);\n        popTopLevelContextObject(interruptedWork);\n        resetWorkInProgressVersions();\n        break;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n\n    case SuspenseComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case SuspenseListComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case ContextProvider:\n      var context = interruptedWork.type._context;\n      popProvider(context, interruptedWork);\n      break;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(interruptedWork);\n      break;\n  }\n}\n\nfunction invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n}\n\nvar invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebook/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      if (typeof document === 'undefined' || document === null) {\n        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');\n      }\n\n      var evt = document.createEvent('Event');\n      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n\n      var didError = true; // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n\n      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event\n      // dispatching: https://github.com/facebook/react/issues/13688\n\n      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');\n\n      function restoreAfterDispatch() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n\n        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\n          window.event = windowEvent;\n        }\n      } // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n\n\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      function callCallback() {\n        didCall = true;\n        restoreAfterDispatch();\n        func.apply(context, funcArgs);\n        didError = false;\n      } // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n\n\n      var error; // Use this to track whether the error event is ever called.\n\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === 'object') {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {// Ignore.\n            }\n          }\n        }\n      } // Create a fake event type.\n\n\n      var evtType = \"react-\" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n      window.addEventListener('error', handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (windowEventDescriptor) {\n        Object.defineProperty(window, 'event', windowEventDescriptor);\n      }\n\n      if (didCall && didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');\n        }\n\n        this.onError(error);\n      } // Remove our event listeners\n\n\n      window.removeEventListener('error', handleWindowError);\n\n      if (!didCall) {\n        // Something went really wrong, and our event was not dispatched.\n        // https://github.com/facebook/react/issues/16734\n        // https://github.com/facebook/react/issues/16585\n        // Fall back to the production implementation.\n        restoreAfterDispatch();\n        return invokeGuardedCallbackProd.apply(this, arguments);\n      }\n    };\n  }\n}\n\nvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\nvar hasError = false;\nvar caughtError = null; // Used by event system to capture/rethrow the first error.\nvar reporter = {\n  onError: function (error) {\n    hasError = true;\n    caughtError = error;\n  }\n};\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\nfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n}\nfunction hasCaughtError() {\n  return hasError;\n}\nfunction clearCaughtError() {\n  if (hasError) {\n    var error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n} // Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\n\n\nvar offscreenSubtreeIsHidden = false;\nvar offscreenSubtreeWasHidden = false;\nvar PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nvar nextEffect = null; // Used for Profiling builds to track updaters.\n\nvar inProgressLanes = null;\nvar inProgressRoot = null;\nfunction reportUncaughtErrorInDEV(error) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  {\n    invokeGuardedCallback(null, function () {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function (current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n\n  if ( current.mode & ProfileMode) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n}; // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n  try {\n    commitHookEffectListMount(Layout, current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n  try {\n    instance.componentDidMount();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  var ref = current.ref;\n\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      var retVal;\n\n      try {\n        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n\n      {\n        if (typeof retVal === 'function') {\n          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n  try {\n    destroy();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nvar focusedInstanceHandle = null;\nvar shouldFireAfterActiveInstanceBlur = false;\nfunction commitBeforeMutationEffects(root, firstChild) {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n\n  var shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n\n    var child = fiber.child;\n\n    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    setCurrentFiber(fiber);\n\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentFiber();\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork) {\n  var current = finishedWork.alternate;\n  var flags = finishedWork.flags;\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentFiber(finishedWork);\n\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          break;\n        }\n\n      case ClassComponent:\n        {\n          if (current !== null) {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            var instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            }\n\n            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            {\n              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n\n                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n              }\n            }\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          if (supportsMutation) {\n            var root = finishedWork.stateNode;\n            clearContainer(root.containerInfo);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        // Nothing to do for these component types\n        break;\n\n      default:\n        {\n          throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n        }\n    }\n\n    resetCurrentFiber();\n  }\n}\n\nfunction commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n  var updateQueue = finishedWork.updateQueue;\n  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    var firstEffect = lastEffect.next;\n    var effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        var destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          {\n            if ((flags & Passive$1) !== NoFlags$1) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & Layout) !== NoFlags$1) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          {\n            if ((flags & Insertion) !== NoFlags$1) {\n              setIsRunningInsertionEffect(true);\n            }\n          }\n\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n          {\n            if ((flags & Insertion) !== NoFlags$1) {\n              setIsRunningInsertionEffect(false);\n            }\n          }\n\n          {\n            if ((flags & Passive$1) !== NoFlags$1) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & Layout) !== NoFlags$1) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags, finishedWork) {\n  var updateQueue = finishedWork.updateQueue;\n  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    var firstEffect = lastEffect.next;\n    var effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        {\n          if ((flags & Passive$1) !== NoFlags$1) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & Layout) !== NoFlags$1) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        } // Mount\n\n\n        var create = effect.create;\n\n        {\n          if ((flags & Insertion) !== NoFlags$1) {\n            setIsRunningInsertionEffect(true);\n          }\n        }\n\n        effect.destroy = create();\n\n        {\n          if ((flags & Insertion) !== NoFlags$1) {\n            setIsRunningInsertionEffect(false);\n          }\n        }\n\n        {\n          if ((flags & Passive$1) !== NoFlags$1) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & Layout) !== NoFlags$1) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        {\n          var destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            var hookName = void 0;\n\n            if ((effect.tag & Layout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & Insertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n\n            var addendum = void 0;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitPassiveEffectDurations(finishedRoot, finishedWork) {\n  {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler:\n          {\n            var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n            var _finishedWork$memoize = finishedWork.memoizedProps,\n                id = _finishedWork$memoize.id,\n                onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n            // It does not get reset until the start of the next commit phase.\n\n            var commitTime = getCommitTime();\n            var phase = finishedWork.alternate === null ? 'mount' : 'update';\n\n            {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onPostCommit === 'function') {\n              onPostCommit(id, phase, passiveEffectDuration, commitTime);\n            } // Bubble times to the next nearest ancestor Profiler.\n            // After we process that Profiler, we'll bubble further up.\n\n\n            var parentFiber = finishedWork.return;\n\n            outer: while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  var root = parentFiber.stateNode;\n                  root.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n\n                case Profiler:\n                  var parentStateNode = parentFiber.stateNode;\n                  parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n              }\n\n              parentFiber = parentFiber.return;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          if ( !offscreenSubtreeWasHidden) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if ( finishedWork.mode & ProfileMode) {\n              try {\n                startLayoutEffectTimer();\n                commitHookEffectListMount(Layout | HasEffect, finishedWork);\n              } finally {\n                recordLayoutEffectDuration(finishedWork);\n              }\n            } else {\n              commitHookEffectListMount(Layout | HasEffect, finishedWork);\n            }\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n\n          if (finishedWork.flags & Update) {\n            if (!offscreenSubtreeWasHidden) {\n              if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if ( finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidMount();\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidMount();\n                }\n              } else {\n                var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                var prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if ( finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                }\n              }\n            }\n          } // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n\n\n          var updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            } // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n\n            commitUpdateQueue(finishedWork, updateQueue, instance);\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n          var _updateQueue = finishedWork.updateQueue;\n\n          if (_updateQueue !== null) {\n            var _instance = null;\n\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostComponent:\n                  _instance = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n\n                case ClassComponent:\n                  _instance = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n\n            commitUpdateQueue(finishedWork, _updateQueue, _instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n\n          if (current === null && finishedWork.flags & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          break;\n        }\n\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          break;\n        }\n\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          break;\n        }\n\n      case Profiler:\n        {\n          {\n            var _finishedWork$memoize2 = finishedWork.memoizedProps,\n                onCommit = _finishedWork$memoize2.onCommit,\n                onRender = _finishedWork$memoize2.onRender;\n            var effectDuration = finishedWork.stateNode.effectDuration;\n            var commitTime = getCommitTime();\n            var phase = current === null ? 'mount' : 'update';\n\n            {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onRender === 'function') {\n              onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n            }\n\n            {\n              if (typeof onCommit === 'function') {\n                onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n              } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n              // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n              // because the effect is also where times bubble to parent Profilers.\n\n\n              enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n              // Do not reset these values until the next render so DevTools has a chance to read them first.\n\n              var parentFiber = finishedWork.return;\n\n              outer: while (parentFiber !== null) {\n                switch (parentFiber.tag) {\n                  case HostRoot:\n                    var root = parentFiber.stateNode;\n                    root.effectDuration += effectDuration;\n                    break outer;\n\n                  case Profiler:\n                    var parentStateNode = parentFiber.stateNode;\n                    parentStateNode.effectDuration += effectDuration;\n                    break outer;\n                }\n\n                parentFiber = parentFiber.return;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n          break;\n        }\n\n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n      case TracingMarkerComponent:\n        {\n          break;\n        }\n\n      default:\n        throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  if ( !offscreenSubtreeWasHidden) {\n    {\n      if (finishedWork.flags & Ref) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n}\n\nfunction reappearLayoutEffectsOnFiber(node) {\n  // Turn on layout effects in a tree that previously disappeared.\n  // TODO (Offscreen) Check: flags & LayoutStatic\n  switch (node.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( node.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n          } finally {\n            recordLayoutEffectDuration(node);\n          }\n        } else {\n          safelyCallCommitHookLayoutEffectListMount(node, node.return);\n        }\n\n        break;\n      }\n\n    case ClassComponent:\n      {\n        var instance = node.stateNode;\n\n        if (typeof instance.componentDidMount === 'function') {\n          safelyCallComponentDidMount(node, node.return, instance);\n        }\n\n        safelyAttachRef(node, node.return);\n        break;\n      }\n\n    case HostComponent:\n      {\n        safelyAttachRef(node, node.return);\n        break;\n      }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  var hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n\n          try {\n            var instance = node.stateNode;\n\n            if (isHidden) {\n              hideInstance(instance);\n            } else {\n              unhideInstance(node.stateNode, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          try {\n            var _instance3 = node.stateNode;\n\n            if (isHidden) {\n              hideTextInstance(_instance3);\n            } else {\n              unhideTextInstance(_instance3, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n    if (typeof ref === 'function') {\n      var retVal;\n\n      if ( finishedWork.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          retVal = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        retVal = ref(instanceToUse);\n      }\n\n      {\n        if (typeof retVal === 'function') {\n          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));\n        }\n      }\n    } else {\n      {\n        if (!ref.hasOwnProperty('current')) {\n          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction detachFiberMutation(fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber) {\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  } // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n\n\n  {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n\n    if (fiber.tag === HostComponent) {\n      var hostInstance = fiber.stateNode;\n\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n\n    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical \u2014 it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    {\n      fiber._debugOwner = null;\n    }\n\n    {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current.stateNode;\n  var containerInfo = portal.containerInfo;\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n\n    parent = parent.return;\n  }\n\n  throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  var node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  } // Recursively insert all host nodes into the parent.\n\n\n  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      {\n        var parent = parentFiber.stateNode;\n\n        if (parentFiber.flags & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.flags &= ~ContentReset;\n        }\n\n        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n        // children to find all the terminal nodes.\n\n        insertOrAppendPlacementNode(finishedWork, before, parent);\n        break;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        var _parent = parentFiber.stateNode.containerInfo;\n\n        var _before = getHostSibling(finishedWork);\n\n        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n        break;\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  var tag = node.tag;\n  var isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    var stateNode = node.stateNode;\n\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) ; else {\n    var child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      var sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  var tag = node.tag;\n  var isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    var stateNode = node.stateNode;\n\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) ; else {\n    var child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      var sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n} // These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\n\n\nvar hostParent = null;\nvar hostParentIsContainer = false;\n\nfunction commitDeletionEffects(root, returnFiber, deletedFiber) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was deleted but we need to recurse down its\n    // children to find all the terminal nodes.\n    // Recursively delete all host nodes from the parent, detach refs, clean\n    // up mounted layout effects, and call componentWillUnmount.\n    // We only need to remove the topmost host child in each branch. But then we\n    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n    // could split this into two separate traversals functions, where the second\n    // one doesn't include any removeChild logic. This is maybe the same\n    // function as \"disappearLayoutEffects\" (or whatever that turns into after\n    // the layout phase is refactored to use recursion).\n    // Before starting, find the nearest host parent on the stack so we know\n    // which instance/container to remove the children from.\n    // TODO: Instead of searching up the fiber return path on every deletion, we\n    // can track the nearest host component on the JS stack as we traverse the\n    // tree during the commit phase. This would make insertions faster, too.\n    var parent = returnFiber;\n\n    findParent: while (parent !== null) {\n      switch (parent.tag) {\n        case HostComponent:\n          {\n            hostParent = parent.stateNode;\n            hostParentIsContainer = false;\n            break findParent;\n          }\n\n        case HostRoot:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n\n        case HostPortal:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n      }\n\n      parent = parent.return;\n    }\n\n    if (hostParent === null) {\n      throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n    }\n\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n    hostParent = null;\n    hostParentIsContainer = false;\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n  }\n\n  detachFiberMutation(deletedFiber);\n}\n\nfunction recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n  // TODO: Use a static flag to skip trees that don't have unmount effects\n  var child = parent.child;\n\n  while (child !== null) {\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n    child = child.sibling;\n  }\n}\n\nfunction commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n  onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n  // into their subtree. There are simpler cases in the inner switch\n  // that don't modify the stack.\n\n  switch (deletedFiber.tag) {\n    case HostComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        } // Intentional fallthrough to next branch\n\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostText:\n      {\n        // We only need to remove the nearest host child. Set the host parent\n        // to `null` on the stack to indicate that nested children don't\n        // need to be removed.\n        if (supportsMutation) {\n          var prevHostParent = hostParent;\n          var prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = prevHostParent;\n          hostParentIsContainer = prevHostParentIsContainer;\n\n          if (hostParent !== null) {\n            // Now that all the child effects have unmounted, we can remove the\n            // node from the tree.\n            if (hostParentIsContainer) {\n              removeChildFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              removeChild(hostParent, deletedFiber.stateNode);\n            }\n          }\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n        // Delete the dehydrated suspense boundary and all of its content.\n\n\n        if (supportsMutation) {\n          if (hostParent !== null) {\n            if (hostParentIsContainer) {\n              clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        if (supportsMutation) {\n          // When we go into a portal, it becomes the parent to remove from.\n          var _prevHostParent = hostParent;\n          var _prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = deletedFiber.stateNode.containerInfo;\n          hostParentIsContainer = true;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = _prevHostParent;\n          hostParentIsContainer = _prevHostParentIsContainer;\n        } else {\n          emptyPortalContainer(deletedFiber);\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          var updateQueue = deletedFiber.updateQueue;\n\n          if (updateQueue !== null) {\n            var lastEffect = updateQueue.lastEffect;\n\n            if (lastEffect !== null) {\n              var firstEffect = lastEffect.next;\n              var effect = firstEffect;\n\n              do {\n                var _effect = effect,\n                    destroy = _effect.destroy,\n                    tag = _effect.tag;\n\n                if (destroy !== undefined) {\n                  if ((tag & Insertion) !== NoFlags$1) {\n                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                  } else if ((tag & Layout) !== NoFlags$1) {\n                    {\n                      markComponentLayoutEffectUnmountStarted(deletedFiber);\n                    }\n\n                    if ( deletedFiber.mode & ProfileMode) {\n                      startLayoutEffectTimer();\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                      recordLayoutEffectDuration(deletedFiber);\n                    } else {\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                    }\n\n                    {\n                      markComponentLayoutEffectUnmountStopped();\n                    }\n                  }\n                }\n\n                effect = effect.next;\n              } while (effect !== firstEffect);\n            }\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ClassComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n          var instance = deletedFiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ScopeComponent:\n      {\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        if ( // TODO: Remove this dead flag\n         deletedFiber.mode & ConcurrentMode) {\n          // If this offscreen component is hidden, we already unmounted it. Before\n          // deleting the children, track that it's already unmounted so that we\n          // don't attempt to unmount the effects again.\n          // TODO: If the tree is hidden, in most cases we should be able to skip\n          // over the nested children entirely. An exception is we haven't yet found\n          // the topmost host node to delete, which we already track on the stack.\n          // But the other case is portals, which need to be detached no matter how\n          // deeply they are nested. We should use a subtree flag to track whether a\n          // subtree includes a nested portal.\n          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n  }\n}\n\nfunction commitSuspenseCallback(finishedWork) {\n  // TODO: Move this to passive phase\n  var newState = finishedWork.memoizedState;\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (!supportsHydration) {\n    return;\n  }\n\n  var newState = finishedWork.memoizedState;\n\n  if (newState === null) {\n    var current = finishedWork.alternate;\n\n    if (current !== null) {\n      var prevState = current.memoizedState;\n\n      if (prevState !== null) {\n        var suspenseInstance = prevState.dehydrated;\n\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  var wakeables = finishedWork.updateQueue;\n\n  if (wakeables !== null) {\n    finishedWork.updateQueue = null;\n    var retryCache = finishedWork.stateNode;\n\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n\n    wakeables.forEach(function (wakeable) {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n\n      if (!retryCache.has(wakeable)) {\n        retryCache.add(wakeable);\n\n        {\n          if (isDevToolsPresent) {\n            if (inProgressLanes !== null && inProgressRoot !== null) {\n              // If we have pending work still, associate the original updaters with it.\n              restorePendingUpdaters(inProgressRoot, inProgressLanes);\n            } else {\n              throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n            }\n          }\n        }\n\n        wakeable.then(retry, retry);\n      }\n    });\n  }\n} // This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root, finishedWork, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  setCurrentFiber(finishedWork);\n  commitMutationEffectsOnFiber(finishedWork, root);\n  setCurrentFiber(finishedWork);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects hae fired.\n  var deletions = parentFiber.deletions;\n\n  if (deletions !== null) {\n    for (var i = 0; i < deletions.length; i++) {\n      var childToDelete = deletions[i];\n\n      try {\n        commitDeletionEffects(root, parentFiber, childToDelete);\n      } catch (error) {\n        captureCommitPhaseError(childToDelete, parentFiber, error);\n      }\n    }\n  }\n\n  var prevDebugFiber = getCurrentFiber();\n\n  if (parentFiber.subtreeFlags & MutationMask) {\n    var child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentFiber(child);\n      commitMutationEffectsOnFiber(child, root);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentFiber(prevDebugFiber);\n}\n\nfunction commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n  var current = finishedWork.alternate;\n  var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n  // because the fiber tag is more specific. An exception is any flag related\n  // to reconcilation, because those can be set on all fiber types.\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          try {\n            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n            commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          } // Layout effects are destroyed during the mutation phase so that all\n          // destroy functions for all fibers are called before any create functions.\n          // This prevents sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n\n\n          if ( finishedWork.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n\n            recordLayoutEffectDuration(finishedWork);\n          } else {\n            try {\n              commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        if (supportsMutation) {\n          // TODO: ContentReset gets cleared by the children during the commit\n          // phase. This is a refactor hazard because it means we must read\n          // flags the flags after `commitReconciliationEffects` has already run;\n          // the order matters. We should refactor so that ContentReset does not\n          // rely on mutating the flag during commit. Like by setting a flag\n          // during the render phase instead.\n          if (finishedWork.flags & ContentReset) {\n            var instance = finishedWork.stateNode;\n\n            try {\n              resetTextContent(instance);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n\n          if (flags & Update) {\n            var _instance4 = finishedWork.stateNode;\n\n            if (_instance4 != null) {\n              // Commit the work prepared earlier.\n              var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              var oldProps = current !== null ? current.memoizedProps : newProps;\n              var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n              var updatePayload = finishedWork.updateQueue;\n              finishedWork.updateQueue = null;\n\n              if (updatePayload !== null) {\n                try {\n                  commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation) {\n            if (finishedWork.stateNode === null) {\n              throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            }\n\n            var textInstance = finishedWork.stateNode;\n            var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n\n            var oldText = current !== null ? current.memoizedProps : newText;\n\n            try {\n              commitTextUpdate(textInstance, oldText, newText);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostRoot:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation && supportsHydration) {\n            if (current !== null) {\n              var prevRootState = current.memoizedState;\n\n              if (prevRootState.isDehydrated) {\n                try {\n                  commitHydratedContainer(root.containerInfo);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n\n          if (supportsPersistence) {\n            var containerInfo = root.containerInfo;\n            var pendingChildren = root.pendingChildren;\n\n            try {\n              replaceContainerChildren(containerInfo, pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsPersistence) {\n            var portal = finishedWork.stateNode;\n            var _containerInfo = portal.containerInfo;\n            var _pendingChildren = portal.pendingChildren;\n\n            try {\n              replaceContainerChildren(_containerInfo, _pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n        var offscreenFiber = finishedWork.child;\n\n        if (offscreenFiber.flags & Visibility) {\n          var offscreenInstance = offscreenFiber.stateNode;\n          var newState = offscreenFiber.memoizedState;\n          var isHidden = newState !== null; // Track the current state on the Offscreen instance so we can\n          // read it during an event\n\n          offscreenInstance.isHidden = isHidden;\n\n          if (isHidden) {\n            var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n\n            if (!wasHidden) {\n              // TODO: Move to passive phase\n              markCommitTimeOfFallback();\n            }\n          }\n        }\n\n        if (flags & Update) {\n          try {\n            commitSuspenseCallback(finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n\n          attachSuspenseRetryListeners(finishedWork);\n        }\n\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        var _wasHidden = current !== null && current.memoizedState !== null;\n\n        if ( // TODO: Remove this dead flag\n         finishedWork.mode & ConcurrentMode) {\n          // Before committing the children, track on the stack whether this\n          // offscreen subtree was already hidden, so that we don't unmount the\n          // effects again.\n          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;\n          recursivelyTraverseMutationEffects(root, finishedWork);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        } else {\n          recursivelyTraverseMutationEffects(root, finishedWork);\n        }\n\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Visibility) {\n          var _offscreenInstance = finishedWork.stateNode;\n          var _newState = finishedWork.memoizedState;\n\n          var _isHidden = _newState !== null;\n\n          var offscreenBoundary = finishedWork; // Track the current state on the Offscreen instance so we can\n          // read it during an event\n\n          _offscreenInstance.isHidden = _isHidden;\n\n          {\n            if (_isHidden) {\n              if (!_wasHidden) {\n                if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                  nextEffect = offscreenBoundary;\n                  var offscreenChild = offscreenBoundary.child;\n\n                  while (offscreenChild !== null) {\n                    nextEffect = offscreenChild;\n                    disappearLayoutEffects_begin(offscreenChild);\n                    offscreenChild = offscreenChild.sibling;\n                  }\n                }\n              }\n            }\n          }\n\n          if (supportsMutation) {\n            // TODO: This needs to run whenever there's an insertion or update\n            // inside a hidden Offscreen tree.\n            hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          attachSuspenseRetryListeners(finishedWork);\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n\n        return;\n      }\n\n    default:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork);\n        commitReconciliationEffects(finishedWork);\n        return;\n      }\n  }\n}\n\nfunction commitReconciliationEffects(finishedWork) {\n  // Placement effects (insertions, reorders) can be scheduled on any fiber\n  // type. They needs to happen after the children effects have fired, but\n  // before the effects on this fiber have fired.\n  var flags = finishedWork.flags;\n\n  if (flags & Placement) {\n    try {\n      commitPlacement(finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    } // Clear the \"placement\" from effect tag so that we know that this is\n    // inserted, before any life-cycles like componentDidMount gets called.\n    // TODO: findDOMNode doesn't rely on this any more but isMounted does\n    // and isMounted is deprecated anyway so we should be able to kill this.\n\n\n    finishedWork.flags &= ~Placement;\n  }\n\n  if (flags & Hydrating) {\n    finishedWork.flags &= ~Hydrating;\n  }\n}\n\nfunction commitLayoutEffects(finishedWork, root, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = finishedWork;\n  commitLayoutEffects_begin(finishedWork, root, committedLanes);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n  // Suspense layout effects semantics don't change for legacy roots.\n  var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if ( fiber.tag === OffscreenComponent && isModernRoot) {\n      // Keep track of the current Offscreen stack's state.\n      var isHidden = fiber.memoizedState !== null;\n      var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n\n      if (newOffscreenSubtreeIsHidden) {\n        // The Offscreen tree is hidden. Skip over its layout effects.\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      } else {\n        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n        var current = fiber.alternate;\n        var wasHidden = current !== null && current.memoizedState !== null;\n        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n\n        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n          // This is the root of a reappearing boundary. Turn its layout effects\n          // back on.\n          nextEffect = fiber;\n          reappearLayoutEffects_begin(fiber);\n        }\n\n        var child = firstChild;\n\n        while (child !== null) {\n          nextEffect = child;\n          commitLayoutEffects_begin(child, // New root; bubble back up to here and stop.\n          root, committedLanes);\n          child = child.sibling;\n        } // Restore Offscreen state and resume in our-progress traversal.\n\n\n        nextEffect = fiber;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      }\n    }\n\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n    }\n  }\n}\n\nfunction commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & LayoutMask) !== NoFlags) {\n      var current = fiber.alternate;\n      setCurrentFiber(fiber);\n\n      try {\n        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n      } catch (error) {\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentFiber();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction disappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ( fiber.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(Layout, fiber, fiber.return);\n            } finally {\n              recordLayoutEffectDuration(fiber);\n            }\n          } else {\n            commitHookEffectListUnmount(Layout, fiber, fiber.return);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          // TODO (Offscreen) Check: flags & RefStatic\n          safelyDetachRef(fiber, fiber.return);\n          var instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          safelyDetachRef(fiber, fiber.return);\n          break;\n        }\n\n      case OffscreenComponent:\n        {\n          // Check if this is a\n          var isHidden = fiber.memoizedState !== null;\n\n          if (isHidden) {\n            // Nested Offscreen tree is already hidden. Don't disappear\n            // its effects.\n            disappearLayoutEffects_complete(subtreeRoot);\n            continue;\n          }\n\n          break;\n        }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      disappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction disappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction reappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if (fiber.tag === OffscreenComponent) {\n      var isHidden = fiber.memoizedState !== null;\n\n      if (isHidden) {\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n        reappearLayoutEffects_complete(subtreeRoot);\n        continue;\n      }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      reappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction reappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n\n    setCurrentFiber(fiber);\n\n    try {\n      reappearLayoutEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentFiber();\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n  nextEffect = finishedWork;\n  commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);\n}\n\nfunction commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);\n    }\n  }\n}\n\nfunction commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentFiber(fiber);\n\n      try {\n        commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);\n      } catch (error) {\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentFiber();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n\n          try {\n            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n          } finally {\n            recordPassiveEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffects(firstChild) {\n  nextEffect = firstChild;\n  commitPassiveUnmountEffects_begin();\n}\n\nfunction commitPassiveUnmountEffects_begin() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var child = fiber.child;\n\n    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n      var deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (var i = 0; i < deletions.length; i++) {\n          var fiberToDelete = deletions[i];\n          nextEffect = fiberToDelete;\n          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n        }\n\n        {\n          // A fiber was deleted from this parent fiber, but it's still part of\n          // the previous (alternate) parent fiber's list of children. Because\n          // children are a linked list, an earlier sibling that's still alive\n          // will be connected to the deleted fiber via its `alternate`:\n          //\n          //   live fiber\n          //   --alternate--> previous live fiber\n          //   --sibling--> deleted fiber\n          //\n          // We can't disconnect `alternate` on nodes that haven't been deleted\n          // yet, but we can disconnect the `sibling` and `child` pointers.\n          var previousFiber = fiber.alternate;\n\n          if (previousFiber !== null) {\n            var detachedChild = previousFiber.child;\n\n            if (detachedChild !== null) {\n              previousFiber.child = null;\n\n              do {\n                var detachedSibling = detachedChild.sibling;\n                detachedChild.sibling = null;\n                detachedChild = detachedSibling;\n              } while (detachedChild !== null);\n            }\n          }\n        }\n\n        nextEffect = fiber;\n      }\n    }\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffects_complete();\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffects_complete() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentFiber(fiber);\n      commitPassiveUnmountOnFiber(fiber);\n      resetCurrentFiber();\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n          recordPassiveEffectDuration(finishedWork);\n        } else {\n          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n\n    setCurrentFiber(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentFiber();\n    var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\n    if (child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var sibling = fiber.sibling;\n    var returnFiber = fiber.return;\n\n    {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      sibling.return = returnFiber;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( current.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n          recordPassiveEffectDuration(current);\n        } else {\n          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n        }\n\n        break;\n      }\n  }\n} // TODO: Reuse reappearLayoutEffects traversal here?\n\n\nfunction invokeLayoutEffectMountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(Layout | HasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = fiber.stateNode;\n\n          try {\n            instance.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n        }\n    }\n  }\n}\n\nvar COMPONENT_TYPE = 0;\nvar HAS_PSEUDO_CLASS_TYPE = 1;\nvar ROLE_TYPE = 2;\nvar TEST_NAME_TYPE = 3;\nvar TEXT_TYPE = 4;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  COMPONENT_TYPE = symbolFor('selector.component');\n  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n  ROLE_TYPE = symbolFor('selector.role');\n  TEST_NAME_TYPE = symbolFor('selector.test_id');\n  TEXT_TYPE = symbolFor('selector.text');\n}\n\nfunction createComponentSelector(component) {\n  return {\n    $$typeof: COMPONENT_TYPE,\n    value: component\n  };\n}\nfunction createHasPseudoClassSelector(selectors) {\n  return {\n    $$typeof: HAS_PSEUDO_CLASS_TYPE,\n    value: selectors\n  };\n}\nfunction createRoleSelector(role) {\n  return {\n    $$typeof: ROLE_TYPE,\n    value: role\n  };\n}\nfunction createTextSelector(text) {\n  return {\n    $$typeof: TEXT_TYPE,\n    value: text\n  };\n}\nfunction createTestNameSelector(id) {\n  return {\n    $$typeof: TEST_NAME_TYPE,\n    value: id\n  };\n}\n\nfunction findFiberRootForHostRoot(hostRoot) {\n  var maybeFiber = getInstanceFromNode(hostRoot);\n\n  if (maybeFiber != null) {\n    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n      throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n    }\n\n    return maybeFiber;\n  } else {\n    var fiberRoot = findFiberRoot(hostRoot);\n\n    if (fiberRoot === null) {\n      throw new Error('Could not find React container within specified host subtree.');\n    } // The Flow type for FiberRoot is a little funky.\n    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n\n\n    return fiberRoot.stateNode.current;\n  }\n}\n\nfunction matchSelector(fiber, selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      if (fiber.type === selector.value) {\n        return true;\n      }\n\n      break;\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return hasMatchingPaths(fiber, selector.value);\n\n    case ROLE_TYPE:\n      if (fiber.tag === HostComponent) {\n        var node = fiber.stateNode;\n\n        if (matchAccessibilityRole(node, selector.value)) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEXT_TYPE:\n      if (fiber.tag === HostComponent || fiber.tag === HostText) {\n        var textContent = getTextContent(fiber);\n\n        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEST_NAME_TYPE:\n      if (fiber.tag === HostComponent) {\n        var dataTestID = fiber.memoizedProps['data-testname'];\n\n        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n          return true;\n        }\n      }\n\n      break;\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n\n  return false;\n}\n\nfunction selectorToString(selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n      return \"<\" + displayName + \">\";\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return \":has(\" + (selectorToString(selector) || '') + \")\";\n\n    case ROLE_TYPE:\n      return \"[role=\\\"\" + selector.value + \"\\\"]\";\n\n    case TEXT_TYPE:\n      return \"\\\"\" + selector.value + \"\\\"\";\n\n    case TEST_NAME_TYPE:\n      return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n}\n\nfunction findPaths(root, selectors) {\n  var matchingFibers = [];\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      matchingFibers.push(fiber);\n    } else {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return matchingFibers;\n} // Same as findPaths but with eager bailout on first match\n\n\nfunction hasMatchingPaths(root, selectors) {\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      return true;\n    } else {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction findAllNodes(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var matchingFibers = findPaths(root, selectors);\n  var instanceRoots = [];\n  var stack = Array.from(matchingFibers);\n  var index = 0;\n\n  while (index < stack.length) {\n    var node = stack[index++];\n\n    if (node.tag === HostComponent) {\n      if (isHiddenSubtree(node)) {\n        continue;\n      }\n\n      instanceRoots.push(node.stateNode);\n    } else {\n      var child = node.child;\n\n      while (child !== null) {\n        stack.push(child);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return instanceRoots;\n}\nfunction getFindAllNodesFailureDescription(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var maxSelectorIndex = 0;\n  var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else if (matchSelector(fiber, selector)) {\n      matchedNames.push(selectorToString(selector));\n      selectorIndex++;\n\n      if (selectorIndex > maxSelectorIndex) {\n        maxSelectorIndex = selectorIndex;\n      }\n    }\n\n    if (selectorIndex < selectors.length) {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  if (maxSelectorIndex < selectors.length) {\n    var unmatchedNames = [];\n\n    for (var i = maxSelectorIndex; i < selectors.length; i++) {\n      unmatchedNames.push(selectorToString(selectors[i]));\n    }\n\n    return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n  }\n\n  return null;\n}\nfunction findBoundingRects(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var instanceRoots = findAllNodes(hostRoot, selectors);\n  var boundingRects = [];\n\n  for (var i = 0; i < instanceRoots.length; i++) {\n    boundingRects.push(getBoundingRect(instanceRoots[i]));\n  }\n\n  for (var _i = boundingRects.length - 1; _i > 0; _i--) {\n    var targetRect = boundingRects[_i];\n    var targetLeft = targetRect.x;\n    var targetRight = targetLeft + targetRect.width;\n    var targetTop = targetRect.y;\n    var targetBottom = targetTop + targetRect.height;\n\n    for (var j = _i - 1; j >= 0; j--) {\n      if (_i !== j) {\n        var otherRect = boundingRects[j];\n        var otherLeft = otherRect.x;\n        var otherRight = otherLeft + otherRect.width;\n        var otherTop = otherRect.y;\n        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n        // but we can handle the most common cases:\n        // 1. completely overlapping rects\n        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n        //\n        // Even given the above constraints,\n        // we still won't end up with the fewest possible rects without doing multiple passes,\n        // but it's good enough for this purpose.\n\n        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n          // Complete overlapping rects; remove the inner one.\n          boundingRects.splice(_i, 1);\n          break;\n        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n          // Adjacent vertical rects; merge them.\n          if (otherTop > targetTop) {\n            otherRect.height += otherTop - targetTop;\n            otherRect.y = targetTop;\n          }\n\n          if (otherBottom < targetBottom) {\n            otherRect.height = targetBottom - otherTop;\n          }\n\n          boundingRects.splice(_i, 1);\n          break;\n        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n          // Adjacent horizontal rects; merge them.\n          if (otherLeft > targetLeft) {\n            otherRect.width += otherLeft - targetLeft;\n            otherRect.x = targetLeft;\n          }\n\n          if (otherRight < targetRight) {\n            otherRect.width = targetRight - otherLeft;\n          }\n\n          boundingRects.splice(_i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return boundingRects;\n}\nfunction focusWithin(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var matchingFibers = findPaths(root, selectors);\n  var stack = Array.from(matchingFibers);\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n\n    if (isHiddenSubtree(fiber)) {\n      continue;\n    }\n\n    if (fiber.tag === HostComponent) {\n      var node = fiber.stateNode;\n\n      if (setFocusIfFocusable(node)) {\n        return true;\n      }\n    }\n\n    var child = fiber.child;\n\n    while (child !== null) {\n      stack.push(child);\n      child = child.sibling;\n    }\n  }\n\n  return false;\n}\nvar commitHooks = [];\nfunction onCommitRoot$1() {\n  if (supportsTestSelectors) {\n    commitHooks.forEach(function (commitHook) {\n      return commitHook();\n    });\n  }\n}\nfunction observeVisibleRects(hostRoot, selectors, callback, options) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var instanceRoots = findAllNodes(hostRoot, selectors);\n\n  var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options),\n      disconnect = _setupIntersectionObs.disconnect,\n      observe = _setupIntersectionObs.observe,\n      unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n\n\n  var commitHook = function () {\n    var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n    instanceRoots.forEach(function (target) {\n      if (nextInstanceRoots.indexOf(target) < 0) {\n        unobserve(target);\n      }\n    });\n    nextInstanceRoots.forEach(function (target) {\n      if (instanceRoots.indexOf(target) < 0) {\n        observe(target);\n      }\n    });\n  };\n\n  commitHooks.push(commitHook);\n  return {\n    disconnect: function () {\n      // Stop listening for React mutations:\n      var index = commitHooks.indexOf(commitHook);\n\n      if (index >= 0) {\n        commitHooks.splice(index, 1);\n      } // Disconnect the host observer:\n\n\n      disconnect();\n    }\n  };\n}\n\nvar ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\nfunction isLegacyActEnvironment(fiber) {\n  {\n    // Legacy mode. We preserve the behavior of React 17's act. It assumes an\n    // act environment whenever `jest` is defined, but you can still turn off\n    // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n    // to false.\n    var isReactActEnvironmentGlobal = // $FlowExpectedError \u2013 Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest\n\n    var jestIsDefined = typeof jest !== 'undefined';\n    return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;\n  }\n}\nfunction isConcurrentActEnvironment() {\n  {\n    var isReactActEnvironmentGlobal = // $FlowExpectedError \u2013 Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n\n    if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n      // TODO: Include link to relevant documentation page.\n      error('The current testing environment is not configured to support ' + 'act(...)');\n    }\n\n    return isReactActEnvironmentGlobal;\n  }\n}\n\nvar ceil = Math.ceil;\nvar ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,\n    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,\n    ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,\n    ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\nvar NoContext =\n/*             */\n0;\nvar BatchedContext =\n/*               */\n1;\nvar RenderContext =\n/*                */\n2;\nvar CommitContext =\n/*                */\n4;\nvar RootInProgress = 0;\nvar RootFatalErrored = 1;\nvar RootErrored = 2;\nvar RootSuspended = 3;\nvar RootSuspendedWithDelay = 4;\nvar RootCompleted = 5;\nvar RootDidNotComplete = 6; // Describes where we are in the React execution stack\n\nvar executionContext = NoContext; // The root we're working on\n\nvar workInProgressRoot = null; // The fiber we're working on\n\nvar workInProgress = null; // The lanes we're rendering\n\nvar workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\n\nvar subtreeRenderLanes = NoLanes;\nvar subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n\nvar workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n\nvar workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\n\nvar workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nvar workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n\nvar workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n\nvar workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n\nvar workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\n\nvar workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nvar globalMostRecentFallbackTime = 0;\nvar FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\n\nvar workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\n\nvar RENDER_TIMEOUT_MS = 500;\nvar workInProgressTransitions = null;\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n}\n\nfunction getRenderTargetTime() {\n  return workInProgressRootRenderTargetTime;\n}\nvar hasUncaughtError = false;\nvar firstUncaughtError = null;\nvar legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects = false;\nvar rootWithPendingPassiveEffects = null;\nvar pendingPassiveEffectsLanes = NoLanes;\nvar pendingPassiveProfilerEffects = [];\nvar pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n\nvar NESTED_UPDATE_LIMIT = 50;\nvar nestedUpdateCount = 0;\nvar rootWithNestedUpdates = null;\nvar isFlushingPassiveEffects = false;\nvar didScheduleUpdateDuringPassiveEffects = false;\nvar NESTED_PASSIVE_UPDATE_LIMIT = 50;\nvar nestedPassiveUpdateCount = 0;\nvar rootWithPassiveNestedUpdates = null; // If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\n\nvar currentEventTime = NoTimestamp;\nvar currentEventTransitionLane = NoLanes;\nvar isRunningInsertionEffect = false;\nfunction getWorkInProgressRoot() {\n  return workInProgressRoot;\n}\nfunction requestEventTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now();\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = now();\n  return currentEventTime;\n}\nfunction requestUpdateLane(fiber) {\n  // Special cases\n  var mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  } else if ( (executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  var isTransition = requestCurrentTransition() !== NoTransition;\n\n  if (isTransition) {\n    if ( ReactCurrentBatchConfig$2.transition !== null) {\n      var transition = ReactCurrentBatchConfig$2.transition;\n\n      if (!transition._updatedFibers) {\n        transition._updatedFibers = new Set();\n      }\n\n      transition._updatedFibers.add(fiber);\n    } // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n\n\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n\n    return currentEventTransitionLane;\n  } // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  var updateLane = getCurrentUpdatePriority();\n\n  if (updateLane !== NoLane) {\n    return updateLane;\n  } // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  var eventLane = getCurrentEventPriority();\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\" \u2014 a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n  // Special cases\n  var mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  }\n\n  return claimNextRetryLane();\n}\n\nfunction scheduleUpdateOnFiber(root, fiber, lane, eventTime) {\n  checkForNestedUpdates();\n\n  {\n    if (isRunningInsertionEffect) {\n      error('useInsertionEffect must not schedule updates.');\n    }\n  }\n\n  {\n    if (isFlushingPassiveEffects) {\n      didScheduleUpdateDuringPassiveEffects = true;\n    }\n  } // Mark that the root has a pending update.\n\n\n  markRootUpdated(root, lane, eventTime);\n\n  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (root === workInProgressRoot) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if ( (executionContext & RenderContext) === NoContext) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n      }\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended$1(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n\n    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nfunction scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n  // This is a special fork of scheduleUpdateOnFiber that is only used to\n  // schedule the initial hydration of a root that has just been created. Most\n  // of the stuff in scheduleUpdateOnFiber can be skipped.\n  //\n  // The main reason for this separate path, though, is to distinguish the\n  // initial children from subsequent updates. In fully client-rendered roots\n  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n  // updates, but hydration roots are special because the initial render must\n  // match what was rendered on the server.\n  var current = root.current;\n  current.lanes = lane;\n  markRootUpdated(root, lane, eventTime);\n  ensureRootIsScheduled(root, eventTime);\n}\nfunction isUnsafeClassRenderPhaseUpdate(fiber) {\n  // Check if this is a render phase update. Only called by class components,\n  // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n  return (// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n    // decided not to enable it.\n     (executionContext & RenderContext) !== NoContext\n  );\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\n\nfunction ensureRootIsScheduled(root, currentTime) {\n  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n\n  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n\n  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback$1(existingCallbackNode);\n    }\n\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  } // We use the highest priority lane to represent the priority of the callback.\n\n\n  var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n\n  var existingCallbackPriority = root.callbackPriority;\n\n  if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n  // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n  // on the `act` queue.\n  !( ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n    {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n        error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // The priority hasn't changed. We can reuse the existing task. Exit.\n\n\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback$1(existingCallbackNode);\n  } // Schedule a new callback.\n\n\n  var newCallbackNode;\n\n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if ( ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n      }\n\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if ( ReactCurrentActQueue$1.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(function () {\n          // In Safari, appending an iframe forces microtasks to run.\n          // https://github.com/facebook/react/issues/22459\n          // We don't support running callbacks in the middle of render\n          // or commit so we need to check against that.\n          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n            // Note that this would still prematurely flush the callbacks\n            // if this happens outside render or commit phase (e.g. in an event).\n            flushSyncCallbacks();\n          }\n        });\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);\n    }\n\n    newCallbackNode = null;\n  } else {\n    var schedulerPriorityLevel;\n\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediatePriority;\n        break;\n\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingPriority;\n        break;\n\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalPriority;\n        break;\n\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdlePriority;\n        break;\n\n      default:\n        schedulerPriorityLevel = NormalPriority;\n        break;\n    }\n\n    newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  {\n    resetNestedUpdateFlag();\n  } // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n\n\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  } // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n\n\n  var originalCallbackNode = root.callbackNode;\n  var didFlushPassiveEffects = flushPassiveEffects();\n\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    }\n  } // Determine the next lanes to work on, using the fields stored\n  // on the root.\n\n\n  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  } // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n\n\n  var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && ( !didTimeout);\n  var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n\n  if (exitStatus !== RootInProgress) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n\n    if (exitStatus === RootFatalErrored) {\n      var fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended$1(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    if (exitStatus === RootDidNotComplete) {\n      // The render unwound without completing the tree. This happens in special\n      // cases where need to exit the current render without producing a\n      // consistent tree or committing.\n      //\n      // This should only happen during a concurrent render, not a discrete or\n      // synchronous update. We should have already checked for this when we\n      // unwound the stack.\n      markRootSuspended$1(root, lanes);\n    } else {\n      // The render completed.\n      // Check if this render may have yielded to a concurrent event, and if so,\n      // confirm that any newly rendered stores are consistent.\n      // TODO: It's possible that even a concurrent render may never have yielded\n      // to the main thread, if it was fast enough, or if it expired. We could\n      // skip the consistency check in that case, too.\n      var renderWasConcurrent = !includesBlockingLane(root, lanes);\n      var finishedWork = root.current.alternate;\n\n      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n        // A store was mutated in an interleaved event. Render again,\n        // synchronously, to block further mutations.\n        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n\n        if (exitStatus === RootErrored) {\n          var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n          if (_errorRetryLanes !== NoLanes) {\n            lanes = _errorRetryLanes;\n            exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n            // concurrent events.\n          }\n        }\n\n        if (exitStatus === RootFatalErrored) {\n          var _fatalError = workInProgressRootFatalError;\n          prepareFreshStack(root, NoLanes);\n          markRootSuspended$1(root, lanes);\n          ensureRootIsScheduled(root, now());\n          throw _fatalError;\n        }\n      } // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n\n\n      root.finishedWork = finishedWork;\n      root.finishedLanes = lanes;\n      finishConcurrentRender(root, exitStatus, lanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, now());\n\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n\n  return null;\n}\n\nfunction recoverFromConcurrentError(root, errorRetryLanes) {\n  // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n  // Before rendering again, save the errors from the previous attempt.\n  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n\n  if (isRootDehydrated(root)) {\n    // The shell failed to hydrate. Set a flag to force a client rendering\n    // during the next attempt. To do this, we call prepareFreshStack now\n    // to create the root work-in-progress fiber. This is a bit weird in terms\n    // of factoring, because it relies on renderRootSync not calling\n    // prepareFreshStack again in the call below, which happens because the\n    // root and lanes haven't changed.\n    //\n    // TODO: I think what we should do is set ForceClientRender inside\n    // throwException, like we do for nested Suspense boundaries. The reason\n    // it's here instead is so we can switch to the synchronous work loop, too.\n    // Something to consider for a future refactor.\n    var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n    rootWorkInProgress.flags |= ForceClientRender;\n\n    {\n      errorHydratingContainer(root.containerInfo);\n    }\n  }\n\n  var exitStatus = renderRootSync(root, errorRetryLanes);\n\n  if (exitStatus !== RootErrored) {\n    // Successfully finished rendering on retry\n    // The errors from the failed first attempt have been recovered. Add\n    // them to the collection of recoverable errors. We'll log them in the\n    // commit phase.\n    var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n    workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n    // from the first attempt, to preserve the causal sequence.\n\n    if (errorsFromSecondAttempt !== null) {\n      queueRecoverableErrors(errorsFromSecondAttempt);\n    }\n  }\n\n  return exitStatus;\n}\n\nfunction queueRecoverableErrors(errors) {\n  if (workInProgressRootRecoverableErrors === null) {\n    workInProgressRootRecoverableErrors = errors;\n  } else {\n    workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n  }\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootInProgress:\n    case RootFatalErrored:\n      {\n        throw new Error('Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // We should have already attempted to retry this tree. If we reached\n        // this point, it errored again. Commit it.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n\n        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()) {\n          // This render only included retries, no updates. Throttle committing\n          // retries so that we don't show too many loading states too quickly.\n          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            var nextLanes = getNextLanes(root, NoLanes);\n\n            if (nextLanes !== NoLanes) {\n              // There's additional work on this root.\n              break;\n            }\n\n            var suspendedLanes = root.suspendedLanes;\n\n            if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              // FIXME: What if the suspended lanes are Idle? Should not restart.\n              var eventTime = requestEventTime();\n              markRootPinged(root, suspendedLanes);\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspended$1(root, lanes);\n\n        if (includesOnlyTransitions(lanes)) {\n          // This is a transition, so we should exit without committing a\n          // placeholder and without scheduling a timeout. Delay indefinitely\n          // until we receive more data.\n          break;\n        }\n\n        if (!shouldForceFlushFallbacksInDEV()) {\n          // This is not a transition, but we did trigger an avoided state.\n          // Schedule a placeholder to display after a short delay, using the Just\n          // Noticeable Difference.\n          // TODO: Is the JND optimization worth the added complexity? If this is\n          // the only reason we track the event time, then probably not.\n          // Consider removing.\n          var mostRecentEventTime = getMostRecentEventTime(root, lanes);\n          var eventTimeMs = mostRecentEventTime;\n          var timeElapsedMs = now() - eventTimeMs;\n\n          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n\n\n          if (_msUntilTimeout > 10) {\n            // Instead of committing the fallback immediately, wait for more data\n            // to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);\n            break;\n          }\n        } // Commit the placeholder.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unknown root exit status.');\n      }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  var node = finishedWork;\n\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      var updateQueue = node.updateQueue;\n\n      if (updateQueue !== null) {\n        var checks = updateQueue.stores;\n\n        if (checks !== null) {\n          for (var i = 0; i < checks.length; i++) {\n            var check = checks[i];\n            var getSnapshot = check.getSnapshot;\n            var renderedValue = check.value;\n\n            try {\n              if (!objectIs(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n\n    var child = node.child;\n\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n\n    if (node === finishedWork) {\n      return true;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n\n\n  return true;\n}\n\nfunction markRootSuspended$1(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n  markRootSuspended(root, suspendedLanes);\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n\n\nfunction performSyncWorkOnRoot(root) {\n  {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  flushPassiveEffects();\n  var lanes = getNextLanes(root, NoLanes);\n\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  var exitStatus = renderRootSync(root, lanes);\n\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    var fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended$1(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  if (exitStatus === RootDidNotComplete) {\n    throw new Error('Root did not complete. This is a bug in React.');\n  } // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n\n\n  var finishedWork = root.current.alternate;\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions); // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n\n  ensureRootIsScheduled(root, now());\n  return null;\n}\n\nfunction flushRoot(root, lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now());\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction deferredUpdates(fn) {\n  var previousPriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n  }\n}\nfunction batchedUpdates(fn, a) {\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n\n    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nfunction discreteUpdates(fn, a, b, c, d) {\n  var previousPriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n} // Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushPassiveEffects();\n  }\n\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n  var previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction isAlreadyRendering() {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return  (executionContext & (RenderContext | CommitContext)) !== NoContext;\n}\nfunction flushControlled(fn) {\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n  var previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction pushRenderLanes(fiber, lanes) {\n  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n}\nfunction popRenderLanes(fiber) {\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\n  pop(subtreeRenderLanesCursor, fiber);\n}\n\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n  var timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    var interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      var current = interruptedWork.alternate;\n      unwindInterruptedWork(current, interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  workInProgressRoot = root;\n  var rootWorkInProgress = createWorkInProgress(root.current, null);\n  workInProgress = rootWorkInProgress;\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  workInProgressRootExitStatus = RootInProgress;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  workInProgressRootConcurrentErrors = null;\n  workInProgressRootRecoverableErrors = null;\n  finishQueueingConcurrentUpdates();\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n\n  return rootWorkInProgress;\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    var erroredWork = workInProgress;\n\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n\n      ReactCurrentOwner$2.current = null;\n\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n\n        workInProgress = null;\n        return;\n      }\n\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n      }\n\n      if (enableSchedulingProfiler) {\n        markComponentRenderStopped();\n\n        if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n          var wakeable = thrownValue;\n          markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n        } else {\n          markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n      }\n\n      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n\n      continue;\n    } // Return to the normal work loop.\n\n\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher() {\n  var prevDispatcher = ReactCurrentDispatcher$2.current;\n  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher$2.current = prevDispatcher;\n}\n\nfunction markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nfunction markSkippedUpdateLanes(lane) {\n  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n}\nfunction renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nfunction renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n\n\n  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\nfunction renderDidError(error) {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n\n  if (workInProgressRootConcurrentErrors === null) {\n    workInProgressRootConcurrentErrors = [error];\n  } else {\n    workInProgressRootConcurrentErrors.push(error);\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nfunction renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootInProgress;\n}\n\nfunction renderRootSync(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    {\n      if (isDevToolsPresent) {\n        var memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes();\n    prepareFreshStack(root, lanes);\n  }\n\n  {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n  }\n\n  {\n    markRenderStopped();\n  } // Set this to null to indicate there's no in-progress render.\n\n\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n  return workInProgressRootExitStatus;\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    {\n      if (isDevToolsPresent) {\n        var memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes();\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n\n  if (workInProgress !== null) {\n    // Still work remaining.\n    {\n      markRenderYielded();\n    }\n\n    return RootInProgress;\n  } else {\n    // Completed the tree.\n    {\n      markRenderStopped();\n    } // Set this to null to indicate there's no in-progress render.\n\n\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n\n    return workInProgressRootExitStatus;\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  var current = unitOfWork.alternate;\n  setCurrentFiber(unitOfWork);\n  var next;\n\n  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n  }\n\n  resetCurrentFiber();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner$2.current = null;\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  var completedWork = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    var current = completedWork.alternate;\n    var returnFiber = completedWork.return; // Check if the work completed or if something threw.\n\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentFiber(completedWork);\n      var next = void 0;\n\n      if ( (completedWork.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, completedWork, subtreeRenderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n\n      resetCurrentFiber();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.\n\n\n      if (_next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.flags &= HostEffectMask;\n        workInProgress = _next;\n        return;\n      }\n\n      if ( (completedWork.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n\n        var actualDuration = completedWork.actualDuration;\n        var child = completedWork.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      } else {\n        // We've unwound all the way to the root.\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n        return;\n      }\n    }\n\n    var siblingFiber = completedWork.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    } // Otherwise, return to the parent\n\n\n    completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n\n    workInProgress = completedWork;\n  } while (completedWork !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(root, recoverableErrors, transitions) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  var previousUpdateLanePriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);\n  } finally {\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n\nfunction commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  var finishedWork = root.finishedWork;\n  var lanes = root.finishedLanes;\n\n  {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n\n    {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    {\n      if (lanes === NoLanes) {\n        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n      }\n    }\n  }\n\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n  } // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n\n\n  root.callbackNode = null;\n  root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n\n\n  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      // to store it in pendingPassiveTransitions until they get processed\n      // We need to pass this through as an argument to commitRoot\n      // because workInProgressTransitions might have changed between\n      // the previous render and commit if we throttle the commit\n      // with setTimeout\n\n      pendingPassiveTransitions = transitions;\n      scheduleCallback$1(NormalPriority, function () {\n        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\n        return null;\n      });\n    }\n  } // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n\n\n  var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n  var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    var prevTransition = ReactCurrentBatchConfig$2.transition;\n    ReactCurrentBatchConfig$2.transition = null;\n    var previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    var prevExecutionContext = executionContext;\n    executionContext |= CommitContext; // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    var shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n\n    {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n\n    commitMutationEffects(root, finishedWork, lanes);\n\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n\n    {\n      markLayoutEffectsStarted(lanes);\n    }\n\n    commitLayoutEffects(finishedWork, root, lanes);\n\n    {\n      markLayoutEffectsStopped();\n    }\n    // opportunity to paint.\n\n\n    requestPaint();\n    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    {\n      recordCommitTime();\n    }\n  }\n\n  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n\n    {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n    }\n  } // Read this again, since an effect might have updated it\n\n\n  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed \u2014 that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root.current, false);\n    }\n  }\n\n  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n\n  {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  {\n    onCommitRoot$1();\n  } // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n\n  ensureRootIsScheduled(root, now());\n\n  if (recoverableErrors !== null) {\n    // There were errors during this render, but recovered from them without\n    // needing to surface it to the UI. We log them here.\n    var onRecoverableError = root.onRecoverableError;\n\n    for (var i = 0; i < recoverableErrors.length; i++) {\n      var recoverableError = recoverableErrors[i];\n      var componentStack = recoverableError.stack;\n      var digest = recoverableError.digest;\n      onRecoverableError(recoverableError.value, {\n        componentStack: componentStack,\n        digest: digest\n      });\n    }\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    var error$1 = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error$1;\n  } // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n\n\n  if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n    flushPassiveEffects();\n  } // Read this again, since a passive effect might have updated it\n\n\n  remainingLanes = root.pendingLanes;\n\n  if (includesSomeLane(remainingLanes, SyncLane)) {\n    {\n      markNestedUpdateScheduled();\n    } // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n\n\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbacks();\n\n  {\n    markCommitStopped();\n  }\n\n  return null;\n}\n\nfunction flushPassiveEffects() {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    var prevTransition = ReactCurrentBatchConfig$2.transition;\n    var previousPriority = getCurrentUpdatePriority();\n\n    try {\n      ReactCurrentBatchConfig$2.transition = null;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n    }\n  }\n\n  return false;\n}\nfunction enqueuePendingPassiveProfilerEffect(fiber) {\n  {\n    pendingPassiveProfilerEffects.push(fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback$1(NormalPriority, function () {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  } // Cache and clear the transitions flag\n\n\n  var transitions = pendingPassiveTransitions;\n  pendingPassiveTransitions = null;\n  var root = rootWithPendingPassiveEffects;\n  var lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  {\n    isFlushingPassiveEffects = true;\n    didScheduleUpdateDuringPassiveEffects = false;\n  }\n\n  {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  var prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n\n  {\n    var profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n\n    for (var i = 0; i < profilerEffects.length; i++) {\n      var _fiber = profilerEffects[i];\n      commitPassiveEffectDurations(root, _fiber);\n    }\n  }\n\n  {\n    markPassiveEffectsStopped();\n  }\n\n  {\n    commitDoubleInvokeEffectsInDEV(root.current, true);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbacks();\n\n  {\n    // If additional passive effects were scheduled, increment a counter. If this\n    // exceeds the limit, we'll fire a warning.\n    if (didScheduleUpdateDuringPassiveEffects) {\n      if (root === rootWithPassiveNestedUpdates) {\n        nestedPassiveUpdateCount++;\n      } else {\n        nestedPassiveUpdateCount = 0;\n        rootWithPassiveNestedUpdates = root;\n      }\n    } else {\n      nestedPassiveUpdateCount = 0;\n    }\n\n    isFlushingPassiveEffects = false;\n    didScheduleUpdateDuringPassiveEffects = false;\n  } // TODO: Move to commitPassiveMountEffects\n\n\n  onPostCommitRoot(root);\n\n  {\n    var stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nvar onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  var errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n  var root = enqueueUpdate(rootFiber, update, SyncLane);\n  var eventTime = requestEventTime();\n\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nfunction captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n  {\n    reportUncaughtErrorInDEV(error$1);\n    setIsRunningInsertionEffect(false);\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n    return;\n  }\n\n  var fiber = null;\n\n  {\n    fiber = nearestMountedAncestor;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      var ctor = fiber.type;\n      var instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n        var root = enqueueUpdate(fiber, update, SyncLane);\n        var eventTime = requestEventTime();\n\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n\n  {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n  }\n}\nfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n  var pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  var eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes);\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root.\n      prepareFreshStack(root, NoLanes);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  } // TODO: Special case idle priority?\n\n\n  var eventTime = requestEventTime();\n  var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nfunction retryDehydratedSuspenseBoundary(boundaryFiber) {\n  var suspenseState = boundaryFiber.memoizedState;\n  var retryLane = NoLane;\n\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction resolveRetryWakeable(boundaryFiber, wakeable) {\n  var retryLane = NoLane; // Default\n\n  var retryCache;\n\n  switch (boundaryFiber.tag) {\n    case SuspenseComponent:\n      retryCache = boundaryFiber.stateNode;\n      var suspenseState = boundaryFiber.memoizedState;\n\n      if (suspenseState !== null) {\n        retryLane = suspenseState.retryLane;\n      }\n\n      break;\n\n    case SuspenseListComponent:\n      retryCache = boundaryFiber.stateNode;\n      break;\n\n    default:\n      throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n\n      error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n  {\n    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n    // Maybe not a big deal since this is DEV only behavior.\n    setCurrentFiber(fiber);\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n    }\n\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n    }\n\n    resetCurrentFiber();\n  }\n}\n\nfunction invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    var current = firstChild;\n    var subtreeRoot = null;\n\n    while (current !== null) {\n      var primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n\n      if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n        current = current.child;\n      } else {\n        if ((current.flags & fiberFlags) !== NoFlags) {\n          invokeEffectFn(current);\n        }\n\n        if (current.sibling !== null) {\n          current = current.sibling;\n        } else {\n          current = subtreeRoot = current.return;\n        }\n      }\n    }\n  }\n}\n\nvar didWarnStateUpdateForNotYetMountedComponent = null;\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n  {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    var tag = fiber.tag;\n\n    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    var previousFiber = current;\n\n    try {\n      setCurrentFiber(fiber);\n\n      error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n    } finally {\n      if (previousFiber) {\n        setCurrentFiber(fiber);\n      } else {\n        resetCurrentFiber();\n      }\n    }\n  }\n}\nvar beginWork$1;\n\n{\n  var dummyFiber = null;\n\n  beginWork$1 = function (current, unitOfWork, lanes) {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return beginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises.\n        // Don't replay errors if we are hydrating and have already suspended or handled an error\n        throw originalError;\n      } // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n      unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if ( unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\n\n      if (hasCaughtError()) {\n        var replayError = clearCaughtError();\n\n        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      } // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\n\n      throw originalError;\n    }\n  };\n}\n\nvar didWarnAboutUpdateInRender = false;\nvar didWarnAboutUpdateInRenderForAnotherComponent;\n\n{\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  {\n    if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n          {\n            var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n            var dedupeKey = renderingComponentName;\n\n            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n              var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n            }\n\n            break;\n          }\n\n        case ClassComponent:\n          {\n            if (!didWarnAboutUpdateInRender) {\n              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n\n              didWarnAboutUpdateInRender = true;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nfunction restorePendingUpdaters(root, lanes) {\n  {\n    if (isDevToolsPresent) {\n      var memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(function (schedulingFiber) {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      }); // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\nvar fakeActCallbackNode = {};\n\nfunction scheduleCallback$1(priorityLevel, callback) {\n  {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    var actQueue = ReactCurrentActQueue$1.current;\n\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return scheduleCallback(priorityLevel, callback);\n    }\n  }\n}\n\nfunction cancelCallback$1(callbackNode) {\n  if ( callbackNode === fakeActCallbackNode) {\n    return;\n  } // In production, always call Scheduler. This function will be stripped out.\n\n\n  return cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return  ReactCurrentActQueue$1.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber) {\n  {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n\n      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue$1.current === null) {\n      var previousFiber = current;\n\n      try {\n        setCurrentFiber(fiber);\n\n        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n      } finally {\n        if (previousFiber) {\n          setCurrentFiber(fiber);\n        } else {\n          resetCurrentFiber();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n  {\n    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n      error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');\n    }\n  }\n}\n\nfunction setIsRunningInsertionEffect(isRunning) {\n  {\n    isRunningInsertionEffect = isRunning;\n  }\n}\n\n/* eslint-disable react-internal/prod-error-codes */\nvar resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n\nvar failedBoundaries = null;\nvar setRefreshHandler = function (handler) {\n  {\n    resolveFamily = handler;\n  }\n};\nfunction resolveFunctionForHotReloading(type) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    var family = resolveFamily(type);\n\n    if (family === undefined) {\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  }\n}\nfunction resolveClassForHotReloading(type) {\n  // No implementation differences.\n  return resolveFunctionForHotReloading(type);\n}\nfunction resolveForwardRefForHotReloading(type) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    var family = resolveFamily(type);\n\n    if (family === undefined) {\n      // Check if we're dealing with a real forwardRef. Don't want to crash early.\n      if (type !== null && type !== undefined && typeof type.render === 'function') {\n        // ForwardRef is special because its resolved .type is an object,\n        // but it's possible that we only have its inner render function in the map.\n        // If that inner render function is different, we'll build a new forwardRef type.\n        var currentRender = resolveFunctionForHotReloading(type.render);\n\n        if (type.render !== currentRender) {\n          var syntheticType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: currentRender\n          };\n\n          if (type.displayName !== undefined) {\n            syntheticType.displayName = type.displayName;\n          }\n\n          return syntheticType;\n        }\n      }\n\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  }\n}\nfunction isCompatibleFamilyForHotReloading(fiber, element) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return false;\n    }\n\n    var prevType = fiber.elementType;\n    var nextType = element.type; // If we got here, we know types aren't === equal.\n\n    var needsCompareFamilies = false;\n    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n\n    switch (fiber.tag) {\n      case ClassComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case FunctionComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            // We don't know the inner type yet.\n            // We're going to assume that the lazy inner type is stable,\n            // and so it is sufficient to avoid reconciling it away.\n            // We're not going to unwrap or actually use the new lazy type.\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case ForwardRef:\n        {\n          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ($$typeofNextType === REACT_MEMO_TYPE) {\n            // TODO: if it was but can no longer be simple,\n            // we shouldn't set this.\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      default:\n        return false;\n    } // Check if both types have a family and it's the same one.\n\n\n    if (needsCompareFamilies) {\n      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n      // This means both of them need to be registered to preserve state.\n      // If we unwrapped and compared the inner types for wrappers instead,\n      // then we would risk falsely saying two separate memo(Foo)\n      // calls are equivalent because they wrap the same Foo function.\n      var prevFamily = resolveFamily(prevType);\n\n      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\nfunction markFailedErrorBoundaryForHotReloading(fiber) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    if (typeof WeakSet !== 'function') {\n      return;\n    }\n\n    if (failedBoundaries === null) {\n      failedBoundaries = new WeakSet();\n    }\n\n    failedBoundaries.add(fiber);\n  }\n}\nvar scheduleRefresh = function (root, update) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    var staleFamilies = update.staleFamilies,\n        updatedFamilies = update.updatedFamilies;\n    flushPassiveEffects();\n    flushSync(function () {\n      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n    });\n  }\n};\nvar scheduleRoot = function (root, element) {\n  {\n    if (root.context !== emptyContextObject) {\n      // Super edge case: root has a legacy _renderSubtree context\n      // but we don't know the parentComponent so we can't pass it.\n      // Just ignore. We'll delete this with _renderSubtree code path later.\n      return;\n    }\n\n    flushPassiveEffects();\n    flushSync(function () {\n      updateContainer(element, root, null, null);\n    });\n  }\n};\n\nfunction scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n  {\n    var alternate = fiber.alternate,\n        child = fiber.child,\n        sibling = fiber.sibling,\n        tag = fiber.tag,\n        type = fiber.type;\n    var candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n    }\n\n    if (resolveFamily === null) {\n      throw new Error('Expected resolveFamily to be set during hot reload.');\n    }\n\n    var needsRender = false;\n    var needsRemount = false;\n\n    if (candidateType !== null) {\n      var family = resolveFamily(candidateType);\n\n      if (family !== undefined) {\n        if (staleFamilies.has(family)) {\n          needsRemount = true;\n        } else if (updatedFamilies.has(family)) {\n          if (tag === ClassComponent) {\n            needsRemount = true;\n          } else {\n            needsRender = true;\n          }\n        }\n      }\n    }\n\n    if (failedBoundaries !== null) {\n      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n        needsRemount = true;\n      }\n    }\n\n    if (needsRemount) {\n      fiber._debugNeedsRemount = true;\n    }\n\n    if (needsRemount || needsRender) {\n      var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (_root !== null) {\n        scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n\n    if (child !== null && !needsRemount) {\n      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n    }\n\n    if (sibling !== null) {\n      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n  }\n}\n\nvar findHostInstancesForRefresh = function (root, families) {\n  {\n    var hostInstances = new Set();\n    var types = new Set(families.map(function (family) {\n      return family.current;\n    }));\n    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n    return hostInstances;\n  }\n};\n\nfunction findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n  {\n    var child = fiber.child,\n        sibling = fiber.sibling,\n        tag = fiber.tag,\n        type = fiber.type;\n    var candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n    }\n\n    var didMatch = false;\n\n    if (candidateType !== null) {\n      if (types.has(candidateType)) {\n        didMatch = true;\n      }\n    }\n\n    if (didMatch) {\n      // We have a match. This only drills down to the closest host components.\n      // There's no need to search deeper because for the purpose of giving\n      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n      findHostInstancesForFiberShallowly(fiber, hostInstances);\n    } else {\n      // If there's no match, maybe there will be one further down in the child tree.\n      if (child !== null) {\n        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n      }\n    }\n\n    if (sibling !== null) {\n      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n    }\n  }\n}\n\nfunction findHostInstancesForFiberShallowly(fiber, hostInstances) {\n  {\n    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n\n    if (foundHostInstances) {\n      return;\n    } // If we didn't find any host children, fallback to closest host parent.\n\n\n    var node = fiber;\n\n    while (true) {\n      switch (node.tag) {\n        case HostComponent:\n          hostInstances.add(node.stateNode);\n          return;\n\n        case HostPortal:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n\n        case HostRoot:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n      }\n\n      if (node.return === null) {\n        throw new Error('Expected to reach root first.');\n      }\n\n      node = node.return;\n    }\n  }\n}\n\nfunction findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n  {\n    var node = fiber;\n    var foundHostInstances = false;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        // We got a match.\n        foundHostInstances = true;\n        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return foundHostInstances;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === fiber) {\n          return foundHostInstances;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  return false;\n}\n\nvar hasBadMapPolyfill;\n\n{\n  hasBadMapPolyfill = false;\n\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n\n    new Map([[nonExtensibleObject, null]]);\n    new Set([nonExtensibleObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null; // Fiber\n\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n  this.ref = null;\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n  this.mode = mode; // Effects\n\n  this.flags = NoFlags;\n  this.subtreeFlags = NoFlags;\n  this.deletions = null;\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n  this.alternate = null;\n\n  {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    // This isn't directly used but is handy for debugging internals:\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugNeedsRemount = false;\n    this._debugHookTypes = null;\n\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n} // This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\n\n\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct$1(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction isSimpleFunctionComponent(type) {\n  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;\n}\nfunction resolveLazyComponentTag(Component) {\n  if (typeof Component === 'function') {\n    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n  } else if (Component !== undefined && Component !== null) {\n    var $$typeof = Component.$$typeof;\n\n    if ($$typeof === REACT_FORWARD_REF_TYPE) {\n      return ForwardRef;\n    }\n\n    if ($$typeof === REACT_MEMO_TYPE) {\n      return MemoComponent;\n    }\n  }\n\n  return IndeterminateComponent;\n} // This is used to create an alternate fiber to do work on.\n\nfunction createWorkInProgress(current, pendingProps) {\n  var workInProgress = current.alternate;\n\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n      workInProgress._debugHookTypes = current._debugHookTypes;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n\n    workInProgress.type = current.type; // We already have an alternate.\n    // Reset the effect tag.\n\n    workInProgress.flags = NoFlags; // The effects are no longer valid.\n\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.deletions = null;\n\n    {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  } // Reset all effects except static ones.\n  // Static effects are not specific to a render.\n\n\n  workInProgress.flags = current.flags & StaticMask;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n\n  var currentDependencies = current.dependencies;\n  workInProgress.dependencies = currentDependencies === null ? null : {\n    lanes: currentDependencies.lanes,\n    firstContext: currentDependencies.firstContext\n  }; // These will be overridden during the parent's reconciliation\n\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  {\n    workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n      case FunctionComponent:\n      case SimpleMemoComponent:\n        workInProgress.type = resolveFunctionForHotReloading(current.type);\n        break;\n\n      case ClassComponent:\n        workInProgress.type = resolveClassForHotReloading(current.type);\n        break;\n\n      case ForwardRef:\n        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        break;\n    }\n  }\n\n  return workInProgress;\n} // Used to reuse a Fiber for a second pass.\n\nfunction resetWorkInProgress(workInProgress, renderLanes) {\n  // This resets the Fiber to what createFiber or createWorkInProgress would\n  // have set the values to before during the first pass. Ideally this wouldn't\n  // be necessary but unfortunately many code paths reads from the workInProgress\n  // when they should be reading from current and writing to workInProgress.\n  // We assume pendingProps, index, key, ref, return are still untouched to\n  // avoid doing another reconciliation.\n  // Reset the effect flags but keep any Placement tags, since that's something\n  // that child fiber is setting, not the reconciliation.\n  workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n\n  var current = workInProgress.alternate;\n\n  if (current === null) {\n    // Reset to createFiber's initial values.\n    workInProgress.childLanes = NoLanes;\n    workInProgress.lanes = renderLanes;\n    workInProgress.child = null;\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.memoizedProps = null;\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null;\n    workInProgress.dependencies = null;\n    workInProgress.stateNode = null;\n\n    {\n      // Note: We don't reset the actualTime counts. It's useful to accumulate\n      // actual time across multiple render passes.\n      workInProgress.selfBaseDuration = 0;\n      workInProgress.treeBaseDuration = 0;\n    }\n  } else {\n    // Reset to the cloned values that createWorkInProgress would've.\n    workInProgress.childLanes = current.childLanes;\n    workInProgress.lanes = current.lanes;\n    workInProgress.child = current.child;\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.deletions = null;\n    workInProgress.memoizedProps = current.memoizedProps;\n    workInProgress.memoizedState = current.memoizedState;\n    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n\n    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n    // it cannot be shared with the current fiber.\n\n    var currentDependencies = current.dependencies;\n    workInProgress.dependencies = currentDependencies === null ? null : {\n      lanes: currentDependencies.lanes,\n      firstContext: currentDependencies.firstContext\n    };\n\n    {\n      // Note: We don't reset the actualTime counts. It's useful to accumulate\n      // actual time across multiple render passes.\n      workInProgress.selfBaseDuration = current.selfBaseDuration;\n      workInProgress.treeBaseDuration = current.treeBaseDuration;\n    }\n  }\n\n  return workInProgress;\n}\nfunction createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n  var mode;\n\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode;\n\n    if (isStrictMode === true) {\n      mode |= StrictLegacyMode;\n\n      {\n        mode |= StrictEffectsMode;\n      }\n    }\n  } else {\n    mode = NoMode;\n  }\n\n  if ( isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\u2013\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\nfunction createFiberFromTypeAndProps(type, // React$ElementType\nkey, pendingProps, owner, mode, lanes) {\n  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n\n  var resolvedType = type;\n\n  if (typeof type === 'function') {\n    if (shouldConstruct$1(type)) {\n      fiberTag = ClassComponent;\n\n      {\n        resolvedType = resolveClassForHotReloading(resolvedType);\n      }\n    } else {\n      {\n        resolvedType = resolveFunctionForHotReloading(resolvedType);\n      }\n    }\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictLegacyMode;\n\n        if ( (mode & ConcurrentMode) !== NoMode) {\n          // Strict effects should never run on legacy roots\n          mode |= StrictEffectsMode;\n        }\n\n        break;\n\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n\n      case REACT_SUSPENSE_TYPE:\n        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n\n      case REACT_SUSPENSE_LIST_TYPE:\n        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n\n      case REACT_OFFSCREEN_TYPE:\n        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n\n      case REACT_LEGACY_HIDDEN_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_SCOPE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_CACHE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_TRACING_MARKER_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_DEBUG_TRACING_MODE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      default:\n        {\n          if (typeof type === 'object' && type !== null) {\n            switch (type.$$typeof) {\n              case REACT_PROVIDER_TYPE:\n                fiberTag = ContextProvider;\n                break getTag;\n\n              case REACT_CONTEXT_TYPE:\n                // This is a consumer\n                fiberTag = ContextConsumer;\n                break getTag;\n\n              case REACT_FORWARD_REF_TYPE:\n                fiberTag = ForwardRef;\n\n                {\n                  resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                }\n\n                break getTag;\n\n              case REACT_MEMO_TYPE:\n                fiberTag = MemoComponent;\n                break getTag;\n\n              case REACT_LAZY_TYPE:\n                fiberTag = LazyComponent;\n                resolvedType = null;\n                break getTag;\n            }\n          }\n\n          var info = '';\n\n          {\n            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n              info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n            }\n\n            var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n\n            if (ownerName) {\n              info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n            }\n          }\n\n          throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n    }\n  }\n\n  var fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.elementType = type;\n  fiber.type = resolvedType;\n  fiber.lanes = lanes;\n\n  {\n    fiber._debugOwner = owner;\n  }\n\n  return fiber;\n}\nfunction createFiberFromElement(element, mode, lanes) {\n  var owner = null;\n\n  {\n    owner = element._owner;\n  }\n\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\nfunction createFiberFromFragment(elements, mode, lanes, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.lanes = lanes;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, lanes, key) {\n  {\n    if (typeof pendingProps.id !== 'string') {\n      error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.elementType = REACT_PROFILER_TYPE;\n  fiber.lanes = lanes;\n\n  {\n    fiber.stateNode = {\n      effectDuration: 0,\n      passiveEffectDuration: 0\n    };\n  }\n\n  return fiber;\n}\n\nfunction createFiberFromSuspense(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_SUSPENSE_TYPE;\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_OFFSCREEN_TYPE;\n  fiber.lanes = lanes;\n  var primaryChildInstance = {\n    isHidden: false\n  };\n  fiber.stateNode = primaryChildInstance;\n  return fiber;\n}\nfunction createFiberFromText(content, mode, lanes) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoMode);\n  fiber.elementType = 'DELETED';\n  return fiber;\n}\nfunction createFiberFromDehydratedFragment(dehydratedNode) {\n  var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n  fiber.stateNode = dehydratedNode;\n  return fiber;\n}\nfunction createFiberFromPortal(portal, mode, lanes) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.lanes = lanes;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null,\n    // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n} // Used for stashing WIP properties to replay failed work in DEV.\n\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoMode);\n  } // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.elementType = source.elementType;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.dependencies = source.dependencies;\n  target.mode = source.mode;\n  target.flags = source.flags;\n  target.subtreeFlags = source.subtreeFlags;\n  target.deletions = source.deletions;\n  target.lanes = source.lanes;\n  target.childLanes = source.childLanes;\n  target.alternate = source.alternate;\n\n  {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugNeedsRemount = source._debugNeedsRemount;\n  target._debugHookTypes = source._debugHookTypes;\n  return target;\n}\n\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n  this.tag = tag;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoLane;\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n  this.identifierPrefix = identifierPrefix;\n  this.onRecoverableError = onRecoverableError;\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  {\n    this.memoizedUpdaters = new Set();\n    var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n\n    for (var _i = 0; _i < TotalLanes; _i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n\n  {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n        break;\n\n      case LegacyRoot:\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n        break;\n    }\n  }\n}\n\nfunction createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix, onRecoverableError, transitionCallbacks) {\n  var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n  // stateNode is any.\n\n\n  var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  {\n    var _initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: null,\n      // not enabled yet\n      transitions: null,\n      pendingSuspenseBoundaries: null\n    };\n    uninitializedFiber.memoizedState = _initialState;\n  }\n\n  initializeUpdateQueue(uninitializedFiber);\n  return root;\n}\n\nvar ReactVersion = '18.2.0';\n\nfunction createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  {\n    checkKeyStringCoercion(key);\n  }\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\nvar didWarnAboutNestedUpdates;\nvar didWarnAboutFindNodeInStrictMode;\n\n{\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    var Component = fiber.type;\n\n    if (isContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  var fiber = get(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      var keys = Object.keys(component).join(',');\n      throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n    }\n  }\n\n  var hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  {\n    var fiber = get(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        var keys = Object.keys(component).join(',');\n        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n      }\n    }\n\n    var hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictLegacyMode) {\n      var componentName = getComponentNameFromFiber(fiber) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        var previousFiber = current;\n\n        try {\n          setCurrentFiber(hostFiber);\n\n          if (fiber.mode & StrictLegacyMode) {\n            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          } else {\n            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentFiber(previousFiber);\n          } else {\n            resetCurrentFiber();\n          }\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n}\n\nfunction createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  var hydrate = false;\n  var initialChildren = null;\n  return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n}\nfunction createHydrationContainer(initialChildren, // TODO: Remove `callback` when we delete legacy mode.\ncallback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  var hydrate = true;\n  var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor\n\n  root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n  // a regular update because the initial render must match was was rendered\n  // on the server.\n  // NOTE: This update intentionally doesn't have a payload. We're only using\n  // the update to schedule work on the root fiber (and, for legacy roots, to\n  // enqueue the callback if one is provided).\n\n  var current = root.current;\n  var eventTime = requestEventTime();\n  var lane = requestUpdateLane(current);\n  var update = createUpdate(eventTime, lane);\n  update.callback = callback !== undefined && callback !== null ? callback : null;\n  enqueueUpdate(current, update, lane);\n  scheduleInitialHydrationOnRoot(root, lane, eventTime);\n  return root;\n}\nfunction updateContainer(element, container, parentComponent, callback) {\n  {\n    onScheduleRoot(container, element);\n  }\n\n  var current$1 = container.current;\n  var eventTime = requestEventTime();\n  var lane = requestUpdateLane(current$1);\n\n  {\n    markRenderScheduled(lane);\n  }\n\n  var context = getContextForSubtree(parentComponent);\n\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  {\n    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n\n      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n    }\n  }\n\n  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: element\n  };\n  callback = callback === undefined ? null : callback;\n\n  if (callback !== null) {\n    {\n      if (typeof callback !== 'function') {\n        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n\n    update.callback = callback;\n  }\n\n  var root = enqueueUpdate(current$1, update, lane);\n\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, current$1, lane, eventTime);\n    entangleTransitions(root, current$1, lane);\n  }\n\n  return lane;\n}\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n\n  if (!containerFiber.child) {\n    return null;\n  }\n\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\nfunction attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      {\n        var root = fiber.stateNode;\n\n        if (isRootDehydrated(root)) {\n          // Flush the first scheduled \"update\".\n          var lanes = getHighestPriorityPendingLanes(root);\n          flushRoot(root, lanes);\n        }\n\n        break;\n      }\n\n    case SuspenseComponent:\n      {\n        flushSync(function () {\n          var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n          if (root !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root, fiber, SyncLane, eventTime);\n          }\n        }); // If we're still blocked after this, we need to increase\n        // the priority of any promises resolving within this\n        // boundary so that they next attempt also has higher pri.\n\n        var retryLane = SyncLane;\n        markRetryLaneIfNotHydrated(fiber, retryLane);\n        break;\n      }\n  }\n}\n\nfunction markRetryLaneImpl(fiber, retryLane) {\n  var suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n  }\n} // Increases the priority of thenables when they resolve within this boundary.\n\n\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  var alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nfunction attemptDiscreteHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  var lane = SyncLane;\n  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    var eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  var lane = SelectiveHydrationLane;\n  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    var eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    var eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction findHostInstanceWithNoPortals(fiber) {\n  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nvar shouldErrorImpl = function (fiber) {\n  return null;\n};\n\nfunction shouldError(fiber) {\n  return shouldErrorImpl(fiber);\n}\n\nvar shouldSuspendImpl = function (fiber) {\n  return false;\n};\n\nfunction shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nvar overrideHookState = null;\nvar overrideHookStateDeletePath = null;\nvar overrideHookStateRenamePath = null;\nvar overrideProps = null;\nvar overridePropsDeletePath = null;\nvar overridePropsRenamePath = null;\nvar scheduleUpdate = null;\nvar setErrorHandler = null;\nvar setSuspenseHandler = null;\n\n{\n  var copyWithDeleteImpl = function (obj, path, index) {\n    var key = path[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(key, 1);\n      } else {\n        delete updated[key];\n      }\n\n      return updated;\n    } // $FlowFixMe number or string is fine here\n\n\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  var copyWithDelete = function (obj, path) {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {\n    var oldKey = oldPath[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n    if (index + 1 === oldPath.length) {\n      var newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n      updated[newKey] = updated[oldKey];\n\n      if (isArray(updated)) {\n        updated.splice(oldKey, 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here\n      obj[oldKey], oldPath, newPath, index + 1);\n    }\n\n    return updated;\n  };\n\n  var copyWithRename = function (obj, oldPath, newPath) {\n    if (oldPath.length !== newPath.length) {\n      warn('copyWithRename() expects paths of the same length');\n\n      return;\n    } else {\n      for (var i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          warn('copyWithRename() expects paths to be the same except for the deepest key');\n\n          return;\n        }\n      }\n    }\n\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  var copyWithSetImpl = function (obj, path, index, value) {\n    if (index >= path.length) {\n      return value;\n    }\n\n    var key = path[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  var copyWithSet = function (obj, path, value) {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  var findHook = function (fiber, id) {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    var currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    return currentHook;\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = function (fiber, id, path, value) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n\n  overrideHookStateDeletePath = function (fiber, id, path) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n\n  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = function (fiber, path, value) {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overridePropsDeletePath = function (fiber, path) {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overridePropsRenamePath = function (fiber, oldPath, newPath) {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  scheduleUpdate = function (fiber) {\n    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  setErrorHandler = function (newShouldErrorImpl) {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = function (newShouldSuspendImpl) {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber) {\n  var hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(instance) {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return current;\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState: overrideHookState,\n    overrideHookStateDeletePath: overrideHookStateDeletePath,\n    overrideHookStateRenamePath: overrideHookStateRenamePath,\n    overrideProps: overrideProps,\n    overridePropsDeletePath: overridePropsDeletePath,\n    overridePropsRenamePath: overridePropsRenamePath,\n    setErrorHandler: setErrorHandler,\n    setSuspenseHandler: setSuspenseHandler,\n    scheduleUpdate: scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber: findHostInstanceByFiber,\n    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh:  findHostInstancesForRefresh ,\n    scheduleRefresh:  scheduleRefresh ,\n    scheduleRoot:  scheduleRoot ,\n    setRefreshHandler:  setRefreshHandler ,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber:  getCurrentFiberForDevTools ,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion\n  });\n}\n\nexports.attemptContinuousHydration = attemptContinuousHydration;\nexports.attemptDiscreteHydration = attemptDiscreteHydration;\nexports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\nexports.attemptSynchronousHydration = attemptSynchronousHydration;\nexports.batchedUpdates = batchedUpdates;\nexports.createComponentSelector = createComponentSelector;\nexports.createContainer = createContainer;\nexports.createHasPseudoClassSelector = createHasPseudoClassSelector;\nexports.createHydrationContainer = createHydrationContainer;\nexports.createPortal = createPortal;\nexports.createRoleSelector = createRoleSelector;\nexports.createTestNameSelector = createTestNameSelector;\nexports.createTextSelector = createTextSelector;\nexports.deferredUpdates = deferredUpdates;\nexports.discreteUpdates = discreteUpdates;\nexports.findAllNodes = findAllNodes;\nexports.findBoundingRects = findBoundingRects;\nexports.findHostInstance = findHostInstance;\nexports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\nexports.findHostInstanceWithWarning = findHostInstanceWithWarning;\nexports.flushControlled = flushControlled;\nexports.flushPassiveEffects = flushPassiveEffects;\nexports.flushSync = flushSync;\nexports.focusWithin = focusWithin;\nexports.getCurrentUpdatePriority = getCurrentUpdatePriority;\nexports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\nexports.getPublicRootInstance = getPublicRootInstance;\nexports.injectIntoDevTools = injectIntoDevTools;\nexports.isAlreadyRendering = isAlreadyRendering;\nexports.observeVisibleRects = observeVisibleRects;\nexports.registerMutableSourceForHydration = registerMutableSourceForHydration;\nexports.runWithPriority = runWithPriority;\nexports.shouldError = shouldError;\nexports.shouldSuspend = shouldSuspend;\nexports.updateContainer = updateContainer;\n    return exports;\n  };\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-reconciler.production.min.js');\n} else {\n  module.exports = require('./cjs/react-reconciler.development.js');\n}\n", "/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar React = require('react');\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    {\n      if (hasOwnProperty.call(props, 'key')) {\n        var componentName = getComponentNameFromType(type);\n        var keys = Object.keys(props).filter(function (k) {\n          return k !== 'key';\n        });\n        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n        if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n          error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n          didWarnAboutKeySpread[componentName + beforeExample] = true;\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n", "import { useEffect, useState } from \"react\";\nimport {\n  reactExtension,\n  useApi,\n  AdminAction,\n  BlockStack,\n  Button,\n  Banner,\n  Link,\n  ProgressIndicator,\n} from \"@shopify/ui-extensions-react/admin\";\n\nconst TARGET = \"admin.order-details.action.render\";\n\nexport default reactExtension(TARGET, () => <App />);\n\nconst ORDER_QUERY = `\n  query Order($id: ID!) {\n    order(id: $id) {\n      name\n    }\n  }\n`;\n\nfunction App() {\n  const { close, data } = useApi(TARGET);\n  const orderId = data.selected?.[0]?.id;\n\n  const [order, setOrder] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!orderId) return;\n    (async () => {\n      try {\n        const res = await fetch(\"shopify:admin/api/graphql.json\", {\n          method: \"POST\",\n          body: JSON.stringify({ query: ORDER_QUERY, variables: { id: orderId } }),\n        });\n        const json = await res.json();\n        const orderData = json.data?.order;\n        if (!orderData) throw new Error(\"Order not found\");\n        setOrder(orderData);\n      } catch (e) {\n        setError(e.message);\n      } finally {\n        setLoading(false);\n      }\n    })();\n  }, [orderId]);\n\n  if (loading) {\n    return (\n      <AdminAction title=\"Open in Workflow Admin\">\n        <BlockStack inlineAlignment=\"center\" padding=\"large400\">\n          <ProgressIndicator size=\"small-200\" />\n        </BlockStack>\n      </AdminAction>\n    );\n  }\n\n  if (error || !order) {\n    return (\n      <AdminAction\n        title=\"Open in Workflow Admin\"\n        secondaryAction={<Button onPress={close}>Close</Button>}\n      >\n        <Banner tone=\"critical\">{error || \"Order not found\"}</Banner>\n      </AdminAction>\n    );\n  }\n\n  const orderNumber = order.name.replace(/^#/, \"\");\n\n  return (\n    <AdminAction\n      title=\"Open in Workflow Admin\"\n      primaryAction={<Link href={`app:?q=${orderNumber}`}>Open {order.name}</Link>}\n      secondaryAction={<Button onPress={close}>Close</Button>}\n    />\n  );\n}\n", "import { RETAINED_BY, RETAIN_METHOD, RELEASE_METHOD } from './types.mjs';\nexport { RELEASE_METHOD, RETAINED_BY, RETAIN_METHOD } from './types.mjs';\n\nclass StackFrame {\n  constructor() {\n    this.memoryManaged = new Set();\n  }\n\n  add(memoryManageable) {\n    this.memoryManaged.add(memoryManageable);\n    memoryManageable[RETAINED_BY].add(this);\n    memoryManageable[RETAIN_METHOD]();\n  }\n\n  release() {\n    for (const memoryManaged of this.memoryManaged) {\n      memoryManaged[RETAINED_BY].delete(this);\n      memoryManaged[RELEASE_METHOD]();\n    }\n\n    this.memoryManaged.clear();\n  }\n\n}\nfunction isMemoryManageable(value) {\n  return Boolean(value && value[RETAIN_METHOD] && value[RELEASE_METHOD]);\n}\nfunction retain(value, {\n  deep = true\n} = {}) {\n  return retainInternal(value, deep, new Map());\n}\n\nfunction retainInternal(value, deep, seen) {\n  const seenValue = seen.get(value);\n  if (seenValue != null) return seenValue;\n  const canRetain = isMemoryManageable(value);\n\n  if (canRetain) {\n    value[RETAIN_METHOD]();\n  }\n\n  seen.set(value, canRetain);\n\n  if (deep) {\n    if (Array.isArray(value)) {\n      const nestedCanRetain = value.reduce((canRetain, item) => retainInternal(item, deep, seen) || canRetain, canRetain);\n      seen.set(value, nestedCanRetain);\n      return nestedCanRetain;\n    }\n\n    if (isBasicObject(value)) {\n      const nestedCanRetain = Object.keys(value).reduce((canRetain, key) => retainInternal(value[key], deep, seen) || canRetain, canRetain);\n      seen.set(value, nestedCanRetain);\n      return nestedCanRetain;\n    }\n  }\n\n  seen.set(value, canRetain);\n  return canRetain;\n}\n\nfunction release(value, {\n  deep = true\n} = {}) {\n  return releaseInternal(value, deep, new Map());\n}\nfunction releaseInternal(value, deep, seen) {\n  const seenValue = seen.get(value);\n  if (seenValue != null) return seenValue;\n  const canRelease = isMemoryManageable(value);\n\n  if (canRelease) {\n    value[RELEASE_METHOD]();\n  }\n\n  seen.set(value, canRelease);\n\n  if (deep) {\n    if (Array.isArray(value)) {\n      const nestedCanRelease = value.reduce((canRelease, item) => releaseInternal(item, deep, seen) || canRelease, canRelease);\n      seen.set(value, nestedCanRelease);\n      return nestedCanRelease;\n    }\n\n    if (isBasicObject(value)) {\n      const nestedCanRelease = Object.keys(value).reduce((canRelease, key) => releaseInternal(value[key], deep, seen) || canRelease, canRelease);\n      seen.set(value, nestedCanRelease);\n      return nestedCanRelease;\n    }\n  }\n\n  return canRelease;\n}\nfunction isBasicObject(value) {\n  if (value == null || typeof value !== 'object') return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype == null || prototype === Object.prototype;\n}\n\nexport { StackFrame, isBasicObject, isMemoryManageable, release, releaseInternal, retain };\n", "import { KIND_COMPONENT, KIND_TEXT, KIND_FRAGMENT } from './types.mjs';\n\nfunction isRemoteComponent(child) {\n  return child != null && child.kind === KIND_COMPONENT;\n}\nfunction isRemoteText(child) {\n  return child != null && child.kind === KIND_TEXT;\n}\nfunction isRemoteFragment(object) {\n  return object != null && object.kind === KIND_FRAGMENT;\n}\n\nexport { isRemoteComponent, isRemoteFragment, isRemoteText };\n", "import { isBasicObject } from '@remote-ui/rpc';\nimport { KIND_ROOT, ACTION_MOUNT, ACTION_INSERT_CHILD, KIND_TEXT, ACTION_REMOVE_CHILD, KIND_COMPONENT, KIND_FRAGMENT, ACTION_UPDATE_PROPS, ACTION_UPDATE_TEXT } from './types.mjs';\nimport { isRemoteFragment } from './utilities.mjs';\n\nconst FUNCTION_CURRENT_IMPLEMENTATION_KEY = '__current';\nconst EMPTY_OBJECT = {};\nconst EMPTY_ARRAY = [];\nfunction createRemoteRoot(channel, {\n  strict = true,\n  components\n} = {}) {\n  let currentId = 0;\n  const rootInternals = {\n    strict,\n    mounted: false,\n    channel,\n    children: EMPTY_ARRAY,\n    nodes: new WeakSet(),\n    parents: new WeakMap(),\n    tops: new WeakMap(),\n    components: new WeakMap(),\n    fragments: new WeakMap()\n  };\n  if (strict) Object.freeze(components);\n  const remoteRoot = {\n    kind: KIND_ROOT,\n    options: strict ? Object.freeze({\n      strict,\n      components\n    }) : {\n      strict,\n      components\n    },\n\n    get children() {\n      return rootInternals.children;\n    },\n\n    createComponent(type, ...rest) {\n      if (components && components.indexOf(type) < 0) {\n        throw new Error(`Unsupported component: ${type}`);\n      }\n\n      const [initialProps, initialChildren, ...moreChildren] = rest;\n      const normalizedInitialProps = initialProps !== null && initialProps !== void 0 ? initialProps : {};\n      const normalizedInitialChildren = [];\n      const normalizedInternalProps = {};\n\n      if (initialProps) {\n        for (const key of Object.keys(initialProps)) {\n          // \"children\" as a prop can be extremely confusing with the \"children\" of\n          // a component. In React, a \"child\" can be anything, but once it reaches\n          // a host environment (like this remote `Root`), we want \"children\" to have\n          // only one meaning: the actual, resolved children components and text.\n          //\n          // To enforce this, we delete any prop named \"children\". We don\u2019t take a copy\n          // of the props for performance, so a user calling this function must do so\n          // with an object that can handle being mutated.\n          if (key === 'children') continue;\n          normalizedInternalProps[key] = makeValueHotSwappable(serializeProp(initialProps[key]));\n        }\n      }\n\n      if (initialChildren) {\n        if (Array.isArray(initialChildren)) {\n          for (const child of initialChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        } else {\n          normalizedInitialChildren.push(normalizeChild(initialChildren, remoteRoot)); // The complex tuple type of `rest` makes it so `moreChildren` is\n          // incorrectly inferred as potentially being the props of the component,\n          // lazy casting since we know it will be an array of child elements\n          // (or empty).\n\n          for (const child of moreChildren) {\n            normalizedInitialChildren.push(normalizeChild(child, remoteRoot));\n          }\n        }\n      }\n\n      const id = `${currentId++}`;\n      const internals = {\n        externalProps: strict ? Object.freeze(normalizedInitialProps) : normalizedInitialProps,\n        internalProps: normalizedInternalProps,\n        children: strict ? Object.freeze(normalizedInitialChildren) : normalizedInitialChildren\n      };\n      const component = {\n        kind: KIND_COMPONENT,\n\n        get children() {\n          return internals.children;\n        },\n\n        get props() {\n          return internals.externalProps;\n        },\n\n        get remoteProps() {\n          return internals.internalProps;\n        },\n\n        remove: () => remove(component),\n        updateProps: newProps => updateProps(component, newProps, internals, rootInternals),\n        append: (...children) => append(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(component, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(component, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(component, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually, which we do below. If we just `as any`\n        // the whole object, we lose the implicit argument types for the\n        // methods above.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.components.set(component, internals);\n      Object.defineProperty(component, 'type', {\n        value: type,\n        configurable: false,\n        writable: false,\n        enumerable: true\n      });\n      makePartOfTree(component, rootInternals);\n      makeRemote(component, id, remoteRoot);\n\n      for (const child of internals.children) {\n        moveNodeToContainer(component, child, rootInternals);\n      }\n\n      return component;\n    },\n\n    createText(content = '') {\n      const id = `${currentId++}`;\n      const internals = {\n        text: content\n      };\n\n      const update = newText => updateText(text, newText, internals, rootInternals);\n\n      const text = {\n        kind: KIND_TEXT,\n\n        get text() {\n          return internals.text;\n        },\n\n        update,\n        updateText: update,\n        remove: () => remove(text),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      makePartOfTree(text, rootInternals);\n      makeRemote(text, id, remoteRoot);\n      return text;\n    },\n\n    createFragment() {\n      const id = `${currentId++}`;\n      const internals = {\n        children: strict ? Object.freeze([]) : []\n      };\n      const fragment = {\n        kind: KIND_FRAGMENT,\n\n        get children() {\n          return internals.children;\n        },\n\n        append: (...children) => append(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        appendChild: child => appendChild(fragment, normalizeChild(child, remoteRoot), internals, rootInternals),\n        removeChild: child => removeChild(fragment, child, internals, rootInternals),\n        replaceChildren: (...children) => replaceChildren(fragment, children.map(child => normalizeChild(child, remoteRoot)), internals, rootInternals),\n        insertBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        insertChildBefore: (child, before) => insertBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals),\n        // Just satisfying the type definition, since we need to write\n        // some properties manually.\n        ...EMPTY_OBJECT\n      };\n      rootInternals.fragments.set(fragment, internals);\n      makePartOfTree(fragment, rootInternals);\n      makeRemote(fragment, id, remoteRoot);\n      return fragment;\n    },\n\n    append: (...children) => append(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    appendChild: child => appendChild(remoteRoot, normalizeChild(child, remoteRoot), rootInternals, rootInternals),\n    replaceChildren: (...children) => replaceChildren(remoteRoot, children.map(child => normalizeChild(child, remoteRoot)), rootInternals, rootInternals),\n    removeChild: child => removeChild(remoteRoot, child, rootInternals, rootInternals),\n    insertBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n    insertChildBefore: (child, before) => insertBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals),\n\n    mount() {\n      if (rootInternals.mounted) return Promise.resolve();\n      rootInternals.mounted = true;\n      return Promise.resolve(channel(ACTION_MOUNT, rootInternals.children.map(serializeChild)));\n    }\n\n  };\n  return remoteRoot;\n}\n\nfunction connected(element, {\n  tops\n}) {\n  var _tops$get;\n\n  return ((_tops$get = tops.get(element)) === null || _tops$get === void 0 ? void 0 : _tops$get.kind) === KIND_ROOT;\n}\n\nfunction allDescendants(element, withEach) {\n  const recurse = element => {\n    if ('children' in element) {\n      for (const child of element.children) {\n        withEach(child);\n        recurse(child);\n      }\n    }\n  };\n\n  recurse(element);\n}\n\nfunction perform(element, rootInternals, {\n  remote,\n  local\n}) {\n  const {\n    mounted,\n    channel\n  } = rootInternals;\n\n  if (mounted && (element.kind === KIND_ROOT || connected(element, rootInternals))) {\n    // should only create context once async queue is cleared\n    remote(channel); // technically, we should be waiting for the remote update to apply,\n    // then apply it locally. The implementation below is too naive because\n    // it allows local updates to get out of sync with remote ones.\n    // if (remoteResult == null || !('then' in remoteResult)) {\n    //   local();\n    //   return;\n    // } else {\n    //   return remoteResult.then(() => {\n    //     local();\n    //   });\n    // }\n  }\n\n  local();\n}\n\nfunction updateText(text, newText, internals, rootInternals) {\n  return perform(text, rootInternals, {\n    remote: channel => channel(ACTION_UPDATE_TEXT, text.id, newText),\n    local: () => {\n      internals.text = newText;\n    }\n  });\n}\n\nconst IGNORE = Symbol('ignore');\n\nfunction updateProps(component, newProps, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  const {\n    internalProps: currentProps,\n    externalProps: currentExternalProps\n  } = internals;\n  const normalizedNewProps = {};\n  const hotSwapFunctions = [];\n  let hasRemoteChange = false;\n\n  for (const key of Object.keys(newProps)) {\n    // See notes above for why we treat `children` as a reserved prop.\n    if (key === 'children') continue;\n    const currentExternalValue = currentExternalProps[key];\n    const newExternalValue = newProps[key];\n    const currentValue = currentProps[key];\n    const newValue = serializeProp(newExternalValue); // Bail out if we have equal, primitive types\n\n    if (currentValue === newValue && (newValue == null || typeof newValue !== 'object')) {\n      continue;\n    }\n\n    const [value, hotSwaps] = tryHotSwappingValues(currentValue, newValue);\n\n    if (hotSwaps) {\n      hotSwapFunctions.push(...hotSwaps);\n    }\n\n    if (value === IGNORE) continue;\n    hasRemoteChange = true;\n    normalizedNewProps[key] = value;\n\n    if (isRemoteFragment(currentExternalValue)) {\n      removeNodeFromContainer(currentExternalValue, rootInternals);\n    }\n\n    if (isRemoteFragment(newExternalValue)) {\n      moveNodeToContainer(component, newExternalValue, rootInternals);\n    }\n  }\n\n  return perform(component, rootInternals, {\n    remote: channel => {\n      if (hasRemoteChange) {\n        channel(ACTION_UPDATE_PROPS, component.id, normalizedNewProps);\n      }\n    },\n    local: () => {\n      const mergedExternalProps = { ...currentExternalProps,\n        ...newProps\n      };\n      internals.externalProps = strict ? Object.freeze(mergedExternalProps) : mergedExternalProps;\n      internals.internalProps = { ...internals.internalProps,\n        ...normalizedNewProps\n      };\n\n      for (const [hotSwappable, newValue] of hotSwapFunctions) {\n        hotSwappable[FUNCTION_CURRENT_IMPLEMENTATION_KEY] = newValue;\n      }\n    }\n  });\n} // Imagine the following remote-ui components we might render in a remote context:\n//\n// const root = createRemoteRoot();\n// const {value, onChange, onPress} = getPropsForValue();\n//\n// const textField = root.createComponent('TextField', {value, onChange});\n// const button = root.createComponent('Button', {onPress});\n//\n// root.append(textField);\n// root.append(button);\n//\n// function getPropsForValue(value = '') {\n//   return {\n//     value,\n//     onChange: () => {\n//       const {value, onChange, onPress} = getPropsForValue();\n//       textField.updateProps({value, onChange});\n//       button.updateProps({onPress});\n//     },\n//     onPress: () => console.log(value),\n//   };\n// }\n//\n//\n// In this example, assume that the `TextField` `onChange` prop is run on blur.\n// If this were running on the host, the following steps would happen if you pressed\n// on the button:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value, which\n//    then calls `setValue()` with the updated value.\n// 2. We synchronously update the `value`, `onChange`, and `onPress` props to point at\n//    the most current `value`.\n// 3. Handling blur is finished, so the browser now handles the click by calling the\n//    (newly-updated) `Button` `onPress()`, which logs out the new value.\n//\n// Because remote-ui reproduces a UI tree asynchronously from the remote context, the\n// steps above run in a different order:\n//\n// 1. The text field blurs, and so calls `onChange()` with its current value.\n// 2. Handling blur is finished **from the perspective of the main thread**, so the\n//    browser now handles the click by calling the (original) `Button` `onPress()`, which\n//    logs out the **initial** value.\n// 3. In the remote context, we receive the `onChange()` call, which calls updates the props\n//    on the `Button` and `TextField` to be based on the new `value`, but by now it\u2019s\n//    already too late for `onPress` \u2014 the old version has already been called!\n//\n// As you can see, the timing issue introduced by the asynchronous nature of remote-ui\n// can cause \u201Cold props\u201D to be called from the main thread. This example may seem like\n// an unusual pattern, and it is if you are using `@remote-ui/core` directly; you\u2019d generally\n// keep a mutable reference to the state, instead of closing over the state with new props.\n// However, abstractions on top of `@remote-ui/core`, like the React reconciler in\n// `@remote-ui/react`, work almost entirely by closing over state, so this issue is\n// much more common with those declarative libraries.\n//\n// To protect against this, we handle function props a bit differently. When we have a\n// function prop, we replace it with a new function that calls the original. However,\n// we make the original mutable, by making it a property on the function itself. When\n// this function subsequently updates, we don\u2019t send the update to the main thread (as\n// we just saw, this can often be \"too late\" to be of any use). Instead, we swap out\n// the mutable reference to the current implementation of the function prop, which can\n// be done synchronously. In the example above, this would all happen synchronously in\n// the remote context; in our handling of `TextField onChange()`, we update `Button onPress()`,\n// and swap out the implementations. Now, when the main thread attempts to call `Button onPress()`,\n// it instead calls our wrapper around the function, which can refer to, and call, the\n// most recently-applied implementation, instead of directly calling the old implementation.\n\n\nfunction tryHotSwappingValues(currentValue, newValue, seen = new Set()) {\n  if (seen.has(currentValue)) {\n    return [IGNORE];\n  }\n\n  if (typeof currentValue === 'function' && FUNCTION_CURRENT_IMPLEMENTATION_KEY in currentValue) {\n    seen.add(currentValue);\n    const result = [typeof newValue === 'function' ? IGNORE : makeValueHotSwappable(newValue), [[currentValue, newValue]]];\n    return result;\n  }\n\n  if (Array.isArray(currentValue)) {\n    seen.add(currentValue);\n    const result = tryHotSwappingArrayValues(currentValue, newValue, seen);\n    return result;\n  }\n\n  if (isBasicObject(currentValue) && !isRemoteFragment(currentValue)) {\n    seen.add(currentValue);\n    const result = tryHotSwappingObjectValues(currentValue, newValue, seen);\n    return result;\n  }\n\n  const result = [currentValue === newValue ? IGNORE : newValue];\n  return result;\n}\n\nfunction makeValueHotSwappable(value, seen = new Map()) {\n  const seenValue = seen.get(value);\n  if (seenValue) return seenValue;\n\n  if (isRemoteFragment(value)) {\n    seen.set(value, value);\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    const result = [];\n    seen.set(value, result);\n\n    for (const nested of value) {\n      result.push(makeValueHotSwappable(nested, seen));\n    }\n\n    return result;\n  }\n\n  if (isBasicObject(value)) {\n    const result = {};\n    seen.set(value, result);\n\n    for (const key of Object.keys(value)) {\n      result[key] = makeValueHotSwappable(value[key], seen);\n    }\n\n    return result;\n  }\n\n  if (typeof value === 'function') {\n    const wrappedFunction = (...args) => {\n      return wrappedFunction[FUNCTION_CURRENT_IMPLEMENTATION_KEY](...args);\n    };\n\n    Object.defineProperty(wrappedFunction, FUNCTION_CURRENT_IMPLEMENTATION_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value\n    });\n    seen.set(value, wrappedFunction);\n    return wrappedFunction;\n  }\n\n  return value;\n}\n\nfunction collectNestedHotSwappableValues(value, seen = new Set()) {\n  if (seen.has(value)) return undefined;\n  seen.add(value);\n\n  if (Array.isArray(value)) {\n    return value.reduce((all, element) => {\n      const nested = collectNestedHotSwappableValues(element, seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n\n  if (isBasicObject(value)) {\n    return Object.keys(value).reduce((all, key) => {\n      const nested = collectNestedHotSwappableValues(value[key], seen);\n      return nested ? [...all, ...nested] : all;\n    }, []);\n  }\n\n  if (typeof value === 'function') {\n    return FUNCTION_CURRENT_IMPLEMENTATION_KEY in value ? [value] : undefined;\n  }\n\n  return undefined;\n}\n\nfunction remove(child) {\n  var _child$parent;\n\n  (_child$parent = child.parent) === null || _child$parent === void 0 ? void 0 : _child$parent.removeChild(child);\n}\n\nfunction append(container, children, internals, rootInternals) {\n  for (const child of children) {\n    appendChild(container, child, internals, rootInternals);\n  }\n}\n\nfunction appendChild(container, child, internals, rootInternals) {\n  var _currentParent$childr;\n\n  const {\n    nodes,\n    strict\n  } = rootInternals;\n\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot append a node that was not created by this remote root`);\n  }\n\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr !== void 0 ? _currentParent$childr : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      channel(ACTION_INSERT_CHILD, container.id, existingIndex < 0 ? container.children.length : container.children.length - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n\n      newChildren.push(child);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction replaceChildren(container, children, internals, rootInternals) {\n  for (const child of container.children) {\n    removeChild(container, child, internals, rootInternals);\n  }\n\n  append(container, children, internals, rootInternals);\n} // there is a problem with this, because when multiple children\n// are removed, there is no guarantee the messages will arrive in the\n// order we need them to on the host side (it depends how React\n// calls our reconciler). If it calls with, for example, the removal of\n// the second last item, then the removal of the last item, it will fail\n// because the indexes moved around.\n//\n// Might need to send the removed child ID, or find out if we\n// can collect removals into a single update.\n\n\nfunction removeChild(container, child, internals, rootInternals) {\n  const {\n    strict\n  } = rootInternals;\n  const childIndex = container.children.indexOf(child);\n\n  if (childIndex === -1) {\n    return undefined;\n  }\n\n  return perform(container, rootInternals, {\n    remote: channel => channel(ACTION_REMOVE_CHILD, container.id, childIndex),\n    local: () => {\n      removeNodeFromContainer(child, rootInternals);\n      const newChildren = [...internals.children];\n      newChildren.splice(newChildren.indexOf(child), 1);\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction insertBefore(container, child, before, internals, rootInternals) {\n  var _currentParent$childr2;\n\n  const {\n    strict,\n    nodes\n  } = rootInternals;\n\n  if (!nodes.has(child)) {\n    throw new Error(`Cannot insert a node that was not created by this remote root`);\n  }\n\n  const currentParent = child.parent;\n  const existingIndex = (_currentParent$childr2 = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children.indexOf(child)) !== null && _currentParent$childr2 !== void 0 ? _currentParent$childr2 : -1;\n  return perform(container, rootInternals, {\n    remote: channel => {\n      const beforeIndex = before == null ? container.children.length - 1 : container.children.indexOf(before);\n      channel(ACTION_INSERT_CHILD, container.id, beforeIndex < existingIndex || existingIndex < 0 ? beforeIndex : beforeIndex - 1, serializeChild(child), currentParent ? currentParent.id : false);\n    },\n    local: () => {\n      moveNodeToContainer(container, child, rootInternals);\n      let newChildren;\n\n      if (currentParent) {\n        const currentInternals = getCurrentInternals(currentParent, rootInternals);\n        const currentChildren = [...currentInternals.children];\n        currentChildren.splice(existingIndex, 1);\n\n        if (currentParent === container) {\n          newChildren = currentChildren;\n        } else {\n          currentInternals.children = strict ? Object.freeze(currentChildren) : currentChildren;\n          newChildren = [...internals.children];\n        }\n      } else {\n        newChildren = [...internals.children];\n      }\n\n      if (before == null) {\n        newChildren.push(child);\n      } else {\n        newChildren.splice(newChildren.indexOf(before), 0, child);\n      }\n\n      internals.children = strict ? Object.freeze(newChildren) : newChildren;\n    }\n  });\n}\n\nfunction normalizeChild(child, root) {\n  return typeof child === 'string' ? root.createText(child) : child;\n}\n\nfunction moveNodeToContainer(container, node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  const newTop = container.kind === KIND_ROOT ? container : tops.get(container);\n  tops.set(node, newTop);\n  parents.set(node, container);\n  moveFragmentToContainer(node, rootInternals);\n  allDescendants(node, descendant => {\n    tops.set(descendant, newTop);\n    moveFragmentToContainer(descendant, rootInternals);\n  });\n}\n\nfunction moveFragmentToContainer(node, rootInternals) {\n  if (node.kind !== KIND_COMPONENT) return;\n  const props = node.props;\n  if (!props) return;\n  Object.values(props).forEach(prop => {\n    if (!isRemoteFragment(prop)) return;\n    moveNodeToContainer(node, prop, rootInternals);\n  });\n}\n\nfunction removeNodeFromContainer(node, rootInternals) {\n  const {\n    tops,\n    parents\n  } = rootInternals;\n  tops.delete(node);\n  parents.delete(node);\n  allDescendants(node, descendant => {\n    tops.delete(descendant);\n    removeFragmentFromContainer(descendant, rootInternals);\n  });\n  removeFragmentFromContainer(node, rootInternals);\n}\n\nfunction removeFragmentFromContainer(node, rootInternals) {\n  if (node.kind !== KIND_COMPONENT) return;\n  const props = node.remoteProps;\n\n  for (const key of Object.keys(props !== null && props !== void 0 ? props : {})) {\n    const prop = props[key];\n    if (!isRemoteFragment(prop)) continue;\n    removeNodeFromContainer(prop, rootInternals);\n  }\n}\n\nfunction makePartOfTree(node, {\n  parents,\n  tops,\n  nodes\n}) {\n  nodes.add(node);\n  Object.defineProperty(node, 'parent', {\n    get() {\n      return parents.get(node);\n    },\n\n    configurable: true,\n    enumerable: true\n  });\n  Object.defineProperty(node, 'top', {\n    get() {\n      return tops.get(node);\n    },\n\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction serializeChild(value) {\n  return value.kind === KIND_TEXT ? {\n    id: value.id,\n    kind: value.kind,\n    text: value.text\n  } : {\n    id: value.id,\n    kind: value.kind,\n    type: value.type,\n    props: value.remoteProps,\n    children: value.children.map(child => serializeChild(child))\n  };\n}\n\nfunction serializeProp(prop) {\n  if (isRemoteFragment(prop)) {\n    return serializeFragment(prop);\n  }\n\n  return prop;\n}\n\nfunction serializeFragment(value) {\n  return {\n    id: value.id,\n    kind: value.kind,\n\n    get children() {\n      return value.children.map(child => serializeChild(child));\n    }\n\n  };\n}\n\nfunction getCurrentInternals(currentParent, rootInternals) {\n  if (currentParent.kind === KIND_ROOT) {\n    return rootInternals;\n  }\n\n  if (currentParent.kind === KIND_FRAGMENT) {\n    return rootInternals.fragments.get(currentParent);\n  }\n\n  return rootInternals.components.get(currentParent);\n}\n\nfunction makeRemote(value, id, root) {\n  Object.defineProperty(value, 'id', {\n    value: id,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n  Object.defineProperty(value, 'root', {\n    value: root,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\n\nfunction tryHotSwappingObjectValues(currentValue, newValue, seen) {\n  if (!isBasicObject(newValue)) {\n    var _collectNestedHotSwap;\n\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap === void 0 ? void 0 : _collectNestedHotSwap.map(hotSwappable => [hotSwappable, undefined])];\n  }\n\n  let hasChanged = false;\n  const hotSwaps = [];\n  const normalizedNewValue = {}; // eslint-disable-next-line guard-for-in\n\n  for (const key in currentValue) {\n    const currentObjectValue = currentValue[key];\n\n    if (!(key in newValue)) {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentObjectValue);\n\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n\n    const newObjectValue = newValue[key];\n    const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentObjectValue, newObjectValue, seen);\n\n    if (elementHotSwaps) {\n      hotSwaps.push(...elementHotSwaps);\n    }\n\n    if (updatedValue !== IGNORE) {\n      hasChanged = true;\n      normalizedNewValue[key] = updatedValue;\n    }\n  }\n\n  for (const key in newValue) {\n    if (key in normalizedNewValue) continue;\n    hasChanged = true;\n    normalizedNewValue[key] = makeValueHotSwappable(newValue[key]);\n  }\n\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\n\nfunction tryHotSwappingArrayValues(currentValue, newValue, seen) {\n  if (!Array.isArray(newValue)) {\n    var _collectNestedHotSwap2;\n\n    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap2 = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap2 === void 0 ? void 0 : _collectNestedHotSwap2.map(hotSwappable => [hotSwappable, undefined])];\n  }\n\n  let hasChanged = false;\n  const hotSwaps = [];\n  const newLength = newValue.length;\n  const currentLength = currentValue.length;\n  const maxLength = Math.max(currentLength, newLength);\n  const normalizedNewValue = [];\n\n  for (let i = 0; i < maxLength; i++) {\n    const currentArrayValue = currentValue[i];\n    const newArrayValue = newValue[i];\n\n    if (i < newLength) {\n      if (i >= currentLength) {\n        hasChanged = true;\n        normalizedNewValue[i] = makeValueHotSwappable(newArrayValue);\n        continue;\n      }\n\n      const [updatedValue, elementHotSwaps] = tryHotSwappingValues(currentArrayValue, newArrayValue, seen);\n      if (elementHotSwaps) hotSwaps.push(...elementHotSwaps);\n\n      if (updatedValue === IGNORE) {\n        normalizedNewValue[i] = currentArrayValue;\n        continue;\n      }\n\n      hasChanged = true;\n      normalizedNewValue[i] = updatedValue;\n    } else {\n      hasChanged = true;\n      const nestedHotSwappables = collectNestedHotSwappableValues(currentArrayValue);\n\n      if (nestedHotSwappables) {\n        hotSwaps.push(...nestedHotSwappables.map(hotSwappable => [hotSwappable, undefined]));\n      }\n    }\n  }\n\n  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];\n}\n\nexport { createRemoteRoot };\n", "import { createRemoteRoot } from '@remote-ui/core';\n\n/**\n * This function takes an extension function that is expecting a `RemoteRoot` as its\n * first argument, and returns a new function that accepts a `RemoteChannel` instead.\n * This is a convenience that allows the raw UI extension API to only expose the simpler\n * `RemoteChannel` type, while allowing the extension to use the more powerful `RemoteRoot`,\n * provided by a version of `@remote-ui/core` that the extension controls.\n */\nfunction createExtensionRegistrationFunction() {\n  const extensionWrapper = (target, implementation) => {\n    var _shopify;\n    async function extension(...args) {\n      // Rendering extensions have two arguments. Non-rendering extensions don\u2019t have\n      // a `RemoteChannel` that needs to be normalized, so we can just pass the arguments\n      // through.\n      if (args.length === 1) {\n        return implementation(...args);\n      }\n      const [{\n        channel,\n        components\n      }, api] = args;\n      const root = createRemoteRoot(channel, {\n        components,\n        strict: true\n      });\n      let renderResult = implementation(root, api);\n      if (typeof renderResult === 'object' && renderResult != null && 'then' in renderResult) {\n        renderResult = await renderResult;\n      }\n      root.mount();\n      return renderResult;\n    }\n    (_shopify = globalThis.shopify) === null || _shopify === void 0 ? void 0 : _shopify.extend(target, extension);\n    return extension;\n  };\n  return extensionWrapper;\n}\n\nexport { createExtensionRegistrationFunction };\n", "import { createExtensionRegistrationFunction } from '../../utilities/registration.mjs';\n\nconst extension = createExtensionRegistrationFunction();\nconst extend = extension;\n\nexport { extend, extension };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\n/**\n * AdminAction is a component used by Admin Action extensions to configure a primary and secondary action and title.\n */\nconst AdminAction = createRemoteComponent('AdminAction');\n\nexport { AdminAction };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\nconst Banner = createRemoteComponent('Banner');\n\nexport { Banner };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\nconst BlockStack = createRemoteComponent('BlockStack');\n\nexport { BlockStack };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\nconst Button = createRemoteComponent('Button');\n\nexport { Button };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\nconst Link = createRemoteComponent('Link');\n\nexport { Link };\n", "import { createRemoteComponent } from '@remote-ui/core';\n\nconst ProgressIndicator = createRemoteComponent('ProgressIndicator');\n\nexport { ProgressIndicator };\n", "import { createContext } from 'react';\n\nconst ExtensionApiContext = /*#__PURE__*/createContext(null);\n\nexport { ExtensionApiContext };\n", "import { version } from 'react';\nimport { createReconciler } from './reconciler.mjs';\nimport { RenderContext } from './context.mjs';\nimport { jsx } from 'react/jsx-runtime';\n\nconst cache = new WeakMap(); // @see https://github.com/facebook/react/blob/fea6f8da6ab669469f2fa3f18bd3a831f00ab284/packages/react-reconciler/src/ReactRootTags.js#L12\n// We don't support concurrent rendering for now.\n\nconst LEGACY_ROOT = 0;\nconst defaultReconciler = createReconciler();\nfunction createRoot(root) {\n  return {\n    render(children) {\n      render(children, root);\n    },\n\n    unmount() {\n      if (!cache.has(root)) return;\n      render(null, root);\n      cache.delete(root);\n    }\n\n  };\n}\n/**\n * @deprecated Use `createRoot` for a React 18-style rendering API.\n */\n\nfunction render(element, root, callback, reconciler = defaultReconciler) {\n  // First, check if we've already cached a container and render context for this root\n  let cached = cache.get(root);\n\n  if (!cached) {\n    var _version$split;\n\n    const major = Number(((_version$split = version.split('.')) === null || _version$split === void 0 ? void 0 : _version$split[0]) || 18); // Since we haven't created a container for this root yet, create a new one\n\n    const value = {\n      container: major >= 18 ? reconciler.createContainer(root, LEGACY_ROOT, null, false, null, // Might not be necessary\n      'r-ui', () => null, null) : // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - this is to support React 17\n      reconciler.createContainer(root, LEGACY_ROOT, false, null),\n      // We also cache the render context to avoid re-creating it on subsequent render calls\n      renderContext: {\n        root,\n        reconciler\n      }\n    }; // Store the container and render context for retrieval on subsequent render calls\n\n    cache.set(root, value);\n    cached = value;\n  }\n\n  const {\n    container,\n    renderContext\n  } = cached; // callback is cast here because the typings do not mark that argument\n  // as optional, even though it is.\n\n  reconciler.updateContainer(element && /*#__PURE__*/jsx(RenderContext.Provider, {\n    value: renderContext,\n    children: element\n  }), container, null, callback); // Did not work for me because (I think?) it is done by the worker\n  // and therefore has an entirely different React.\n  //\n  // Original code was from:\n  // @see https://github.com/facebook/react/issues/16666\n  // @see https://github.com/michalochman/react-pixi-fiber/pull/148\n  //\n  // reconciler.injectIntoDevTools({\n  //   bundleType: 1,\n  //   findFiberByHostInstance: reconciler.findFiberByHostInstance,\n  //   rendererPackageName: '@remote-ui/react',\n  //   version: '16.9.0',\n  // });\n}\n\nexport { createRoot, render };\n", "import reactReconciler from 'react-reconciler';\n\nconst createReconciler = options => {\n  var _options$primary;\n\n  return reactReconciler({\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - Compat for React <= 17.x\n    now: Date.now,\n    // Timeout\n    scheduleTimeout: setTimeout,\n    cancelTimeout: clearTimeout,\n    noTimeout: false,\n    // Microtask scheduling\n    // @see https://github.com/facebook/react/blob/2c8a1452b82b9ec5ebfa3f370b31fda19610ae92/packages/react-dom/src/client/ReactDOMHostConfig.js#L391-L401\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - types in `@types/react-reconciler` are outdated\n    supportsMicrotasks: true,\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - types in `@types/react-reconciler` are outdated\n    scheduleMicrotask,\n    // Compat for React <= 17.x\n    queueMicrotask: scheduleMicrotask,\n    isPrimaryRenderer: (_options$primary = options === null || options === void 0 ? void 0 : options.primary) !== null && _options$primary !== void 0 ? _options$primary : true,\n    supportsMutation: true,\n    supportsHydration: false,\n    supportsPersistence: false,\n\n    // Context\n    getRootHostContext() {\n      return {};\n    },\n\n    getChildHostContext(context) {\n      return context;\n    },\n\n    // Instances\n    createTextInstance(text, root) {\n      return root.createText(text);\n    },\n\n    createInstance(type, allProps, root) {\n      const {\n        children: _children,\n        ...props\n      } = allProps;\n      return root.createComponent(type, props);\n    },\n\n    // Updates\n    commitTextUpdate(text, _oldText, newText) {\n      text.update(newText);\n    },\n\n    prepareUpdate(_instance, _type, oldProps, newProps) {\n      const updateProps = {};\n      let needsUpdate = false;\n\n      for (const key in oldProps) {\n        if (!has(oldProps, key) || key === 'children') {\n          continue;\n        }\n\n        if (!(key in newProps)) {\n          needsUpdate = true;\n          updateProps[key] = undefined; // } else if (typeof oldProps[key] === 'function') {\n          //   if (typeof newProps[key] === 'function') {\n          //     fragment.controller.functions.exchange(\n          //       oldProps[key] as Function,\n          //       newProps[key] as Function,\n          //     );\n          //   } else {\n          //     needsUpdate = true;\n          //     fragment.controller.functions.revoke(oldProps[key] as Function);\n          //     updateProps[key] = newProps[key];\n          //   }\n        } else if (oldProps[key] !== newProps[key]) {\n          needsUpdate = true;\n          updateProps[key] = newProps[key];\n        }\n      }\n\n      for (const key in newProps) {\n        if (!has(newProps, key) || key === 'children') {\n          continue;\n        }\n\n        if (!(key in oldProps)) {\n          needsUpdate = true;\n          updateProps[key] = newProps[key];\n        }\n      }\n\n      return needsUpdate ? updateProps : null;\n    },\n\n    commitUpdate(instance, payload) {\n      instance.updateProps(payload);\n    },\n\n    // Update root\n    appendChildToContainer(remoteRoot, child) {\n      remoteRoot.append(child);\n    },\n\n    insertInContainerBefore(remoteRoot, child, beforeChild) {\n      remoteRoot.insertBefore(child, beforeChild);\n    },\n\n    removeChildFromContainer(remoteRoot, child) {\n      remoteRoot.removeChild(child);\n    },\n\n    clearContainer(remoteRoot) {\n      for (const child of remoteRoot.children) {\n        remoteRoot.removeChild(child);\n      }\n    },\n\n    // Update children\n    appendInitialChild(parent, child) {\n      parent.append(child);\n    },\n\n    appendChild(parent, child) {\n      parent.append(child);\n    },\n\n    insertBefore(parent, newChild, beforeChild) {\n      parent.insertBefore(newChild, beforeChild);\n    },\n\n    removeChild(parent, child) {\n      parent.removeChild(child);\n    },\n\n    // Unknown\n    finalizeInitialChildren() {\n      return false;\n    },\n\n    shouldSetTextContent() {\n      return false;\n    },\n\n    getPublicInstance() {},\n\n    prepareForCommit() {\n      return null;\n    },\n\n    resetAfterCommit() {},\n\n    commitMount() {},\n\n    preparePortalMount() {},\n\n    detachDeletedInstance() {}\n\n  });\n};\n\nfunction scheduleMicrotask(callback) {\n  return typeof queueMicrotask === 'function' ? queueMicrotask : Promise.resolve(null).then(callback).catch(handleErrorInNextTick);\n}\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n\nconst {\n  hasOwnProperty\n} = {};\n\nfunction has(object, property) {\n  return hasOwnProperty.call(object, property);\n}\n\nexport { createReconciler };\n", "import { createContext } from 'react';\n\nconst RenderContext = /*#__PURE__*/createContext(null);\n\nexport { RenderContext };\n", "import { memo, useRef, useMemo, isValidElement, Children } from 'react';\nimport { isRemoteFragment } from '@remote-ui/core';\nimport { jsx } from 'react/jsx-runtime';\nimport { useRender } from './hooks/render.mjs';\n\nfunction createRemoteReactComponent(componentType, {\n  fragmentProps\n} = {}) {\n  if (!fragmentProps || !fragmentProps.length) {\n    return componentType;\n  }\n\n  const wrapper = createComponentWrapper(componentType, fragmentProps);\n  wrapper.displayName = componentType;\n  return wrapper;\n}\n\nfunction createComponentWrapper(componentType, fragmentProps) {\n  const Component = componentType;\n  return /*#__PURE__*/memo(function ComponentWrapper({\n    children: externalChildren = [],\n    ...externalProps\n  }) {\n    const fragments = useRef({});\n    const {\n      root,\n      reconciler\n    } = useRender();\n    const {\n      props,\n      children\n    } = useMemo(() => {\n      // React portals need to be attached to the tree after intialize in order to render.\n      // It's usually done by appending them as children of a parent node.\n      // @see https://reactjs.org/docs/portals.html\n      const portals = [];\n      const props = {};\n\n      for (const key of Object.keys(externalProps)) {\n        const element = externalProps[key];\n\n        if (fragmentProps.includes(key) && /*#__PURE__*/isValidElement(element)) {\n          const currentFragment = fragments.current[key];\n          const fragment = isRemoteFragment(currentFragment) ? currentFragment : root.createFragment();\n          fragments.current[key] = fragment; // Assign createText and createComponent to fragment\n          // so that it can become a React container to render the portal\n\n          Object.assign(fragment, {\n            createText(...args) {\n              return root.createText(...args);\n            },\n\n            createComponent(type, ...args) {\n              return root.createComponent(type, ...args);\n            }\n\n          });\n          const portal = reconciler.createPortal(element, fragment, null, null);\n          portals.push(portal);\n          props[key] = fragment;\n        } else {\n          props[key] = element;\n          delete fragments.current[key];\n        }\n      }\n\n      return {\n        props,\n        children: [...Children.toArray(externalChildren), ...portals]\n      };\n    }, [externalChildren, externalProps, root, reconciler, fragments]);\n    return /*#__PURE__*/jsx(Component, { ...props,\n      children: children\n    });\n  });\n}\n\nexport { createRemoteReactComponent };\n", "import { useContext } from 'react';\nimport { RenderContext } from '../context.mjs';\n\nfunction useRender() {\n  const render = useContext(RenderContext);\n\n  if (render == null) {\n    throw new Error('No remote-ui Render instance found in context');\n  }\n\n  return render;\n}\n\nexport { useRender };\n", "import { createRoot } from '@remote-ui/react';\n\nconst remoteRootRender = (node, root) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const remoteRoot = createRoot(root);\n      remoteRoot.render(node);\n      resolve(() => remoteRoot.unmount());\n    } catch (error) {\n      // Workaround for https://github.com/Shopify/ui-extensions/issues/325\n      // eslint-disable-next-line no-console\n      console.error(error);\n      reject(error);\n    }\n  });\n};\n\nexport { remoteRootRender };\n", "import { extension } from '@shopify/ui-extensions/admin';\nimport { ExtensionApiContext } from './context.mjs';\nimport { remoteRootRender } from '../../utilities/remoteRootRender.mjs';\nimport { jsx } from 'react/jsx-runtime';\n\nfunction reactExtension(target, render) {\n  // TypeScript can\u2019t infer the type of the callback because it\u2019s a big union\n  // type. To get around it, we\u2019ll just fake like we are rendering the\n  // Playground extension, since all render extensions have the same general\n  // shape (`RenderExtension`).\n  return extension(target, async (root, api) => {\n    if (!target.match(/\\.render$/)) {\n      throw new Error(`reactExtension can only be used for .render extension targets, got: ${target}`);\n    }\n    const element = await render(api);\n    return remoteRootRender( /*#__PURE__*/jsx(ExtensionApiContext.Provider, {\n      value: api,\n      children: element\n    }), root);\n  });\n}\n\nexport { reactExtension, reactExtension as render };\n", "import { AdminAction as AdminAction$1 } from '@shopify/ui-extensions/admin';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst AdminAction = createRemoteReactComponent(AdminAction$1, {\n  fragmentProps: ['primaryAction', 'secondaryAction']\n});\n\nexport { AdminAction };\n", "import { Banner as Banner$1 } from '@shopify/ui-extensions/admin';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Banner = createRemoteReactComponent(Banner$1, {\n  fragmentProps: ['primaryAction', 'secondaryAction']\n});\n\nexport { Banner };\n", "import { BlockStack as BlockStack$1 } from '@shopify/ui-extensions/admin';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst BlockStack = createRemoteReactComponent(BlockStack$1);\n\nexport { BlockStack };\n", "import { Button as Button$1 } from '@shopify/ui-extensions/admin';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Button = createRemoteReactComponent(Button$1);\n\nexport { Button };\n", "import { Link as Link$1 } from '@shopify/ui-extensions/admin';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst Link = createRemoteReactComponent(Link$1);\n\nexport { Link };\n", "import { ProgressIndicator as ProgressIndicator$1 } from '@shopify/ui-extensions/admin';\nimport { createRemoteReactComponent } from '@remote-ui/react';\n\nconst ProgressIndicator = createRemoteReactComponent(ProgressIndicator$1);\n\nexport { ProgressIndicator };\n", "import { useContext } from 'react';\nimport { ExtensionApiContext } from '../context.mjs';\nimport { AdminUIExtensionError } from '../errors.mjs';\n\n/**\n * Returns the full API object that was passed in to your\n * extension when it was created.\n */\nfunction useApi(_target) {\n  const api = useContext(ExtensionApiContext);\n  if (api == null) {\n    throw new AdminUIExtensionError('No extension api found.');\n  }\n  return api;\n}\n\n/**\n * Returns the full API object that was passed in to your\n * extension when it was created.\n * @deprecated you shoud be importing useApi instead\n */\nfunction useExtensionApi() {\n  return useApi();\n}\n\nexport { useApi, useExtensionApi };\n", "class AdminUIExtensionError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.name = 'AdminUIExtensionError';\n  }\n}\n\nexport { AdminUIExtensionError };\n"],
  "mappings": "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",
  "names": ["require_react_development", "__commonJSMin", "exports", "module", "ReactVersion", "REACT_ELEMENT_TYPE", "REACT_PORTAL_TYPE", "REACT_FRAGMENT_TYPE", "REACT_STRICT_MODE_TYPE", "REACT_PROFILER_TYPE", "REACT_PROVIDER_TYPE", "REACT_CONTEXT_TYPE", "REACT_FORWARD_REF_TYPE", "REACT_SUSPENSE_TYPE", "REACT_SUSPENSE_LIST_TYPE", "REACT_MEMO_TYPE", "REACT_LAZY_TYPE", "REACT_OFFSCREEN_TYPE", "MAYBE_ITERATOR_SYMBOL", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "maybeIterator", "ReactCurrentDispatcher", "ReactCurrentBatchConfig", "ReactCurrentActQueue", "ReactCurrentOwner", "ReactDebugCurrentFrame", "currentExtraStackFrame", "setExtraStackFrame", "stack", "impl", "enableScopeAPI", "enableCacheElement", "enableTransitionTracing", "enableLegacyHidden", "enableDebugTracing", "ReactSharedInternals", "warn", "format", "_len", "args", "_key", "printWarning", "error", "_len2", "_key2", "level", "argsWithFormat", "item", "didWarnStateUpdateForUnmountedComponent", "warnNoop", "publicInstance", "callerName", "_constructor", "componentName", "warningKey", "ReactNoopUpdateQueue", "callback", "completeState", "partialState", "assign", "emptyObject", "Component", "props", "context", "updater", "deprecatedAPIs", "defineDeprecationWarning", "methodName", "info", "fnName", "ComponentDummy", "PureComponent", "pureComponentPrototype", "createRef", "refObject", "isArrayImpl", "isArray", "a", "typeName", "value", "hasToStringTag", "type", "willCoercionThrow", "testStringCoercion", "e", "checkKeyStringCoercion", "getWrappedName", "outerType", "innerType", "wrapperName", "displayName", "functionName", "getContextName", "getComponentNameFromType", "provider", "outerName", "lazyComponent", "payload", "init", "x", "hasOwnProperty", "RESERVED_PROPS", "specialPropKeyWarningShown", "specialPropRefWarningShown", "didWarnAboutStringRefs", "hasValidRef", "config", "getter", "hasValidKey", "defineKeyPropWarningGetter", "warnAboutAccessingKey", "defineRefPropWarningGetter", "warnAboutAccessingRef", "warnIfStringRefCannotBeAutoConverted", "ReactElement", "key", "ref", "self", "source", "owner", "element", "createElement", "children", "propName", "childrenLength", "childArray", "i", "defaultProps", "cloneAndReplaceKey", "oldElement", "newKey", "newElement", "cloneElement", "isValidElement", "object", "SEPARATOR", "SUBSEPARATOR", "escape", "escapeRegex", "escaperLookup", "escapedString", "match", "didWarnAboutMaps", "userProvidedKeyEscapeRegex", "escapeUserProvidedKey", "text", "getElementKey", "index", "mapIntoArray", "array", "escapedPrefix", "nameSoFar", "invokeCallback", "_child", "mappedChild", "childKey", "escapedChildKey", "c", "child", "nextName", "subtreeCount", "nextNamePrefix", "iteratorFn", "iterableChildren", "iterator", "step", "ii", "childrenString", "mapChildren", "func", "result", "count", "countChildren", "n", "forEachChildren", "forEachFunc", "forEachContext", "toArray", "onlyChild", "createContext", "defaultValue", "hasWarnedAboutUsingNestedContextConsumers", "hasWarnedAboutUsingConsumerProvider", "hasWarnedAboutDisplayNameOnConsumer", "Consumer", "_Provider", "_currentValue", "_currentValue2", "_threadCount", "Uninitialized", "Pending", "Resolved", "Rejected", "lazyInitializer", "ctor", "thenable", "moduleObject", "resolved", "rejected", "pending", "lazy", "lazyType", "propTypes", "newDefaultProps", "newPropTypes", "forwardRef", "render", "elementType", "ownName", "name", "REACT_MODULE_REFERENCE", "isValidElementType", "memo", "compare", "resolveDispatcher", "dispatcher", "useContext", "Context", "realContext", "useState", "initialState", "useReducer", "reducer", "initialArg", "useRef", "initialValue", "useEffect", "create", "deps", "useInsertionEffect", "useLayoutEffect", "useCallback", "useMemo", "useImperativeHandle", "useDebugValue", "formatterFn", "useTransition", "useDeferredValue", "useId", "useSyncExternalStore", "subscribe", "getSnapshot", "getServerSnapshot", "disabledDepth", "prevLog", "prevInfo", "prevWarn", "prevError", "prevGroup", "prevGroupCollapsed", "prevGroupEnd", "disabledLog", "disableLogs", "reenableLogs", "ReactCurrentDispatcher$1", "prefix", "describeBuiltInComponentFrame", "ownerFn", "reentry", "componentFrameCache", "PossiblyWeakMap", "describeNativeComponentFrame", "fn", "construct", "frame", "control", "previousPrepareStackTrace", "previousDispatcher", "Fake", "sample", "sampleLines", "controlLines", "s", "_frame", "syntheticFrame", "describeFunctionComponentFrame", "shouldConstruct", "prototype", "describeUnknownElementTypeFrameInDEV", "loggedTypeFailures", "ReactDebugCurrentFrame$1", "setCurrentlyValidatingElement", "checkPropTypes", "typeSpecs", "values", "location", "has", "typeSpecName", "error$1", "err", "ex", "setCurrentlyValidatingElement$1", "propTypesMisspellWarningShown", "getDeclarationErrorAddendum", "getSourceInfoErrorAddendum", "fileName", "lineNumber", "getSourceInfoErrorAddendumForProps", "elementProps", "ownerHasKeyUseWarning", "getCurrentComponentErrorInfo", "parentType", "parentName", "validateExplicitKey", "currentComponentErrorInfo", "childOwner", "validateChildKeys", "node", "validatePropTypes", "_name", "validateFragmentProps", "fragment", "keys", "createElementWithValidation", "validType", "sourceInfo", "typeString", "didWarnAboutDeprecatedCreateFactory", "createFactoryWithValidation", "validatedFactory", "cloneElementWithValidation", "startTransition", "scope", "options", "prevTransition", "currentTransition", "updatedFibersCount", "didWarnAboutMessageChannel", "enqueueTaskImpl", "enqueueTask", "task", "requireString", "nodeRequire", "_err", "channel", "actScopeDepth", "didWarnNoAwaitAct", "act", "prevActScopeDepth", "prevIsBatchingLegacy", "queue", "flushActQueue", "popActScope", "thenableResult", "wasAwaited", "resolve", "reject", "returnValue", "recursivelyFlushAsyncActWork", "_queue", "_thenable", "_thenable2", "isFlushing", "createElement$1", "cloneElement$1", "createFactory", "Children", "require_react", "__commonJSMin", "exports", "module", "require_scheduler_development", "__commonJSMin", "exports", "enableSchedulerDebugging", "enableProfiling", "frameYieldMs", "push", "heap", "node", "index", "siftUp", "peek", "pop", "first", "last", "siftDown", "i", "parentIndex", "parent", "compare", "length", "halfLength", "leftIndex", "left", "rightIndex", "right", "a", "b", "diff", "ImmediatePriority", "UserBlockingPriority", "NormalPriority", "LowPriority", "IdlePriority", "markTaskErrored", "task", "ms", "hasPerformanceNow", "localPerformance", "localDate", "initialTime", "maxSigned31BitInt", "IMMEDIATE_PRIORITY_TIMEOUT", "USER_BLOCKING_PRIORITY_TIMEOUT", "NORMAL_PRIORITY_TIMEOUT", "LOW_PRIORITY_TIMEOUT", "IDLE_PRIORITY_TIMEOUT", "taskQueue", "timerQueue", "taskIdCounter", "currentTask", "currentPriorityLevel", "isPerformingWork", "isHostCallbackScheduled", "isHostTimeoutScheduled", "localSetTimeout", "localClearTimeout", "localSetImmediate", "isInputPending", "advanceTimers", "currentTime", "timer", "handleTimeout", "requestHostCallback", "flushWork", "firstTimer", "requestHostTimeout", "hasTimeRemaining", "cancelHostTimeout", "previousPriorityLevel", "workLoop", "error", "shouldYieldToHost", "callback", "didUserCallbackTimeout", "continuationCallback", "unstable_runWithPriority", "priorityLevel", "eventHandler", "unstable_next", "unstable_wrapCallback", "parentPriorityLevel", "unstable_scheduleCallback", "options", "startTime", "delay", "timeout", "expirationTime", "newTask", "unstable_pauseExecution", "unstable_continueExecution", "unstable_getFirstCallbackNode", "unstable_cancelCallback", "unstable_getCurrentPriorityLevel", "isMessageLoopRunning", "scheduledHostCallback", "taskTimeoutID", "frameInterval", "timeElapsed", "requestPaint", "forceFrameRate", "fps", "performWorkUntilDeadline", "hasMoreWork", "schedulePerformWorkUntilDeadline", "channel", "port", "unstable_requestPaint", "unstable_Profiling", "require_scheduler", "__commonJSMin", "exports", "module", "require_react_reconciler_development", "__commonJSMin", "exports", "module", "$$$hostConfig", "React", "Scheduler", "ReactSharedInternals", "suppressWarning", "setSuppressWarning", "newSuppressWarning", "warn", "format", "_len", "args", "_key", "printWarning", "error", "_len2", "_key2", "level", "ReactDebugCurrentFrame", "stack", "argsWithFormat", "item", "assign", "get", "key", "set", "value", "enableNewReconciler", "enableLazyContextPropagation", "enableLegacyHidden", "enableSuspenseAvoidThisFallback", "warnAboutStringRefs", "enableSchedulingProfiler", "enableProfilerTimer", "enableProfilerCommitHooks", "FunctionComponent", "ClassComponent", "IndeterminateComponent", "HostRoot", "HostPortal", "HostComponent", "HostText", "Fragment", "Mode", "ContextConsumer", "ContextProvider", "ForwardRef", "Profiler", "SuspenseComponent", "MemoComponent", "SimpleMemoComponent", "LazyComponent", "IncompleteClassComponent", "DehydratedFragment", "SuspenseListComponent", "ScopeComponent", "OffscreenComponent", "LegacyHiddenComponent", "CacheComponent", "TracingMarkerComponent", "REACT_ELEMENT_TYPE", "REACT_PORTAL_TYPE", "REACT_FRAGMENT_TYPE", "REACT_STRICT_MODE_TYPE", "REACT_PROFILER_TYPE", "REACT_PROVIDER_TYPE", "REACT_CONTEXT_TYPE", "REACT_FORWARD_REF_TYPE", "REACT_SUSPENSE_TYPE", "REACT_SUSPENSE_LIST_TYPE", "REACT_MEMO_TYPE", "REACT_LAZY_TYPE", "REACT_SCOPE_TYPE", "REACT_DEBUG_TRACING_MODE_TYPE", "REACT_OFFSCREEN_TYPE", "REACT_LEGACY_HIDDEN_TYPE", "REACT_CACHE_TYPE", "REACT_TRACING_MARKER_TYPE", "MAYBE_ITERATOR_SYMBOL", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "maybeIterator", "getWrappedName", "outerType", "innerType", "wrapperName", "displayName", "functionName", "getContextName", "type", "getComponentNameFromType", "context", "provider", "outerName", "lazyComponent", "payload", "init", "x", "getWrappedName$1", "getContextName$1", "getComponentNameFromFiber", "fiber", "tag", "NoFlags", "PerformedWork", "Placement", "Update", "ChildDeletion", "ContentReset", "Callback", "DidCapture", "ForceClientRender", "Ref", "Snapshot", "Passive", "Hydrating", "Visibility", "StoreConsistency", "LifecycleEffectMask", "HostEffectMask", "Incomplete", "ShouldCapture", "ForceUpdateForLegacySuspense", "Forked", "RefStatic", "LayoutStatic", "PassiveStatic", "MountLayoutDev", "MountPassiveDev", "BeforeMutationMask", "MutationMask", "LayoutMask", "PassiveMask", "StaticMask", "ReactCurrentOwner", "getNearestMountedFiber", "node", "nearestMounted", "nextNode", "isFiberMounted", "isMounted", "component", "owner", "ownerFiber", "instance", "assertIsMounted", "findCurrentFiberUsingSlowPath", "alternate", "b", "parentA", "parentB", "nextParent", "child", "didFindChild", "_child", "findCurrentHostFiber", "parent", "currentParent", "findCurrentHostFiberImpl", "match", "findCurrentHostFiberWithNoPortals", "findCurrentHostFiberWithNoPortalsImpl", "isArrayImpl", "isArray", "a", "getPublicInstance", "getRootHostContext", "getChildHostContext", "prepareForCommit", "resetAfterCommit", "createInstance", "appendInitialChild", "finalizeInitialChildren", "prepareUpdate", "shouldSetTextContent", "createTextInstance", "scheduleTimeout", "cancelTimeout", "noTimeout", "isPrimaryRenderer", "warnsIfNotActing", "supportsMutation", "supportsPersistence", "supportsHydration", "getInstanceFromNode", "beforeActiveInstanceBlur", "afterActiveInstanceBlur", "preparePortalMount", "prepareScopeUpdate", "getInstanceFromScope", "getCurrentEventPriority", "detachDeletedInstance", "supportsMicrotasks", "scheduleMicrotask", "supportsTestSelectors", "findFiberRoot", "getBoundingRect", "getTextContent", "isHiddenSubtree", "matchAccessibilityRole", "setFocusIfFocusable", "setupIntersectionObserver", "appendChild", "appendChildToContainer", "commitTextUpdate", "commitMount", "commitUpdate", "insertBefore", "insertInContainerBefore", "removeChild", "removeChildFromContainer", "resetTextContent", "hideInstance", "hideTextInstance", "unhideInstance", "unhideTextInstance", "clearContainer", "cloneInstance", "createContainerChildSet", "appendChildToContainerChildSet", "finalizeContainerChildren", "replaceContainerChildren", "cloneHiddenInstance", "cloneHiddenTextInstance", "canHydrateInstance", "canHydrateTextInstance", "canHydrateSuspenseInstance", "isSuspenseInstancePending", "isSuspenseInstanceFallback", "getSuspenseInstanceFallbackErrorDetails", "registerSuspenseInstanceRetry", "getNextHydratableSibling", "getFirstHydratableChild", "getFirstHydratableChildWithinContainer", "getFirstHydratableChildWithinSuspenseInstance", "hydrateInstance", "hydrateTextInstance", "hydrateSuspenseInstance", "getNextHydratableInstanceAfterSuspenseInstance", "commitHydratedContainer", "commitHydratedSuspenseInstance", "clearSuspenseBoundary", "clearSuspenseBoundaryFromContainer", "shouldDeleteUnhydratedTailInstances", "didNotMatchHydratedContainerTextInstance", "didNotMatchHydratedTextInstance", "didNotHydrateInstanceWithinContainer", "didNotHydrateInstanceWithinSuspenseInstance", "didNotHydrateInstance", "didNotFindHydratableInstanceWithinContainer", "didNotFindHydratableTextInstanceWithinContainer", "didNotFindHydratableSuspenseInstanceWithinContainer", "didNotFindHydratableInstanceWithinSuspenseInstance", "didNotFindHydratableTextInstanceWithinSuspenseInstance", "didNotFindHydratableSuspenseInstanceWithinSuspenseInstance", "didNotFindHydratableInstance", "didNotFindHydratableTextInstance", "didNotFindHydratableSuspenseInstance", "errorHydratingContainer", "disabledDepth", "prevLog", "prevInfo", "prevWarn", "prevError", "prevGroup", "prevGroupCollapsed", "prevGroupEnd", "disabledLog", "disableLogs", "props", "reenableLogs", "ReactCurrentDispatcher", "prefix", "describeBuiltInComponentFrame", "name", "source", "ownerFn", "reentry", "componentFrameCache", "PossiblyWeakMap", "describeNativeComponentFrame", "fn", "construct", "frame", "control", "previousPrepareStackTrace", "previousDispatcher", "Fake", "sample", "sampleLines", "controlLines", "s", "c", "_frame", "syntheticFrame", "describeClassComponentFrame", "ctor", "describeFunctionComponentFrame", "shouldConstruct", "Component", "prototype", "describeUnknownElementTypeFrameInDEV", "hasOwnProperty", "loggedTypeFailures", "setCurrentlyValidatingElement", "element", "checkPropTypes", "typeSpecs", "values", "location", "componentName", "has", "typeSpecName", "error$1", "err", "ex", "valueStack", "fiberStack", "index", "createCursor", "defaultValue", "pop", "cursor", "push", "warnedAboutMissingGetChildContext", "emptyContextObject", "contextStackCursor", "didPerformWorkStackCursor", "previousContext", "getUnmaskedContext", "workInProgress", "didPushOwnContextIfProvider", "isContextProvider", "cacheContext", "unmaskedContext", "maskedContext", "getMaskedContext", "contextTypes", "hasContextChanged", "childContextTypes", "popContext", "popTopLevelContextObject", "pushTopLevelContextObject", "didChange", "processChildContext", "parentContext", "childContext", "contextKey", "pushContextProvider", "memoizedMergedChildContext", "invalidateContextProvider", "mergedContext", "findCurrentUnmaskedContext", "LegacyRoot", "ConcurrentRoot", "NoMode", "ConcurrentMode", "ProfileMode", "StrictLegacyMode", "StrictEffectsMode", "clz32", "clz32Fallback", "log", "LN2", "asUint", "TotalLanes", "NoLanes", "NoLane", "SyncLane", "InputContinuousHydrationLane", "InputContinuousLane", "DefaultHydrationLane", "DefaultLane", "TransitionHydrationLane", "TransitionLanes", "TransitionLane1", "TransitionLane2", "TransitionLane3", "TransitionLane4", "TransitionLane5", "TransitionLane6", "TransitionLane7", "TransitionLane8", "TransitionLane9", "TransitionLane10", "TransitionLane11", "TransitionLane12", "TransitionLane13", "TransitionLane14", "TransitionLane15", "TransitionLane16", "RetryLanes", "RetryLane1", "RetryLane2", "RetryLane3", "RetryLane4", "RetryLane5", "SomeRetryLane", "SelectiveHydrationLane", "NonIdleLanes", "IdleHydrationLane", "IdleLane", "OffscreenLane", "getLabelForLane", "lane", "NoTimestamp", "nextTransitionLane", "nextRetryLane", "getHighestPriorityLanes", "lanes", "getHighestPriorityLane", "getNextLanes", "root", "wipLanes", "pendingLanes", "nextLanes", "suspendedLanes", "pingedLanes", "nonIdlePendingLanes", "nonIdleUnblockedLanes", "nonIdlePingedLanes", "unblockedLanes", "nextLane", "wipLane", "entangledLanes", "entanglements", "pickArbitraryLaneIndex", "getMostRecentEventTime", "eventTimes", "mostRecentEventTime", "eventTime", "computeExpirationTime", "currentTime", "markStarvedLanesAsExpired", "expirationTimes", "expirationTime", "getHighestPriorityPendingLanes", "getLanesToRetrySynchronouslyOnError", "everythingButOffscreen", "includesSyncLane", "includesNonIdleWork", "includesOnlyRetries", "includesOnlyNonUrgentLanes", "UrgentLanes", "includesOnlyTransitions", "includesBlockingLane", "SyncDefaultLanes", "includesExpiredLane", "isTransitionLane", "claimNextTransitionLane", "claimNextRetryLane", "pickArbitraryLane", "laneToIndex", "includesSomeLane", "isSubsetOfLanes", "subset", "mergeLanes", "removeLanes", "intersectLanes", "laneToLanes", "higherPriorityLane", "createLaneMap", "initial", "laneMap", "i", "markRootUpdated", "updateLane", "markRootSuspended", "markRootPinged", "markRootFinished", "remainingLanes", "noLongerPendingLanes", "markRootEntangled", "rootEntangledLanes", "getBumpedLaneForHydration", "renderLanes", "renderLane", "addFiberToLanesMap", "isDevToolsPresent", "pendingUpdatersLaneMap", "updaters", "movePendingFibersToMemoized", "memoizedUpdaters", "getTransitionsForLanes", "DiscreteEventPriority", "ContinuousEventPriority", "DefaultEventPriority", "IdleEventPriority", "currentUpdatePriority", "getCurrentUpdatePriority", "setCurrentUpdatePriority", "newPriority", "runWithPriority", "priority", "previousPriority", "higherEventPriority", "lowerEventPriority", "isHigherEventPriority", "lanesToEventPriority", "scheduleCallback", "cancelCallback", "shouldYield", "requestPaint", "now", "ImmediatePriority", "UserBlockingPriority", "NormalPriority", "IdlePriority", "unstable_yieldValue", "unstable_setDisableYieldValue", "rendererID", "injectedHook", "injectedProfilingHooks", "hasLoggedError", "injectInternals", "internals", "hook", "getLaneLabelMap", "injectProfilingHooks", "onScheduleRoot", "children", "onCommitRoot", "eventPriority", "didError", "schedulerPriority", "onPostCommitRoot", "onCommitUnmount", "setIsStrictModeForDevtools", "newIsStrictMode", "profilingHooks", "map", "label", "markCommitStarted", "markCommitStopped", "markComponentRenderStarted", "markComponentRenderStopped", "markComponentPassiveEffectMountStarted", "markComponentPassiveEffectMountStopped", "markComponentPassiveEffectUnmountStarted", "markComponentPassiveEffectUnmountStopped", "markComponentLayoutEffectMountStarted", "markComponentLayoutEffectMountStopped", "markComponentLayoutEffectUnmountStarted", "markComponentLayoutEffectUnmountStopped", "markComponentErrored", "thrownValue", "markComponentSuspended", "wakeable", "markLayoutEffectsStarted", "markLayoutEffectsStopped", "markPassiveEffectsStarted", "markPassiveEffectsStopped", "markRenderStarted", "markRenderYielded", "markRenderStopped", "markRenderScheduled", "markForceUpdateScheduled", "markStateUpdateScheduled", "is", "y", "objectIs", "syncQueue", "includesLegacySyncCallbacks", "isFlushingSyncQueue", "scheduleSyncCallback", "callback", "scheduleLegacySyncCallback", "flushSyncCallbacksOnlyInLegacyMode", "flushSyncCallbacks", "previousUpdatePriority", "isSync", "queue", "isRootDehydrated", "currentState", "forkStack", "forkStackIndex", "treeForkProvider", "treeForkCount", "idStack", "idStackIndex", "treeContextProvider", "treeContextId", "treeContextOverflow", "isForkedChild", "warnIfNotHydrating", "getForksAtLevel", "getTreeId", "overflow", "idWithLeadingBit", "id", "getLeadingBit", "pushTreeFork", "totalChildren", "pushTreeId", "baseIdWithLeadingBit", "baseOverflow", "baseLength", "getBitLength", "baseId", "slot", "length", "numberOfOverflowBits", "newOverflowBits", "newOverflow", "restOfBaseId", "restOfBaseLength", "restOfLength", "restOfNewBits", "newBits", "_id", "_overflow", "pushMaterializedTreeId", "returnFiber", "numberOfForks", "slotIndex", "number", "popTreeContext", "getSuspendedTreeContext", "restoreSuspendedTreeContext", "suspendedContext", "getIsHydrating", "hydrationParentFiber", "nextHydratableInstance", "isHydrating", "didSuspendOrErrorDEV", "hydrationErrors", "warnIfHydrating", "markDidThrowWhileHydratingDEV", "didSuspendOrErrorWhileHydratingDEV", "enterHydrationState", "parentInstance", "reenterHydrationStateFromDehydratedSuspenseInstance", "suspenseInstance", "treeContext", "warnUnhydratedInstance", "isConcurrentMode", "suspenseState", "deleteHydratableInstance", "childToDelete", "createFiberFromHostInstanceForDeletion", "deletions", "warnNonhydratedInstance", "parentContainer", "text", "parentType", "parentProps", "_type", "_props", "_text", "_isConcurrentMode", "_parentInstance", "_type2", "_props2", "_text2", "insertNonHydratedInstance", "tryHydrate", "nextInstance", "textInstance", "dehydratedFragment", "createFiberFromDehydratedFragment", "shouldClientRenderOnMismatch", "throwOnHydrationMismatch", "tryToClaimNextHydratableInstance", "firstAttemptedInstance", "prevHydrationParentFiber", "prepareToHydrateHostInstance", "rootContainerInstance", "hostContext", "shouldWarnIfMismatchDev", "updatePayload", "prepareToHydrateHostTextInstance", "textContent", "shouldUpdate", "_isConcurrentMode2", "prepareToHydrateHostSuspenseInstance", "skipPastDehydratedSuspenseInstance", "popToNextHostParent", "popHydrationState", "warnIfUnhydratedTailNodes", "hasUnhydratedTailNodes", "resetHydrationState", "upgradeHydrationErrorsToRecoverable", "queueRecoverableErrors", "queueHydrationError", "ReactCurrentBatchConfig", "NoTransition", "requestCurrentTransition", "shallowEqual", "objA", "objB", "keysA", "keysB", "currentKey", "describeFiber", "getStackByFiberInDevAndProd", "info", "ReactDebugCurrentFrame$1", "current", "isRendering", "getCurrentFiberOwnerNameInDevOrNull", "getCurrentFiberStackInDev", "resetCurrentFiber", "setCurrentFiber", "getCurrentFiber", "setIsRendering", "rendering", "ReactStrictModeWarnings", "findStrictRoot", "maybeStrictRoot", "setToSortedString", "array", "pendingComponentWillMountWarnings", "pendingUNSAFE_ComponentWillMountWarnings", "pendingComponentWillReceivePropsWarnings", "pendingUNSAFE_ComponentWillReceivePropsWarnings", "pendingComponentWillUpdateWarnings", "pendingUNSAFE_ComponentWillUpdateWarnings", "didWarnAboutUnsafeLifecycles", "componentWillMountUniqueNames", "UNSAFE_componentWillMountUniqueNames", "componentWillReceivePropsUniqueNames", "UNSAFE_componentWillReceivePropsUniqueNames", "componentWillUpdateUniqueNames", "UNSAFE_componentWillUpdateUniqueNames", "sortedNames", "_sortedNames", "_sortedNames2", "_sortedNames3", "_sortedNames4", "_sortedNames5", "pendingLegacyContextWarning", "didWarnAboutLegacyContext", "strictRoot", "warningsForRoot", "fiberArray", "firstFiber", "uniqueNames", "typeName", "hasToStringTag", "willCoercionThrow", "testStringCoercion", "e", "checkKeyStringCoercion", "checkPropStringCoercion", "propName", "resolveDefaultProps", "baseProps", "defaultProps", "valueCursor", "rendererSigil", "currentlyRenderingFiber", "lastContextDependency", "lastFullyObservedContext", "isDisallowedContextReadInDEV", "resetContextDependencies", "enterDisallowedContextReadInDEV", "exitDisallowedContextReadInDEV", "pushProvider", "providerFiber", "nextValue", "popProvider", "currentValue", "scheduleContextWorkOnParentPath", "propagationRoot", "propagateContextChange", "propagateContextChange_eager", "nextFiber", "list", "dependency", "update", "createUpdate", "ForceUpdate", "updateQueue", "sharedQueue", "pending", "parentSuspense", "_alternate", "sibling", "prepareToReadContext", "dependencies", "firstContext", "markWorkInProgressReceivedUpdate", "readContext", "contextItem", "concurrentQueues", "pushConcurrentUpdateQueue", "finishQueueingConcurrentUpdates", "lastInterleavedUpdate", "firstInterleavedUpdate", "lastPendingUpdate", "firstPendingUpdate", "enqueueConcurrentHookUpdate", "interleaved", "markUpdateLaneFromFiberToRoot", "enqueueConcurrentHookUpdateAndEagerlyBailout", "enqueueConcurrentClassUpdate", "enqueueConcurrentRenderForLane", "unsafe_markUpdateLaneFromFiberToRoot", "sourceFiber", "warnAboutUpdateOnNotYetMountedFiberInDEV", "UpdateState", "ReplaceState", "CaptureUpdate", "hasForceUpdate", "didWarnUpdateInsideUpdate", "currentlyProcessingQueue", "initializeUpdateQueue", "cloneUpdateQueue", "currentQueue", "clone", "enqueueUpdate", "isUnsafeClassRenderPhaseUpdate", "entangleTransitions", "queueLanes", "newQueueLanes", "enqueueCapturedUpdate", "capturedUpdate", "newFirst", "newLast", "firstBaseUpdate", "lastBaseUpdate", "getStateFromUpdate", "prevState", "nextProps", "nextState", "_payload", "partialState", "processUpdateQueue", "pendingQueue", "currentLastBaseUpdate", "newState", "newLanes", "newBaseState", "newFirstBaseUpdate", "newLastBaseUpdate", "updateEventTime", "_clone", "effects", "_lastPendingUpdate", "_firstPendingUpdate", "lastInterleaved", "markSkippedUpdateLanes", "callCallback", "resetHasForceUpdateBeforeProcessing", "checkHasForceUpdateAfterProcessing", "commitUpdateQueue", "finishedWork", "finishedQueue", "effect", "fakeInternalInstance", "emptyRefsObject", "didWarnAboutStateAssignmentForComponent", "didWarnAboutUninitializedState", "didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate", "didWarnAboutLegacyLifecyclesAndDerivedState", "didWarnAboutUndefinedDerivedState", "warnOnUndefinedDerivedState", "warnOnInvalidCallback", "didWarnAboutDirectlyAssigningPropsToState", "didWarnAboutContextTypeAndContextTypes", "didWarnAboutInvalidateContextType", "didWarnOnInvalidCallback", "callerName", "applyDerivedStateFromProps", "getDerivedStateFromProps", "memoizedState", "classComponentUpdater", "inst", "requestEventTime", "requestUpdateLane", "scheduleUpdateOnFiber", "checkShouldComponentUpdate", "oldProps", "newProps", "oldState", "nextContext", "checkClassInstance", "renderPresent", "hasMutatedProps", "_state", "adoptClassInstance", "constructClassInstance", "isLegacyContextConsumer", "contextType", "isValid", "addendum", "state", "foundWillMountName", "foundWillReceivePropsName", "foundWillUpdateName", "_componentName", "newApiName", "callComponentWillMount", "callComponentWillReceiveProps", "mountClassInstance", "fiberFlags", "resumeMountClassInstance", "oldContext", "nextLegacyUnmaskedContext", "hasNewLifecycles", "_fiberFlags", "_fiberFlags2", "updateClassInstance", "unresolvedOldProps", "unresolvedNewProps", "nextUnmaskedContext", "didWarnAboutMaps", "didWarnAboutGenerators", "didWarnAboutStringRefs", "ownerHasKeyUseWarning", "ownerHasFunctionTypeWarning", "warnForMissingKey", "coerceRef", "mixedRef", "resolvedInst", "stringRef", "ref", "refs", "throwOnInvalidObjectType", "newChild", "childString", "warnOnFunctionType", "resolveLazy", "lazyType", "ChildReconciler", "shouldTrackSideEffects", "deleteChild", "deleteRemainingChildren", "currentFirstChild", "mapRemainingChildren", "existingChildren", "existingChild", "useFiber", "pendingProps", "createWorkInProgress", "placeChild", "newFiber", "lastPlacedIndex", "newIndex", "oldIndex", "placeSingleChild", "updateTextNode", "created", "createFiberFromText", "existing", "updateElement", "elementType", "updateFragment", "isCompatibleFamilyForHotReloading", "createFiberFromElement", "updatePortal", "portal", "createFiberFromPortal", "fragment", "createFiberFromFragment", "createChild", "_created", "_created2", "_created3", "updateSlot", "oldFiber", "updateFromMap", "newIdx", "matchedFiber", "_matchedFiber", "_matchedFiber2", "_matchedFiber3", "warnOnInvalidKey", "knownKeys", "reconcileChildrenArray", "newChildren", "resultingFirstChild", "previousNewFiber", "nextOldFiber", "_newFiber", "_numberOfForks", "_newFiber2", "_numberOfForks2", "reconcileChildrenIterator", "newChildrenIterable", "iteratorFn", "_newChildren", "_step", "step", "_newFiber3", "_numberOfForks3", "_newFiber4", "_numberOfForks4", "reconcileSingleTextNode", "reconcileSingleElement", "_existing", "_created4", "reconcileSinglePortal", "reconcileChildFibers", "isUnkeyedTopLevelFragment", "mountChildFibers", "cloneChildFibers", "currentChild", "resetChildFibers", "resetWorkInProgress", "NO_CONTEXT", "contextStackCursor$1", "contextFiberStackCursor", "rootInstanceStackCursor", "requiredContext", "getRootHostContainer", "rootInstance", "pushHostContainer", "nextRootInstance", "nextRootContext", "popHostContainer", "getHostContext", "pushHostContext", "popHostContext", "DefaultSuspenseContext", "SubtreeSuspenseContextMask", "InvisibleParentSuspenseContext", "ForceSuspenseFallback", "suspenseStackCursor", "hasSuspenseContext", "flag", "setDefaultShallowSuspenseContext", "setShallowSuspenseContext", "shallowContext", "addSubtreeSuspenseContext", "subtreeContext", "pushSuspenseContext", "newContext", "popSuspenseContext", "shouldCaptureSuspense", "hasInvisibleParent", "findFirstSuspended", "row", "dehydrated", "didSuspend", "NoFlags$1", "HasEffect", "Insertion", "Layout", "Passive$1", "workInProgressSources", "resetWorkInProgressVersions", "mutableSource", "registerMutableSourceForHydration", "getVersion", "version", "ReactCurrentDispatcher$1", "ReactCurrentBatchConfig$1", "didWarnAboutMismatchedHooksForComponent", "didWarnUncachedGetSnapshot", "currentlyRenderingFiber$1", "currentHook", "workInProgressHook", "didScheduleRenderPhaseUpdate", "didScheduleRenderPhaseUpdateDuringThisPass", "localIdCounter", "globalClientIdCounter", "RE_RENDER_LIMIT", "currentHookNameInDev", "hookTypesDev", "hookTypesUpdateIndexDev", "ignorePreviousDependencies", "mountHookTypesDev", "hookName", "updateHookTypesDev", "warnOnHookMismatchInDev", "checkDepsAreArrayDev", "deps", "currentHookName", "table", "secondColumnStart", "oldHookName", "newHookName", "throwInvalidHookError", "areHookInputsEqual", "nextDeps", "prevDeps", "renderWithHooks", "secondArg", "nextRenderLanes", "HooksDispatcherOnUpdateInDEV", "HooksDispatcherOnMountWithHookTypesInDEV", "HooksDispatcherOnMountInDEV", "numberOfReRenders", "HooksDispatcherOnRerenderInDEV", "ContextOnlyDispatcher", "didRenderTooFewHooks", "checkDidRenderIdHook", "didRenderIdHook", "bailoutHooks", "resetHooksAfterThrow", "isUpdatingOpaqueValueInRenderPhase", "mountWorkInProgressHook", "updateWorkInProgressHook", "nextCurrentHook", "nextWorkInProgressHook", "newHook", "createFunctionComponentUpdateQueue", "basicStateReducer", "action", "mountReducer", "reducer", "initialArg", "initialState", "dispatch", "dispatchReducerAction", "updateReducer", "baseQueue", "baseFirst", "pendingFirst", "first", "newBaseQueueFirst", "newBaseQueueLast", "interleavedLane", "rerenderReducer", "lastRenderPhaseUpdate", "firstRenderPhaseUpdate", "mountMutableSource", "getSnapshot", "subscribe", "updateMutableSource", "mountSyncExternalStore", "getServerSnapshot", "nextSnapshot", "cachedSnapshot", "getWorkInProgressRoot", "pushStoreConsistencyCheck", "mountEffect", "subscribeToStore", "pushEffect", "updateStoreInstance", "updateSyncExternalStore", "prevSnapshot", "snapshotChanged", "updateEffect", "renderedSnapshot", "check", "componentUpdateQueue", "stores", "checkIfSnapshotChanged", "forceStoreRerender", "handleStoreChange", "latestGetSnapshot", "prevValue", "mountState", "dispatchSetState", "updateState", "rerenderState", "create", "destroy", "lastEffect", "firstEffect", "mountRef", "initialValue", "_ref2", "updateRef", "mountEffectImpl", "hookFlags", "updateEffectImpl", "prevEffect", "mountInsertionEffect", "updateInsertionEffect", "mountLayoutEffect", "updateLayoutEffect", "imperativeHandleEffect", "refCallback", "_inst", "refObject", "_inst2", "mountImperativeHandle", "effectDeps", "updateImperativeHandle", "mountDebugValue", "formatterFn", "updateDebugValue", "mountCallback", "updateCallback", "mountMemo", "nextCreate", "updateMemo", "mountDeferredValue", "updateDeferredValue", "resolvedCurrentHook", "updateDeferredValueImpl", "rerenderDeferredValue", "shouldDeferValue", "deferredLane", "startTransition", "setPending", "options", "prevTransition", "currentTransition", "updatedFibersCount", "mountTransition", "_mountState", "isPending", "start", "updateTransition", "_updateState", "rerenderTransition", "_rerenderState", "getIsUpdatingOpaqueValueInRenderPhaseInDEV", "mountId", "identifierPrefix", "treeId", "localId", "globalClientId", "updateId", "isRenderPhaseUpdate", "enqueueRenderPhaseUpdate", "entangleTransitionUpdate", "markUpdateInDevTools", "lastRenderedReducer", "prevDispatcher", "InvalidNestedHooksDispatcherOnUpdateInDEV", "eagerState", "InvalidNestedHooksDispatcherOnMountInDEV", "InvalidNestedHooksDispatcherOnRerenderInDEV", "warnInvalidContextAccess", "warnInvalidHookAccess", "now$1", "commitTime", "layoutEffectStartTime", "profilerStartTime", "passiveEffectStartTime", "currentUpdateIsNested", "nestedUpdateScheduled", "isCurrentUpdateNested", "markNestedUpdateScheduled", "resetNestedUpdateFlag", "syncNestedUpdateFlag", "getCommitTime", "recordCommitTime", "startProfilerTimer", "stopProfilerTimerIfRunning", "stopProfilerTimerIfRunningAndRecordDelta", "overrideBaseTime", "elapsedTime", "recordLayoutEffectDuration", "parentFiber", "parentStateNode", "recordPassiveEffectDuration", "startLayoutEffectTimer", "startPassiveEffectTimer", "transferActualDuration", "createCapturedValueAtFiber", "createCapturedValue", "digest", "showErrorDialog", "boundary", "errorInfo", "logCapturedError", "logError", "componentStack", "componentNameMessage", "errorBoundaryMessage", "errorBoundaryName", "combinedMessage", "PossiblyWeakMap$1", "createRootErrorUpdate", "onUncaughtError", "createClassErrorUpdate", "getDerivedStateFromError", "markFailedErrorBoundaryForHotReloading", "markLegacyErrorBoundaryAsFailed", "attachPingListener", "pingCache", "threadIDs", "ping", "pingSuspendedRoot", "restorePendingUpdaters", "attachRetryListener", "suspenseBoundary", "wakeables", "resetSuspendedComponent", "rootRenderLanes", "currentSource", "getNearestSuspenseBoundaryToCapture", "markSuspenseBoundaryShouldCapture", "currentSourceFiber", "throwException", "renderDidSuspendDelayIfPossible", "uncaughtSuspenseError", "_suspenseBoundary", "renderDidError", "_errorInfo", "isAlreadyFailedLegacyErrorBoundary", "_lane", "_update", "getSuspendedCache", "ReactCurrentOwner$1", "didReceiveUpdate", "didWarnAboutBadClass", "didWarnAboutModulePatternComponent", "didWarnAboutContextTypeOnFunctionComponent", "didWarnAboutGetDerivedStateOnFunctionComponent", "didWarnAboutFunctionRefs", "didWarnAboutReassigningProps", "didWarnAboutRevealOrder", "didWarnAboutTailOptions", "reconcileChildren", "nextChildren", "forceUnmountCurrentAndReconcile", "updateForwardRef", "innerPropTypes", "render", "hasId", "bailoutOnAlreadyFinishedWork", "updateMemoComponent", "isSimpleFunctionComponent", "resolvedType", "resolveFunctionForHotReloading", "validateFunctionComponentInDev", "updateSimpleMemoComponent", "createFiberFromTypeAndProps", "_innerPropTypes", "hasScheduledUpdateOrContext", "checkScheduledUpdateOrContext", "prevProps", "compare", "outerMemoType", "outerPropTypes", "updateFunctionComponent", "updateOffscreenComponent", "pushRenderLanes", "_nextState2", "subtreeRenderLanes", "spawnedCachePool", "nextBaseLanes", "prevBaseLanes", "_nextState", "_subtreeRenderLanes", "updateMode", "updateProfiler", "stateNode", "markRef", "updateClassComponent", "shouldError", "_instance", "tempInstance", "hasContext", "resetSuspendedCurrentOnMountInLegacyMode", "nextUnitOfWork", "finishClassComponent", "didCaptureError", "pushHostRootContext", "updateHostRoot", "prevChildren", "overrideState", "recoverableError", "mountHostRootWithoutHydrating", "_recoverableError", "updateHostComponent", "isDirectTextChild", "updateHostText", "mountLazyComponent", "_current", "resolvedTag", "resolveLazyComponentTag", "resolvedProps", "resolveClassForHotReloading", "resolveForwardRefForHotReloading", "hint", "mountIncompleteClassComponent", "mountIndeterminateComponent", "_componentName2", "ownerName", "warningKey", "debugSource", "_componentName3", "_componentName4", "SUSPENDED_MARKER", "mountSuspenseOffscreenState", "updateSuspenseOffscreenState", "prevOffscreenState", "cachePool", "shouldRemainOnFallback", "suspenseContext", "getRemainingWorkInPrimaryTree", "updateSuspenseComponent", "shouldSuspend", "showFallback", "mountDehydratedSuspenseComponent", "nextPrimaryChildren", "nextFallbackChildren", "fallbackFragment", "mountSuspenseFallbackChildren", "primaryChildFragment", "mountSuspensePrimaryChildren", "_dehydrated", "updateDehydratedSuspenseComponent", "_nextFallbackChildren", "_nextPrimaryChildren", "fallbackChildFragment", "updateSuspenseFallbackChildren", "_primaryChildFragment2", "_nextPrimaryChildren2", "_primaryChildFragment3", "updateSuspensePrimaryChildren", "primaryChildren", "mode", "primaryChildProps", "mountWorkInProgressOffscreenFiber", "fallbackChildren", "progressedPrimaryFragment", "offscreenProps", "createFiberFromOffscreen", "updateWorkInProgressOffscreenFiber", "currentPrimaryChildFragment", "currentFallbackChildFragment", "retrySuspenseComponentWithoutHydrating", "mountSuspenseFallbackAfterRetryWithoutHydrating", "fiberMode", "_capturedValue2", "_primaryChildFragment4", "message", "_getSuspenseInstanceF", "capturedValue", "attemptHydrationAtLane", "_capturedValue", "retry", "retryDehydratedSuspenseBoundary", "scheduleSuspenseWorkOnFiber", "propagateSuspenseContextChange", "firstChild", "findLastContentRow", "lastContentRow", "currentRow", "validateRevealOrder", "revealOrder", "validateTailOptions", "tailMode", "validateSuspenseListNestedChild", "childSlot", "isAnArray", "isIterable", "validateSuspenseListChildren", "childrenIterator", "_i", "initSuspenseListRenderState", "isBackwards", "tail", "renderState", "updateSuspenseListComponent", "shouldForceFallback", "didSuspendBefore", "_tail", "nextRow", "updatePortalComponent", "hasWarnedAboutUsingNoValuePropOnContextProvider", "updateContextProvider", "providerType", "newValue", "providerPropTypes", "oldValue", "hasWarnedAboutUsingContextAsConsumer", "updateContextConsumer", "remountFiber", "oldWorkInProgress", "newWorkInProgress", "prevSibling", "updateLanes", "attemptEarlyBailoutIfNoScheduledUpdate", "hasChildWork", "primaryChildLanes", "_hasChildWork", "beginWork", "unresolvedProps", "_Component", "_unresolvedProps", "_resolvedProps", "_unresolvedProps2", "_resolvedProps2", "_unresolvedProps3", "_resolvedProps3", "_Component2", "_unresolvedProps4", "_resolvedProps4", "markUpdate", "markRef$1", "hadNoMutationsEffects", "completedWork", "didBailout", "appendAllChildren", "updateHostContainer", "updateHostComponent$1", "updateHostText$1", "needsVisibilityToggle", "isHidden", "currentHostContext", "oldText", "newText", "appendAllChildrenToContainer", "containerChildSet", "_instance2", "portalOrRoot", "childrenUnchanged", "container", "newChildSet", "currentInstance", "recyclableInstance", "newInstance", "cutOffTailIfNeeded", "hasRenderedATailFallback", "tailNode", "lastTailNode", "_tailNode", "_lastTailNode", "bubbleProperties", "newChildLanes", "subtreeFlags", "_treeBaseDuration", "_child2", "_child3", "actualDuration", "treeBaseDuration", "completeDehydratedSuspenseBoundary", "wasHydrated", "isTimedOutSuspense", "_isTimedOutSuspense", "_primaryChildFragment", "completeWork", "fiberRoot", "_wasHydrated", "_rootContainerInstance", "_currentHostContext", "_wasHydrated2", "fallthroughToNormalSuspensePath", "nextDidTimeout", "prevDidTimeout", "_offscreenFiber2", "hasInvisibleChildContext", "renderDidSuspend", "didSuspendAlready", "renderedTail", "cannotBeSuspended", "renderHasNotSuspendedYet", "suspended", "newThenables", "getRenderTargetTime", "_suspended", "_newThenables", "previousSibling", "next", "popRenderLanes", "nextIsHidden", "_prevState", "prevIsHidden", "unwindWork", "flags", "_flags", "_flags2", "unwindInterruptedWork", "interruptedWork", "invokeGuardedCallbackProd", "func", "d", "f", "funcArgs", "invokeGuardedCallbackImpl", "fakeNode", "evt", "didCall", "windowEvent", "windowEventDescriptor", "restoreAfterDispatch", "evtType", "didSetError", "isCrossOriginError", "handleWindowError", "event", "inner", "invokeGuardedCallbackImpl$1", "hasError", "caughtError", "reporter", "invokeGuardedCallback", "hasCaughtError", "clearCaughtError", "didWarnAboutUndefinedSnapshotBeforeUpdate", "offscreenSubtreeIsHidden", "offscreenSubtreeWasHidden", "PossiblyWeakSet", "nextEffect", "inProgressLanes", "inProgressRoot", "reportUncaughtErrorInDEV", "callComponentWillUnmountWithTimer", "safelyCallCommitHookLayoutEffectListMount", "nearestMountedAncestor", "commitHookEffectListMount", "captureCommitPhaseError", "safelyCallComponentWillUnmount", "safelyCallComponentDidMount", "safelyAttachRef", "commitAttachRef", "safelyDetachRef", "retVal", "safelyCallDestroy", "focusedInstanceHandle", "shouldFireAfterActiveInstanceBlur", "commitBeforeMutationEffects", "commitBeforeMutationEffects_begin", "shouldFire", "commitBeforeMutationEffects_complete", "commitBeforeMutationEffectsOnFiber", "snapshot", "didWarnSet", "commitHookEffectListUnmount", "setIsRunningInsertionEffect", "commitPassiveEffectDurations", "finishedRoot", "passiveEffectDuration", "_finishedWork$memoize", "onPostCommit", "phase", "outer", "commitLayoutEffectOnFiber", "committedLanes", "_updateQueue", "_finishedWork$memoize2", "onCommit", "onRender", "effectDuration", "enqueuePendingPassiveProfilerEffect", "commitSuspenseHydrationCallbacks", "reappearLayoutEffectsOnFiber", "hideOrUnhideAllChildren", "hostSubtreeRoot", "_instance3", "instanceToUse", "detachFiberMutation", "detachFiberAfterEffects", "hostInstance", "emptyPortalContainer", "containerInfo", "emptyChildSet", "getHostParentFiber", "isHostParent", "getHostSibling", "siblings", "commitPlacement", "before", "insertOrAppendPlacementNode", "_parent", "_before", "insertOrAppendPlacementNodeIntoContainer", "isHost", "hostParent", "hostParentIsContainer", "commitDeletionEffects", "deletedFiber", "findParent", "commitDeletionEffectsOnFiber", "recursivelyTraverseDeletionEffects", "prevHostParent", "prevHostParentIsContainer", "_prevHostParent", "_prevHostParentIsContainer", "_effect", "prevOffscreenSubtreeWasHidden", "commitSuspenseCallback", "attachSuspenseRetryListeners", "retryCache", "resolveRetryWakeable", "commitMutationEffects", "commitMutationEffectsOnFiber", "recursivelyTraverseMutationEffects", "prevDebugFiber", "commitReconciliationEffects", "_instance4", "prevRootState", "pendingChildren", "_containerInfo", "_pendingChildren", "offscreenFiber", "offscreenInstance", "wasHidden", "markCommitTimeOfFallback", "_wasHidden", "_offscreenInstance", "_newState", "_isHidden", "offscreenBoundary", "offscreenChild", "disappearLayoutEffects_begin", "commitLayoutEffects", "commitLayoutEffects_begin", "subtreeRoot", "isModernRoot", "newOffscreenSubtreeIsHidden", "commitLayoutMountEffects_complete", "newOffscreenSubtreeWasHidden", "prevOffscreenSubtreeIsHidden", "reappearLayoutEffects_begin", "disappearLayoutEffects_complete", "reappearLayoutEffects_complete", "commitPassiveMountEffects", "committedTransitions", "commitPassiveMountEffects_begin", "commitPassiveMountEffects_complete", "commitPassiveMountOnFiber", "commitPassiveUnmountEffects", "commitPassiveUnmountEffects_begin", "fiberToDelete", "commitPassiveUnmountEffectsInsideOfDeletedTree_begin", "previousFiber", "detachedChild", "detachedSibling", "commitPassiveUnmountEffects_complete", "commitPassiveUnmountOnFiber", "deletedSubtreeRoot", "commitPassiveUnmountInsideDeletedTreeOnFiber", "commitPassiveUnmountEffectsInsideOfDeletedTree_complete", "invokeLayoutEffectMountInDEV", "invokePassiveEffectMountInDEV", "invokeLayoutEffectUnmountInDEV", "invokePassiveEffectUnmountInDEV", "COMPONENT_TYPE", "HAS_PSEUDO_CLASS_TYPE", "ROLE_TYPE", "TEST_NAME_TYPE", "TEXT_TYPE", "symbolFor", "createComponentSelector", "createHasPseudoClassSelector", "selectors", "createRoleSelector", "role", "createTextSelector", "createTestNameSelector", "findFiberRootForHostRoot", "hostRoot", "maybeFiber", "matchSelector", "selector", "hasMatchingPaths", "dataTestID", "selectorToString", "findPaths", "matchingFibers", "selectorIndex", "findAllNodes", "instanceRoots", "getFindAllNodesFailureDescription", "maxSelectorIndex", "matchedNames", "unmatchedNames", "findBoundingRects", "boundingRects", "targetRect", "targetLeft", "targetRight", "targetTop", "targetBottom", "j", "otherRect", "otherLeft", "otherRight", "otherTop", "otherBottom", "focusWithin", "commitHooks", "onCommitRoot$1", "commitHook", "observeVisibleRects", "_setupIntersectionObs", "disconnect", "observe", "unobserve", "nextInstanceRoots", "target", "ReactCurrentActQueue", "isLegacyActEnvironment", "isReactActEnvironmentGlobal", "jestIsDefined", "isConcurrentActEnvironment", "ceil", "ReactCurrentDispatcher$2", "ReactCurrentOwner$2", "ReactCurrentBatchConfig$2", "ReactCurrentActQueue$1", "NoContext", "BatchedContext", "RenderContext", "CommitContext", "RootInProgress", "RootFatalErrored", "RootErrored", "RootSuspended", "RootSuspendedWithDelay", "RootCompleted", "RootDidNotComplete", "executionContext", "workInProgressRoot", "workInProgressRootRenderLanes", "subtreeRenderLanesCursor", "workInProgressRootExitStatus", "workInProgressRootFatalError", "workInProgressRootIncludedLanes", "workInProgressRootSkippedLanes", "workInProgressRootInterleavedUpdatedLanes", "workInProgressRootPingedLanes", "workInProgressRootConcurrentErrors", "workInProgressRootRecoverableErrors", "globalMostRecentFallbackTime", "FALLBACK_THROTTLE_MS", "workInProgressRootRenderTargetTime", "RENDER_TIMEOUT_MS", "workInProgressTransitions", "resetRenderTimer", "hasUncaughtError", "firstUncaughtError", "legacyErrorBoundariesThatAlreadyFailed", "rootDoesHavePassiveEffects", "rootWithPendingPassiveEffects", "pendingPassiveEffectsLanes", "pendingPassiveProfilerEffects", "pendingPassiveTransitions", "NESTED_UPDATE_LIMIT", "nestedUpdateCount", "rootWithNestedUpdates", "isFlushingPassiveEffects", "didScheduleUpdateDuringPassiveEffects", "NESTED_PASSIVE_UPDATE_LIMIT", "nestedPassiveUpdateCount", "rootWithPassiveNestedUpdates", "currentEventTime", "currentEventTransitionLane", "isRunningInsertionEffect", "isTransition", "transition", "eventLane", "requestRetryLane", "checkForNestedUpdates", "warnAboutRenderPhaseUpdatesInDEV", "warnIfUpdatesNotWrappedWithActDEV", "markRootSuspended$1", "ensureRootIsScheduled", "scheduleInitialHydrationOnRoot", "existingCallbackNode", "cancelCallback$1", "newCallbackPriority", "existingCallbackPriority", "fakeActCallbackNode", "newCallbackNode", "performSyncWorkOnRoot", "scheduleCallback$1", "schedulerPriorityLevel", "performConcurrentWorkOnRoot", "didTimeout", "originalCallbackNode", "didFlushPassiveEffects", "flushPassiveEffects", "shouldTimeSlice", "exitStatus", "renderRootConcurrent", "renderRootSync", "errorRetryLanes", "recoverFromConcurrentError", "fatalError", "prepareFreshStack", "renderWasConcurrent", "isRenderConsistentWithExternalStores", "_errorRetryLanes", "_fatalError", "finishConcurrentRender", "errorsFromFirstAttempt", "rootWorkInProgress", "errorsFromSecondAttempt", "errors", "commitRoot", "shouldForceFlushFallbacksInDEV", "msUntilTimeout", "eventTimeMs", "timeElapsedMs", "_msUntilTimeout", "jnd", "checks", "renderedValue", "flushRoot", "deferredUpdates", "batchedUpdates", "prevExecutionContext", "discreteUpdates", "flushSync", "isAlreadyRendering", "flushControlled", "timeoutHandle", "handleError", "erroredWork", "completeUnitOfWork", "yetAnotherThrownValue", "pushDispatcher", "popDispatcher", "workLoopSync", "performUnitOfWork", "workLoopConcurrent", "unitOfWork", "beginWork$1", "_next", "siblingFiber", "recoverableErrors", "transitions", "previousUpdateLanePriority", "commitRootImpl", "renderPriorityLevel", "flushRenderPhaseStrictModeWarningsInDEV", "subtreeHasEffects", "rootHasEffect", "rootDidHavePassiveEffects", "commitDoubleInvokeEffectsInDEV", "onRecoverableError", "renderPriority", "flushPassiveEffectsImpl", "profilerEffects", "_fiber", "prepareToThrowUncaughtError", "captureCommitPhaseErrorOnRoot", "rootFiber", "warnIfSuspenseResolutionNotWrappedWithActDEV", "retryTimedOutBoundary", "boundaryFiber", "retryLane", "timeElapsed", "hasPassiveEffects", "invokeEffectsInDev", "invokeEffectFn", "primarySubtreeFlag", "didWarnStateUpdateForNotYetMountedComponent", "dummyFiber", "originalWorkInProgressCopy", "assignFiberPropertiesInDEV", "originalError", "replayError", "didWarnAboutUpdateInRender", "didWarnAboutUpdateInRenderForAnotherComponent", "renderingComponentName", "dedupeKey", "setStateComponentName", "schedulingFiber", "priorityLevel", "actQueue", "callbackNode", "isRunning", "resolveFamily", "failedBoundaries", "setRefreshHandler", "handler", "family", "currentRender", "syntheticType", "prevType", "nextType", "needsCompareFamilies", "$$typeofNextType", "prevFamily", "scheduleRefresh", "staleFamilies", "updatedFamilies", "scheduleFibersWithFamiliesRecursively", "scheduleRoot", "updateContainer", "candidateType", "needsRender", "needsRemount", "_root", "findHostInstancesForRefresh", "families", "hostInstances", "types", "findHostInstancesForMatchingFibersRecursively", "didMatch", "findHostInstancesForFiberShallowly", "foundHostInstances", "findChildHostInstancesForFiberShallowly", "hasBadMapPolyfill", "nonExtensibleObject", "FiberNode", "createFiber", "shouldConstruct$1", "$$typeof", "currentDependencies", "createHostRootFiber", "isStrictMode", "concurrentUpdatesByDefaultOverride", "fiberTag", "getTag", "createFiberFromProfiler", "createFiberFromSuspense", "createFiberFromSuspenseList", "elements", "primaryChildInstance", "content", "dehydratedNode", "FiberRootNode", "hydrate", "createFiberRoot", "initialChildren", "hydrationCallbacks", "transitionCallbacks", "uninitializedFiber", "_initialState", "ReactVersion", "createPortal", "implementation", "didWarnAboutNestedUpdates", "didWarnAboutFindNodeInStrictMode", "getContextForSubtree", "parentComponent", "findHostInstance", "keys", "hostFiber", "findHostInstanceWithWarning", "methodName", "createContainer", "createHydrationContainer", "current$1", "getPublicRootInstance", "containerFiber", "attemptSynchronousHydration", "markRetryLaneIfNotHydrated", "markRetryLaneImpl", "attemptDiscreteHydration", "attemptContinuousHydration", "attemptHydrationAtCurrentPriority", "findHostInstanceWithNoPortals", "shouldErrorImpl", "shouldSuspendImpl", "overrideHookState", "overrideHookStateDeletePath", "overrideHookStateRenamePath", "overrideProps", "overridePropsDeletePath", "overridePropsRenamePath", "scheduleUpdate", "setErrorHandler", "setSuspenseHandler", "copyWithDeleteImpl", "obj", "path", "updated", "copyWithDelete", "copyWithRenameImpl", "oldPath", "newPath", "oldKey", "newKey", "copyWithRename", "copyWithSetImpl", "copyWithSet", "findHook", "newShouldErrorImpl", "newShouldSuspendImpl", "findHostInstanceByFiber", "emptyFindFiberByHostInstance", "getCurrentFiberForDevTools", "injectIntoDevTools", "devToolsConfig", "findFiberByHostInstance", "require_react_reconciler", "__commonJSMin", "exports", "module", "require_react_jsx_runtime_development", "__commonJSMin", "exports", "React", "REACT_ELEMENT_TYPE", "REACT_PORTAL_TYPE", "REACT_FRAGMENT_TYPE", "REACT_STRICT_MODE_TYPE", "REACT_PROFILER_TYPE", "REACT_PROVIDER_TYPE", "REACT_CONTEXT_TYPE", "REACT_FORWARD_REF_TYPE", "REACT_SUSPENSE_TYPE", "REACT_SUSPENSE_LIST_TYPE", "REACT_MEMO_TYPE", "REACT_LAZY_TYPE", "REACT_OFFSCREEN_TYPE", "MAYBE_ITERATOR_SYMBOL", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "maybeIterator", "ReactSharedInternals", "error", "format", "_len2", "args", "_key2", "printWarning", "level", "ReactDebugCurrentFrame", "stack", "argsWithFormat", "item", "enableScopeAPI", "enableCacheElement", "enableTransitionTracing", "enableLegacyHidden", "enableDebugTracing", "REACT_MODULE_REFERENCE", "isValidElementType", "type", "getWrappedName", "outerType", "innerType", "wrapperName", "displayName", "functionName", "getContextName", "getComponentNameFromType", "context", "provider", "outerName", "lazyComponent", "payload", "init", "x", "assign", "disabledDepth", "prevLog", "prevInfo", "prevWarn", "prevError", "prevGroup", "prevGroupCollapsed", "prevGroupEnd", "disabledLog", "disableLogs", "props", "reenableLogs", "ReactCurrentDispatcher", "prefix", "describeBuiltInComponentFrame", "name", "source", "ownerFn", "match", "reentry", "componentFrameCache", "PossiblyWeakMap", "describeNativeComponentFrame", "fn", "construct", "frame", "control", "previousPrepareStackTrace", "previousDispatcher", "Fake", "sample", "sampleLines", "controlLines", "s", "c", "_frame", "syntheticFrame", "describeFunctionComponentFrame", "shouldConstruct", "Component", "prototype", "describeUnknownElementTypeFrameInDEV", "hasOwnProperty", "loggedTypeFailures", "setCurrentlyValidatingElement", "element", "owner", "checkPropTypes", "typeSpecs", "values", "location", "componentName", "has", "typeSpecName", "error$1", "err", "ex", "isArrayImpl", "isArray", "a", "typeName", "value", "hasToStringTag", "willCoercionThrow", "testStringCoercion", "e", "checkKeyStringCoercion", "ReactCurrentOwner", "RESERVED_PROPS", "specialPropKeyWarningShown", "specialPropRefWarningShown", "didWarnAboutStringRefs", "hasValidRef", "config", "getter", "hasValidKey", "warnIfStringRefCannotBeAutoConverted", "self", "defineKeyPropWarningGetter", "warnAboutAccessingKey", "defineRefPropWarningGetter", "warnAboutAccessingRef", "ReactElement", "key", "ref", "jsxDEV", "maybeKey", "propName", "defaultProps", "ReactCurrentOwner$1", "ReactDebugCurrentFrame$1", "setCurrentlyValidatingElement$1", "propTypesMisspellWarningShown", "isValidElement", "object", "getDeclarationErrorAddendum", "getSourceInfoErrorAddendum", "fileName", "lineNumber", "ownerHasKeyUseWarning", "getCurrentComponentErrorInfo", "parentType", "info", "parentName", "validateExplicitKey", "currentComponentErrorInfo", "childOwner", "validateChildKeys", "node", "i", "child", "iteratorFn", "iterator", "step", "validatePropTypes", "propTypes", "_name", "validateFragmentProps", "fragment", "keys", "didWarnAboutKeySpread", "jsxWithValidation", "isStaticChildren", "validType", "sourceInfo", "typeString", "children", "k", "beforeExample", "afterExample", "jsxWithValidationStatic", "jsxWithValidationDynamic", "jsx", "jsxs", "require_jsx_runtime", "__commonJSMin", "exports", "module", "import_react", "isBasicObject", "value", "prototype", "isRemoteFragment", "object", "FUNCTION_CURRENT_IMPLEMENTATION_KEY", "EMPTY_OBJECT", "EMPTY_ARRAY", "createRemoteRoot", "channel", "strict", "components", "currentId", "rootInternals", "remoteRoot", "type", "rest", "initialProps", "initialChildren", "moreChildren", "normalizedInitialProps", "normalizedInitialChildren", "normalizedInternalProps", "key", "makeValueHotSwappable", "serializeProp", "child", "normalizeChild", "id", "internals", "component", "__spreadValues", "remove", "newProps", "updateProps", "children", "append", "appendChild", "removeChild", "replaceChildren", "before", "insertBefore", "makePartOfTree", "makeRemote", "moveNodeToContainer", "content", "update", "newText", "updateText", "text", "fragment", "serializeChild", "connected", "element", "tops", "_tops$get", "allDescendants", "withEach", "recurse", "perform", "remote", "local", "mounted", "IGNORE", "currentProps", "currentExternalProps", "normalizedNewProps", "hotSwapFunctions", "hasRemoteChange", "currentExternalValue", "newExternalValue", "currentValue", "newValue", "value", "hotSwaps", "tryHotSwappingValues", "isRemoteFragment", "removeNodeFromContainer", "mergedExternalProps", "hotSwappable", "seen", "tryHotSwappingArrayValues", "isBasicObject", "tryHotSwappingObjectValues", "seenValue", "result", "nested", "wrappedFunction", "args", "collectNestedHotSwappableValues", "all", "_child$parent", "container", "_currentParent$childr", "nodes", "currentParent", "existingIndex", "newChildren", "currentInternals", "getCurrentInternals", "currentChildren", "childIndex", "_currentParent$childr2", "beforeIndex", "root", "node", "parents", "newTop", "moveFragmentToContainer", "descendant", "props", "prop", "removeFragmentFromContainer", "serializeFragment", "_collectNestedHotSwap", "hasChanged", "normalizedNewValue", "currentObjectValue", "nestedHotSwappables", "newObjectValue", "updatedValue", "elementHotSwaps", "_collectNestedHotSwap2", "newLength", "currentLength", "maxLength", "i", "currentArrayValue", "newArrayValue", "createExtensionRegistrationFunction", "target", "implementation", "_shopify", "extension", "args", "__async", "channel", "components", "api", "root", "createRemoteRoot", "renderResult", "extension", "createExtensionRegistrationFunction", "AdminAction", "Banner", "BlockStack", "Button", "Link", "ProgressIndicator", "import_react", "ExtensionApiContext", "import_react", "import_react_reconciler", "createReconciler", "options", "_options$primary", "reactReconciler", "scheduleMicrotask", "context", "text", "root", "type", "allProps", "_a", "_children", "props", "__objRest", "_oldText", "newText", "_instance", "_type", "oldProps", "newProps", "updateProps", "needsUpdate", "key", "has", "instance", "payload", "remoteRoot", "child", "beforeChild", "parent", "newChild", "callback", "handleErrorInNextTick", "error", "hasOwnProperty", "object", "property", "import_react", "RenderContext", "import_jsx_runtime", "cache", "LEGACY_ROOT", "defaultReconciler", "createReconciler", "createRoot", "root", "children", "render", "element", "callback", "reconciler", "cached", "_version$split", "value", "container", "renderContext", "RenderContext", "import_react", "import_jsx_runtime", "import_react", "useRender", "render", "RenderContext", "createRemoteReactComponent", "componentType", "fragmentProps", "wrapper", "createComponentWrapper", "Component", "_a", "_b", "externalChildren", "externalProps", "__objRest", "fragments", "root", "reconciler", "useRender", "props", "children", "portals", "key", "element", "currentFragment", "fragment", "isRemoteFragment", "args", "type", "portal", "__spreadProps", "__spreadValues", "remoteRootRender", "node", "root", "resolve", "reject", "remoteRoot", "createRoot", "error", "import_jsx_runtime", "reactExtension", "target", "render", "extension", "root", "api", "__async", "element", "remoteRootRender", "ExtensionApiContext", "AdminAction", "createRemoteReactComponent", "Banner", "createRemoteReactComponent", "BlockStack", "createRemoteReactComponent", "Button", "createRemoteReactComponent", "Link", "createRemoteReactComponent", "ProgressIndicator", "createRemoteReactComponent", "import_react", "AdminUIExtensionError", "args", "useApi", "_target", "api", "ExtensionApiContext", "AdminUIExtensionError", "import_jsx_runtime", "TARGET", "ActionExtension_default", "reactExtension", "App", "ORDER_QUERY", "_a", "_b", "close", "data", "useApi", "orderId", "order", "setOrder", "loading", "setLoading", "error", "setError", "__async", "orderData", "e", "AdminAction", "BlockStack", "ProgressIndicator", "Button", "Banner", "orderNumber", "Link"]
}
